[{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Code of Conduct","text":"members, contributors, leaders pledge make participation project harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Code of Conduct","text":"Examples behavior contributes positive environment include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes Focusing best community project Examples unacceptable behavior include: Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Code of Conduct","text":"Project maintainers responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Project maintainers right responsibility remove, edit, reject comments, commits, code, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Code of Conduct","text":"Code Conduct applies within project spaces, including GitHub repositories, issue trackers, pull requests, discussions, communication channels associated project. also applies individual officially representing project public spaces.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project maintainer(s). complaints reviewed investigated promptly fairly. Project maintainers obligated respect privacy security reporter incident.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Code of Conduct","text":"Project maintainers follow Community Impact Guidelines determining consequences action deem violation Code Conduct: Correction private, written warning providing clarity around nature violation explanation behavior inappropriate. Warning warning consequences continued behavior. Temporary Ban temporary ban sort interaction public communication project. Permanent Ban permanent ban sort public interaction within project.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1. Available : https://www.contributor-covenant.org/version/2/1/code_of_conduct.html","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to geospatialsuite","title":"Contributing to geospatialsuite","text":"Thank interest contributing geospatialsuite! welcome contributions community.","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"reporting-issues","dir":"","previous_headings":"How to Contribute","what":"Reporting Issues","title":"Contributing to geospatialsuite","text":"Use GitHub Issues page Provide minimal reproducible example Include R version package version Describe expected vs actual behavior","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"suggesting-enhancements","dir":"","previous_headings":"How to Contribute","what":"Suggesting Enhancements","title":"Contributing to geospatialsuite","text":"Open issue “enhancement” label Clearly describe proposed feature Explain use case benefits","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"pull-requests","dir":"","previous_headings":"How to Contribute","what":"Pull Requests","title":"Contributing to geospatialsuite","text":"Fork repository Create new branch (git checkout -b feature/-feature) Make changes Add tests new functionality Update documentation needed Ensure tests pass: devtools::test() Submit pull request","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"How to Contribute","what":"Code Style","title":"Contributing to geospatialsuite","text":"Follow standard R package conventions Use roxygen2 documentation Include examples function documentation Add unit tests new functions","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"How to Contribute","what":"Testing","title":"Contributing to geospatialsuite","text":"Run test suite submitting:","code":"library(devtools) devtools::test() test_geospatialsuite_package_simple()"},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to geospatialsuite","text":"committed providing welcoming inclusive experience everyone. Please respectful professional interactions.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"questions","dir":"","previous_headings":"","what":"Questions?","title":"Contributing to geospatialsuite","text":"Contact maintainers: - Olatunde D. Akanbi: olatunde.akanbi@case.edu - Roger H. French: roger.french@case.edu","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contributing to geospatialsuite","text":"contributing, agree contributions licensed MIT License.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"agricultural-applications-with-geospatialsuite","dir":"Articles","previous_headings":"","what":"Agricultural Applications with geospatialsuite","title":"Agricultural Applications with geospatialsuite","text":"vignette demonstrates comprehensive agricultural analysis capabilities including USDA CDL integration, crop monitoring, stress detection, yield assessment workflows.","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"time-series-ndvi-monitoring","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Enhanced NDVI Analysis for Agriculture","what":"Time Series NDVI Monitoring","title":"Agricultural Applications with geospatialsuite","text":"Use enhanced NDVI calculation multi-temporal crop monitoring:","code":"# Enhanced NDVI with quality filtering ndvi_enhanced <- calculate_ndvi_enhanced(   red_data = red_band,   nir_data = nir_band,   quality_filter = TRUE,   temporal_smoothing = FALSE,  # Single date   verbose = TRUE )  # Visualize enhanced NDVI create_ndvi_map(   ndvi_data = ndvi_enhanced,   title = \"Enhanced NDVI with Quality Filtering\",   ndvi_classes = \"none\" )  print(\"Enhanced NDVI Analysis:\") ndvi_values <- terra::values(ndvi_enhanced, mat = FALSE) valid_ndvi <- ndvi_values[!is.na(ndvi_values)] print(paste(\"Mean NDVI:\", round(mean(valid_ndvi), 3))) print(paste(\"NDVI range:\", paste(round(range(valid_ndvi), 3), collapse = \" - \")))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"multi-index-crop-assessment","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Enhanced NDVI Analysis for Agriculture","what":"Multi-Index Crop Assessment","title":"Agricultural Applications with geospatialsuite","text":"Calculate multiple vegetation indices comprehensive crop assessment:","code":"# Calculate multiple indices relevant to agriculture agricultural_indices <- calculate_multiple_indices(   red = red_band,   nir = nir_band,   indices = c(\"NDVI\", \"SAVI\", \"MSAVI\", \"DVI\", \"RVI\"),   output_stack = TRUE,   verbose = TRUE )  print(\"Agricultural Indices Calculated:\") print(names(agricultural_indices))  # Visualize key indices if (terra::nlyr(agricultural_indices) >= 2) {   # NDVI visualization   create_spatial_map(     spatial_data = agricultural_indices[[1]],     title = \"NDVI for Agricultural Assessment\",     color_scheme = \"ndvi\"   )      # SAVI visualization (soil-adjusted)   if (\"SAVI\" %in% names(agricultural_indices)) {     plot_raster_fast(       agricultural_indices[[\"SAVI\"]],       title = \"SAVI (Soil Adjusted Vegetation Index)\",       color_scheme = \"viridis\"     )   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"yield-potential-assessment","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Yield Prediction Support","what":"Yield Potential Assessment","title":"Agricultural Applications with geospatialsuite","text":"Assess yield potential using vegetation indices:","code":"# Extract yield analysis if available if (!is.null(crop_analysis$analysis_results$yield_analysis)) {   yield_results <- crop_analysis$analysis_results$yield_analysis      print(\"Yield Potential Analysis:\")   if (!\"error\" %in% names(yield_results)) {     print(paste(\"Composite yield index:\", round(yield_results$composite_yield_index, 3)))     print(paste(\"Yield potential class:\", yield_results$yield_potential_class))     print(paste(\"Classification confidence:\", round(yield_results$classification_confidence, 3)))          print(\"Index contributions to yield assessment:\")     for (idx in names(yield_results$index_contributions)) {       contrib <- yield_results$index_contributions[[idx]]       print(paste(\"  \", idx, \"- Normalized:\", round(contrib$mean_normalized, 3),                   \"Raw mean:\", round(contrib$raw_mean, 3)))     }   } }  # Create yield potential map visualization yield_potential_raster <- agricultural_indices[[1]]  # Use NDVI as proxy terra::values(yield_potential_raster) <- ifelse(terra::values(yield_potential_raster) > 0.6, 3,                                                ifelse(terra::values(yield_potential_raster) > 0.4, 2, 1)) names(yield_potential_raster) <- \"Yield_Potential\"  plot_raster_fast(   yield_potential_raster,   title = \"Yield Potential Classification\",   color_scheme = \"terrain\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"crop-performance-metrics","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Yield Prediction Support","what":"Crop Performance Metrics","title":"Agricultural Applications with geospatialsuite","text":"Calculate key performance indicators agricultural monitoring:","code":"# Calculate comprehensive vegetation statistics if (inherits(agricultural_indices, \"SpatRaster\")) {   veg_stats <- list()      for (i in 1:terra::nlyr(agricultural_indices)) {     index_name <- names(agricultural_indices)[i]     values <- terra::values(agricultural_indices[[i]], mat = FALSE)     valid_values <- values[!is.na(values)]          if (length(valid_values) > 0) {       veg_stats[[index_name]] <- list(         mean = mean(valid_values),         median = median(valid_values),         sd = sd(valid_values),         cv = sd(valid_values) / mean(valid_values),         min = min(valid_values),         max = max(valid_values),         q25 = quantile(valid_values, 0.25),         q75 = quantile(valid_values, 0.75)       )     }   }      print(\"Crop Performance Metrics:\")   for (index in names(veg_stats)) {     stats <- veg_stats[[index]]     print(paste(index, \"- Mean:\", round(stats$mean, 3),                  \"CV:\", round(stats$cv, 3),                 \"Range:\", paste(round(c(stats$min, stats$max), 3), collapse = \"-\")))   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"field-level-analysis","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Precision Agriculture Applications","what":"Field-Level Analysis","title":"Agricultural Applications with geospatialsuite","text":"Analyze individual fields management zones:","code":"# Create sample field boundaries field_1 <- sf::st_polygon(list(matrix(c(   -83.5, 40.0, -83.3, 40.0, -83.3, 40.2, -83.5, 40.2, -83.5, 40.0 ), ncol = 2, byrow = TRUE)))  field_2 <- sf::st_polygon(list(matrix(c(   -83.3, 40.0, -83.1, 40.0, -83.1, 40.2, -83.3, 40.2, -83.3, 40.0 ), ncol = 2, byrow = TRUE)))  fields_sf <- sf::st_sf(   field_id = c(\"Field_1\", \"Field_2\"),   crop_type = c(\"Corn\", \"Soybeans\"),   geometry = sf::st_sfc(field_1, field_2, crs = 4326) )  # Extract vegetation statistics by field using spatial join field_analysis <- universal_spatial_join(   source_data = agricultural_indices,   target_data = fields_sf,   method = \"zonal\",   summary_function = \"mean\",   verbose = TRUE )  print(\"Field-Level Analysis Results:\") if (inherits(field_analysis, \"sf\")) {   print(sf::st_drop_geometry(field_analysis)) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"variable-rate-application-support","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Precision Agriculture Applications","what":"Variable Rate Application Support","title":"Agricultural Applications with geospatialsuite","text":"Support precision agriculture spatial variability analysis:","code":"# Calculate coefficient of variation for management zones if (inherits(agricultural_indices, \"SpatRaster\") && terra::nlyr(agricultural_indices) > 0) {   # Use NDVI for variability analysis   ndvi_layer <- agricultural_indices[[1]]      # Calculate local variability using focal statistics   local_cv <- terra::focal(ndvi_layer, w = matrix(1, 3, 3),                             fun = function(x) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE))   names(local_cv) <- \"Local_CV\"      # Classify variability zones   variability_zones <- terra::classify(local_cv,                                         matrix(c(0, 0.1, 1,     # Low variability                                                0.1, 0.2, 2,    # Medium variability                                                  0.2, 1, 3),     # High variability                                               ncol = 3, byrow = TRUE))   names(variability_zones) <- \"Variability_Zones\"      # Visualize variability   plot_raster_fast(     local_cv,     title = \"Spatial Variability (Coefficient of Variation)\",     color_scheme = \"plasma\"   )      plot_raster_fast(     variability_zones,     title = \"Management Zones (1=Low, 2=Medium, 3=High Variability)\",     color_scheme = \"categorical\"   ) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"disease-and-stress-detection","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Crop Health Monitoring","what":"Disease and Stress Detection","title":"Agricultural Applications with geospatialsuite","text":"Use vegetation indices detect crop stress disease:","code":"# Create stress detection workflow stress_indices <- c(\"NDVI\", \"SAVI\", \"DVI\")  # Calculate stress thresholds based on crop type corn_thresholds <- list(   healthy = list(NDVI = c(0.6, 1.0), SAVI = c(0.4, 0.8)),   stressed = list(NDVI = c(0.3, 0.6), SAVI = c(0.2, 0.4)),   severely_stressed = list(NDVI = c(0.0, 0.3), SAVI = c(0.0, 0.2)) )  # Apply stress classification if (inherits(agricultural_indices, \"SpatRaster\") && \"NDVI\" %in% names(agricultural_indices)) {   ndvi_values <- terra::values(agricultural_indices[[\"NDVI\"]], mat = FALSE)      # Classify stress levels   stress_classification <- ifelse(ndvi_values >= 0.6, \"Healthy\",                                  ifelse(ndvi_values >= 0.3, \"Moderate Stress\", \"Severe Stress\"))      # Create stress map   stress_raster <- agricultural_indices[[\"NDVI\"]]   stress_numeric <- ifelse(ndvi_values >= 0.6, 3,                           ifelse(ndvi_values >= 0.3, 2, 1))   terra::values(stress_raster) <- stress_numeric   names(stress_raster) <- \"Stress_Level\"      plot_raster_fast(     stress_raster,     title = \"Crop Stress Classification (1=Severe, 2=Moderate, 3=Healthy)\",     color_scheme = \"terrain\"   )      # Calculate stress statistics   stress_table <- table(stress_classification)   stress_percent <- round(prop.table(stress_table) * 100, 1)      print(\"Crop Stress Distribution:\")   for (level in names(stress_table)) {     print(paste(level, \":\", stress_table[[level]], \"pixels (\", stress_percent[[level]], \"%)\"))   } }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"early-warning-systems","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Crop Health Monitoring","what":"Early Warning Systems","title":"Agricultural Applications with geospatialsuite","text":"Create early warning systems crop management:","code":"# Define warning thresholds warning_thresholds <- list(   drought_stress = 0.4,    # NDVI below this indicates drought stress   disease_risk = 0.3,      # NDVI below this indicates disease risk   optimal_growth = 0.7     # NDVI above this indicates optimal conditions )  # Generate alerts if (exists(\"ndvi_values\")) {   alerts <- list()      # Calculate percentages in each category   drought_pixels <- sum(ndvi_values < warning_thresholds$drought_stress, na.rm = TRUE)   disease_pixels <- sum(ndvi_values < warning_thresholds$disease_risk, na.rm = TRUE)   optimal_pixels <- sum(ndvi_values > warning_thresholds$optimal_growth, na.rm = TRUE)   total_pixels <- sum(!is.na(ndvi_values))      alerts$drought_risk <- round((drought_pixels / total_pixels) * 100, 1)   alerts$disease_risk <- round((disease_pixels / total_pixels) * 100, 1)   alerts$optimal_conditions <- round((optimal_pixels / total_pixels) * 100, 1)      print(\"Agricultural Alert System:\")   print(paste(\"Drought stress risk:\", alerts$drought_risk, \"% of field\"))   print(paste(\"Disease risk:\", alerts$disease_risk, \"% of field\"))   print(paste(\"Optimal conditions:\", alerts$optimal_conditions, \"% of field\"))      # Generate recommendations   if (alerts$drought_risk > 20) {     print(\"RECOMMENDATION: Consider irrigation scheduling\")   }   if (alerts$disease_risk > 10) {     print(\"RECOMMENDATION: Increase disease monitoring\")   }   if (alerts$optimal_conditions > 70) {     print(\"STATUS: Crop conditions are generally favorable\")   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"multi-temporal-analysis","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Seasonal Crop Monitoring","what":"Multi-Temporal Analysis","title":"Agricultural Applications with geospatialsuite","text":"Track crop development throughout growing season:","code":"# Simulate time series data for growing season growth_stages <- c(\"Planting\", \"V6\", \"V12\", \"R1\", \"R3\", \"R6\") ndvi_progression <- c(0.2, 0.4, 0.7, 0.8, 0.75, 0.6)  # Create time series visualization concept seasonal_data <- data.frame(   Stage = growth_stages,   NDVI = ndvi_progression,   DOY = c(120, 150, 180, 200, 220, 260)  # Day of year )  print(\"Seasonal NDVI Progression:\") print(seasonal_data)  # Create conceptual growth curve if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)      growth_plot <- ggplot(seasonal_data, aes(x = DOY, y = NDVI)) +     geom_line(color = \"darkgreen\", size = 1.2) +     geom_point(color = \"red\", size = 3) +     geom_text(aes(label = Stage), vjust = -0.5) +     labs(title = \"Typical Corn NDVI Progression\",          x = \"Day of Year\",          y = \"NDVI Value\") +     theme_minimal() +     ylim(0, 1)      print(growth_plot) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"harvest-timing-optimization","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Seasonal Crop Monitoring","what":"Harvest Timing Optimization","title":"Agricultural Applications with geospatialsuite","text":"Use vegetation indices optimize harvest timing:","code":"# Define maturity indicators based on NDVI decline maturity_thresholds <- list(   corn = list(     early_maturity = 0.7,     # NDVI starts declining     harvest_ready = 0.5,      # Optimal harvest window     post_harvest = 0.3        # Past optimal timing   ),   soybeans = list(     early_maturity = 0.6,     harvest_ready = 0.4,     post_harvest = 0.25   ) )  # Calculate harvest readiness if (exists(\"ndvi_values\")) {   # Use corn thresholds for demonstration   thresholds <- maturity_thresholds$corn      harvest_assessment <- list(     early_maturity = sum(ndvi_values <= thresholds$early_maturity &                          ndvi_values > thresholds$harvest_ready, na.rm = TRUE),     harvest_ready = sum(ndvi_values <= thresholds$harvest_ready &                         ndvi_values > thresholds$post_harvest, na.rm = TRUE),     post_optimal = sum(ndvi_values <= thresholds$post_harvest, na.rm = TRUE),     still_growing = sum(ndvi_values > thresholds$early_maturity, na.rm = TRUE)   )      total_pixels <- sum(!is.na(ndvi_values))      print(\"Harvest Timing Assessment:\")   for (stage in names(harvest_assessment)) {     percentage <- round((harvest_assessment[[stage]] / total_pixels) * 100, 1)     print(paste(stage, \":\", harvest_assessment[[stage]], \"pixels (\", percentage, \"%)\"))   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"irrigation-needs-assessment","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Water Management for Agriculture","what":"Irrigation Needs Assessment","title":"Agricultural Applications with geospatialsuite","text":"Use water indices assess irrigation requirements:","code":"# Calculate water-related indices green_band <- red_band terra::values(green_band) <- runif(2500, 0.1, 0.2) names(green_band) <- \"Green\"  # Calculate NDWI for water stress detection ndwi <- calculate_water_index(   green = green_band,   nir = nir_band,   index_type = \"NDWI\",   verbose = TRUE )  # Irrigation needs based on NDWI ndwi_values <- terra::values(ndwi, mat = FALSE) valid_ndwi <- ndwi_values[!is.na(ndwi_values)]  if (length(valid_ndwi) > 0) {   irrigation_zones <- ifelse(valid_ndwi < -0.3, \"High Need\",                            ifelse(valid_ndwi < -0.1, \"Moderate Need\", \"Adequate\"))      irrigation_table <- table(irrigation_zones)   irrigation_percent <- round(prop.table(irrigation_table) * 100, 1)      print(\"Irrigation Needs Assessment:\")   for (zone in names(irrigation_table)) {     print(paste(zone, \":\", irrigation_table[[zone]], \"pixels (\", irrigation_percent[[zone]], \"%)\"))   }      # Visualize irrigation zones   irrigation_raster <- ndwi   terra::values(irrigation_raster) <- as.numeric(as.factor(irrigation_zones))   names(irrigation_raster) <- \"Irrigation_Needs\"      plot_raster_fast(     irrigation_raster,     title = \"Irrigation Needs Assessment (1=Adequate, 2=High, 3=Moderate)\",     color_scheme = \"water\"   ) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"multi-year-crop-tracking","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Crop Rotation Analysis","what":"Multi-Year Crop Tracking","title":"Agricultural Applications with geospatialsuite","text":"Analyze crop rotation patterns using multi-temporal CDL data:","code":"# Simulate multi-year CDL data create_rotation_analysis <- function() {   # Create sample rotation data   rotation_data <- data.frame(     year = rep(2021:2023, each = 4),     field = rep(c(\"Field_A\", \"Field_B\", \"Field_C\", \"Field_D\"), 3),     crop = c(       \"Corn\", \"Soybeans\", \"Corn\", \"Wheat\",      # 2021       \"Soybeans\", \"Corn\", \"Soybeans\", \"Corn\",   # 2022       \"Corn\", \"Soybeans\", \"Corn\", \"Soybeans\"   # 2023     ),     yield = runif(12, 80, 200)   )      return(rotation_data) }  rotation_analysis <- create_rotation_analysis() print(\"Crop Rotation Analysis:\") print(rotation_analysis)  # Analyze rotation patterns rotation_patterns <- list() fields <- unique(rotation_analysis$field)  for (field in fields) {   field_data <- rotation_analysis[rotation_analysis$field == field, ]   rotation_patterns[[field]] <- paste(field_data$crop, collapse = \" Ã¢â€ â€™ \") }  print(\"Rotation Patterns:\") for (field in names(rotation_patterns)) {   print(paste(field, \":\", rotation_patterns[[field]])) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"sustainable-agriculture-metrics","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Crop Rotation Analysis","what":"Sustainable Agriculture Metrics","title":"Agricultural Applications with geospatialsuite","text":"Calculate sustainability indicators:","code":"# Calculate diversity index for crop rotation calculate_crop_diversity <- function(rotation_data) {   diversity_scores <- list()      for (field in unique(rotation_data$field)) {     field_crops <- rotation_data$crop[rotation_data$field == field]     unique_crops <- length(unique(field_crops))     total_years <- length(field_crops)          # Simple diversity score (0-1, higher = more diverse)     diversity_scores[[field]] <- unique_crops / total_years   }      return(diversity_scores) }  diversity_scores <- calculate_crop_diversity(rotation_analysis)  print(\"Crop Diversity Scores (Higher = More Diverse):\") for (field in names(diversity_scores)) {   print(paste(field, \":\", round(diversity_scores[[field]], 2))) }  # Sustainability recommendations avg_diversity <- mean(unlist(diversity_scores)) print(paste(\"Average field diversity:\", round(avg_diversity, 2)))  if (avg_diversity < 0.5) {   print(\"RECOMMENDATION: Consider more diverse crop rotations\") } else if (avg_diversity > 0.8) {   print(\"STATUS: Good crop diversity maintained\") }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"data-export-for-farm-software","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Integration with Farm Management","what":"Data Export for Farm Software","title":"Agricultural Applications with geospatialsuite","text":"Prepare analysis results integration farm management systems:","code":"# Create farm-ready data export create_farm_export <- function(analysis_results, field_boundaries) {   # Compile key metrics for farm management   farm_data <- list(     summary_statistics = list(),     recommendations = list(),     alerts = list()   )      # Extract key metrics   if (exists(\"veg_stats\") && length(veg_stats) > 0) {     farm_data$summary_statistics <- veg_stats   }      # Generate management recommendations   if (exists(\"alerts\")) {     if (alerts$drought_risk > 20) {       farm_data$recommendations <- c(farm_data$recommendations,                                     \"Increase irrigation frequency\")     }     if (alerts$disease_risk > 15) {       farm_data$recommendations <- c(farm_data$recommendations,                                    \"Monitor for disease symptoms\")     }   }      return(farm_data) }  # Export field-level results if (exists(\"field_analysis\") && inherits(field_analysis, \"sf\")) {   field_summary <- sf::st_drop_geometry(field_analysis)      # Add coordinates for GPS guidance   field_centroids <- sf::st_centroid(field_analysis)   field_coords <- sf::st_coordinates(field_centroids)   field_summary$centroid_lon <- field_coords[, 1]   field_summary$centroid_lat <- field_coords[, 2]      print(\"Field Summary for Farm Management:\")   print(field_summary) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"economic-analysis-support","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Integration with Farm Management","what":"Economic Analysis Support","title":"Agricultural Applications with geospatialsuite","text":"Calculate economic indicators vegetation analysis:","code":"# Estimate economic value based on vegetation health calculate_economic_metrics <- function(ndvi_data, crop_prices) {   if (!exists(\"ndvi_values\")) return(NULL)      # Simplified yield prediction based on NDVI   # (In practice, would use crop-specific models)   predicted_yield <- ifelse(ndvi_values > 0.7, \"High\",                            ifelse(ndvi_values > 0.5, \"Medium\", \"Low\"))      yield_table <- table(predicted_yield)      # Economic projections (simplified)   economic_zones <- list(     high_yield = sum(predicted_yield == \"High\", na.rm = TRUE),     medium_yield = sum(predicted_yield == \"Medium\", na.rm = TRUE),      low_yield = sum(predicted_yield == \"Low\", na.rm = TRUE)   )      return(economic_zones) }  # Calculate economic zones if (exists(\"ndvi_values\")) {   economic_analysis <- calculate_economic_metrics(ndvi_values,                                                    list(corn = 5.50, soybeans = 13.00))      if (!is.null(economic_analysis)) {     total_pixels <- sum(unlist(economic_analysis))          print(\"Economic Potential Analysis:\")     for (zone in names(economic_analysis)) {       pixels <- economic_analysis[[zone]]       percentage <- round((pixels / total_pixels) * 100, 1)       print(paste(zone, \":\", pixels, \"pixels (\", percentage, \"%)\"))     }   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"data-quality-checks","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Quality Assurance and Validation","what":"Data Quality Checks","title":"Agricultural Applications with geospatialsuite","text":"Implement quality assurance agricultural monitoring:","code":"# Vegetation index quality assessment quality_check <- function(vegetation_indices) {   qc_results <- list()      if (inherits(vegetation_indices, \"SpatRaster\")) {     for (i in 1:terra::nlyr(vegetation_indices)) {       index_name <- names(vegetation_indices)[i]       values <- terra::values(vegetation_indices[[i]], mat = FALSE)              qc_results[[index_name]] <- list(         total_pixels = length(values),         valid_pixels = sum(!is.na(values)),         coverage_percent = round((sum(!is.na(values)) / length(values)) * 100, 1),         value_range = range(values, na.rm = TRUE),         outliers = sum(values < -1 | values > 1, na.rm = TRUE)  # For normalized indices       )     }   }      return(qc_results) }  # Perform quality check if (exists(\"agricultural_indices\")) {   qc_results <- quality_check(agricultural_indices)      print(\"Data Quality Assessment:\")   for (index in names(qc_results)) {     qc <- qc_results[[index]]     print(paste(index, \"- Coverage:\", qc$coverage_percent, \"%, Outliers:\", qc$outliers))   } }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"field-validation-support","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Quality Assurance and Validation","what":"Field Validation Support","title":"Agricultural Applications with geospatialsuite","text":"Support ground truth collection validation:","code":"# Create sampling points for field validation create_validation_points <- function(field_boundary, n_points = 10) {   # Generate random points within field boundary   if (inherits(field_boundary, \"sf\")) {     sample_points <- sf::st_sample(field_boundary, n_points)     validation_sf <- sf::st_sf(       point_id = paste0(\"VP_\", 1:length(sample_points)),       validation_type = \"Ground_Truth\",       geometry = sample_points     )     return(validation_sf)   }   return(NULL) }  # Create validation points for first field if (exists(\"fields_sf\")) {   validation_points <- create_validation_points(fields_sf[1, ], n_points = 5)      if (!is.null(validation_points)) {     print(\"Validation Points Created:\")     print(sf::st_drop_geometry(validation_points))          # Extract vegetation index values at validation points     if (exists(\"agricultural_indices\")) {       validation_extracted <- universal_spatial_join(         source_data = validation_points,         target_data = agricultural_indices,         method = \"extract\",         verbose = FALSE       )              print(\"Extracted Values at Validation Points:\")       validation_summary <- sf::st_drop_geometry(validation_extracted)       print(head(validation_summary))     }   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"complete-farm-analysis-pipeline","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Advanced Agricultural Workflows","what":"Complete Farm Analysis Pipeline","title":"Agricultural Applications with geospatialsuite","text":"Demonstrate complete agricultural analysis workflow:","code":"# Complete agricultural analysis workflow run_agricultural_workflow <- function(spectral_data, cdl_data = NULL,                                       region_boundary = NULL) {   workflow_results <- list()      # Step 1: Calculate vegetation indices   message(\"Step 1: Calculating vegetation indices...\")   indices <- calculate_multiple_indices(     spectral_data = spectral_data,     indices = c(\"NDVI\", \"SAVI\", \"DVI\"),     output_stack = TRUE   )   workflow_results$vegetation_indices <- indices      # Step 2: Crop classification (if CDL available)   if (!is.null(cdl_data)) {     message(\"Step 2: Analyzing crop distribution...\")     crop_mask <- create_crop_mask(cdl_data, \"corn\")     workflow_results$crop_mask <- crop_mask   }      # Step 3: Stress assessment   message(\"Step 3: Assessing crop stress...\")   if (inherits(indices, \"SpatRaster\") && \"NDVI\" %in% names(indices)) {     ndvi_vals <- terra::values(indices[[\"NDVI\"]], mat = FALSE)     stress_percent <- sum(ndvi_vals < 0.5, na.rm = TRUE) / sum(!is.na(ndvi_vals)) * 100     workflow_results$stress_assessment <- round(stress_percent, 1)   }      # Step 4: Generate recommendations   message(\"Step 4: Generating management recommendations...\")   recommendations <- character()      if (!is.null(workflow_results$stress_assessment)) {     if (workflow_results$stress_assessment > 25) {       recommendations <- c(recommendations, \"High stress detected - investigate causes\")     }     if (workflow_results$stress_assessment < 10) {       recommendations <- c(recommendations, \"Crop conditions appear favorable\")     }   }      workflow_results$recommendations <- recommendations      return(workflow_results) }  # Run the workflow workflow_output <- run_agricultural_workflow(   spectral_data = spectral_stack )  print(\"Complete Agricultural Workflow Results:\") print(paste(\"Stress assessment:\", workflow_output$stress_assessment, \"% of area\")) print(\"Recommendations:\") for (rec in workflow_output$recommendations) {   print(paste(\"-\", rec)) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"key-agricultural-functions","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary and Best Practices","what":"Key Agricultural Functions","title":"Agricultural Applications with geospatialsuite","text":"geospatialsuite provides comprehensive agricultural analysis : CDL Integration: get_comprehensive_cdl_codes(), analyze_cdl_crops_dynamic() Crop Monitoring: analyze_crop_vegetation(), calculate_ndvi_enhanced() Stress Detection: Multi-index analysis threshold classification Water Management: calculate_water_index() irrigation planning Yield Assessment: Composite index calculations trend analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"best-practices-for-agricultural-applications","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary and Best Practices","what":"Best Practices for Agricultural Applications","title":"Agricultural Applications with geospatialsuite","text":"","code":"# 1. Always validate your data print(\"Data Validation Checklist:\") print(\"Check coordinate reference systems\") print(\"Verify date ranges match growing season\") print(\"Validate vegetation index ranges\") print(\"Confirm crop mask accuracy\")  # 2. Use appropriate indices for your crop type crop_index_recommendations <- list(   corn = c(\"NDVI\", \"EVI2\", \"SAVI\", \"DVI\"),   soybeans = c(\"NDVI\", \"SAVI\", \"GNDVI\", \"DVI\"),   wheat = c(\"NDVI\", \"SAVI\", \"MSAVI\"),   general = c(\"NDVI\", \"SAVI\", \"DVI\", \"RVI\") )  print(\"Recommended indices by crop type:\") for (crop in names(crop_index_recommendations)) {   indices <- crop_index_recommendations[[crop]]   print(paste(crop, \":\", paste(indices, collapse = \", \"))) }  # 3. Monitor throughout growing season print(\"Seasonal Monitoring Schedule:\") print(\"- Planting: Establish baseline measurements\") print(\"- Early season: Monitor emergence and establishment\")  print(\"- Mid-season: Peak growth assessment and stress detection\") print(\"- Late season: Maturity evaluation and harvest timing\") print(\"- Post-harvest: Residue analysis and planning\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"integration-with-precision-agriculture","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary and Best Practices","what":"Integration with Precision Agriculture","title":"Agricultural Applications with geospatialsuite","text":"","code":"# Precision agriculture workflow components precision_ag_components <- list(   data_collection = c(\"Satellite imagery\", \"UAV surveys\", \"Ground sensors\"),   analysis_methods = c(\"Vegetation indices\", \"Stress detection\", \"Yield mapping\"),   decision_support = c(\"Variable rate applications\", \"Irrigation scheduling\", \"Harvest timing\"),   validation = c(\"Ground truth sampling\", \"Yield monitoring\", \"Economic analysis\") )  print(\"Precision Agriculture Integration:\") for (component in names(precision_ag_components)) {   print(paste(component, \":\", paste(precision_ag_components[[component]], collapse = \", \"))) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"output-structure-overview","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Understanding analyze_crop_vegetation() Outputs","what":"Output Structure Overview","title":"Agricultural Applications with geospatialsuite","text":"function returns three main components: vegetation_indices: Raster layers calculated indices analysis_results: Detailed analysis (stress, growth, yield) metadata: Processing information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"interpreting-stress-analysis","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Understanding analyze_crop_vegetation() Outputs","what":"Interpreting Stress Analysis","title":"Agricultural Applications with geospatialsuite","text":"Stress detection classifies pixels three categories:","code":"result <- analyze_crop_vegetation(data, analysis_type = \"stress\") stress <- result$analysis_results$stress_analysis$NDVI  # What percentage of my field needs attention? cat(sprintf(\"%.1f%% of field shows stress\\n\",             stress$moderate_stress_percentage + stress$severe_stress_percentage))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"understanding-composite-yield-index","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Understanding analyze_crop_vegetation() Outputs","what":"Understanding Composite Yield Index","title":"Agricultural Applications with geospatialsuite","text":"composite yield index 0-1 normalized score combines multiple vegetation indices: ’s calculated: 1. Multiple indices (NDVI, EVI, GNDVI, DVI, RVI) normalized 0-1 2. Normalized values averaged 3. Result indicates relative yield potential Interpretation: - 0.0-0.3: Low yield potential - 0.3-0.6: Medium yield potential - 0.6-0.8: High yield potential - 0.8-1.0: high yield potential Important caveats: - relative measure, absolute yield - calibrated actual yield data - Works best within-field comparisons - Correlation actual yield varies crop region","code":"result <- analyze_crop_vegetation(data, crop_type = \"corn\", analysis_type = \"yield\") yield <- result$analysis_results$yield_analysis  cat(sprintf(\"Yield Potential: %s\\n\", yield$yield_potential_class)) cat(sprintf(\"Composite Score: %.2f\\n\", yield$composite_yield_index))  # See which indices contributed for (idx in names(yield$index_contributions)) {   contrib <- yield$index_contributions[[idx]]   cat(sprintf(\"  %s: %.3f\\n\", idx, contrib$mean_normalized)) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"growth-stage-predictions","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Understanding analyze_crop_vegetation() Outputs","what":"Growth Stage Predictions","title":"Agricultural Applications with geospatialsuite","text":"Growth stage predicted NDVI patterns:","code":"result <- analyze_crop_vegetation(data, crop_type = \"soybeans\", analysis_type = \"growth\") growth <- result$analysis_results$growth_analysis  cat(sprintf(\"Predicted stage: %s\\n\", growth$predicted_growth_stage)) cat(sprintf(\"Confidence: %.0f%%\\n\", growth$stage_confidence * 100))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"summary","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite","what":"Summary","title":"Agricultural Applications with geospatialsuite","text":"geospatialsuite’s agricultural applications provide:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"cdl-analysis-capabilities","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary","what":"CDL Analysis Capabilities:","title":"Agricultural Applications with geospatialsuite","text":"Comprehensive crop codes USDA CDL categories Dynamic crop analysis area calculations Flexible crop masking classification Multi-year rotation analysis Crop diversity mapping","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"precision-agriculture-tools","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary","what":"Precision Agriculture Tools:","title":"Agricultural Applications with geospatialsuite","text":"Crop-specific vegetation analysis stress detection Enhanced NDVI agricultural processing Multi-scale field analysis (50m 2km scales) Management zone delineation Yield prediction support","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"integrated-workflows","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary","what":"Integrated Workflows:","title":"Agricultural Applications with geospatialsuite","text":"Environmental integration (soil, weather, topography) Water quality assessment agricultural context Temporal growth monitoring Risk assessment pests diseases Comprehensive reporting visualization","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"key-advantages","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary","what":"Key Advantages:","title":"Agricultural Applications with geospatialsuite","text":"Works agricultural region - limited specific areas Handles crop types - row crops specialty crops Multi-scale analysis - field regional levels Temporal integration - supports time series analysis Robust error handling - reliable operational use Comprehensive documentation - easy implement","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"applications","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite > Summary","what":"Applications:","title":"Agricultural Applications with geospatialsuite","text":"Precision agriculture variable rate applications Crop yield prediction forecasting Agricultural sustainability assessment Environmental impact monitoring Policy regulatory compliance Research development support agricultural tools geospatialsuite provide everything needed professional agricultural analysis precision farming applications!","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/agricultural-analysis.html","id":"acknowledgments","dir":"Articles","previous_headings":"Agricultural Applications with geospatialsuite","what":"Acknowledgments","title":"Agricultural Applications with geospatialsuite","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Vibha Mandayam, Yinghui Wu, Jeffrey Yarus, Erika . Barcelos, Roger H. French.","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"overview","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"Overview","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"analyze_crop_vegetation() function returns nested list three main components containing comprehensive crop analysis results.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"output-structure","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"Output Structure","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"","code":"result <- analyze_crop_vegetation(   spectral_data = your_data,   crop_type = \"corn\",   analysis_type = \"comprehensive\" )  # Structure: result$vegetation_indices      # SpatRaster with calculated indices result$analysis_results        # Detailed analysis results result$metadata                # Processing metadata"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"vegetation_indices-spatraster","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"1. vegetation_indices (SpatRaster)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Type: terra::SpatRaster object (multi-layer) Description: raster stack containing calculated vegetation indices specified crop type. Contents: layer different vegetation index (NDVI, EVI, GNDVI, etc.) Values actual index calculations pixel Layer names correspond index abbreviations Example Access:","code":"# View all calculated indices names(result$vegetation_indices) # [1] \"NDVI\" \"EVI\" \"GNDVI\" \"DVI\" \"RVI\" \"PRI\"  # Extract a specific index ndvi <- result$vegetation_indices[[\"NDVI\"]]  # Plot an index plot(result$vegetation_indices[[\"NDVI\"]], main = \"NDVI\")  # Get values for analysis ndvi_values <- terra::values(result$vegetation_indices[[\"NDVI\"]])"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"analysis_results-list","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"2. analysis_results (List)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Type: Named list 5 components depending analysis_type","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"stress_analysis-if-analysis_type-includes-stress-or-comprehensive","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List)","what":"2.1 stress_analysis (if analysis_type includes “stress” or “comprehensive”)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Identifies vegetation stress based index thresholds Structure: Contents index analyzed (e.g., NDVI, EVI, SIPI, GNDVI): Threshold Structure: Interpretation: Healthy: Vegetation growing normally, adequate water/nutrients Moderate Stress: stress present, may indicate water deficit nutrient issues Severe Stress: Significant stress, requires immediate attention Example Usage:","code":"result$analysis_results$stress_analysis result$analysis_results$stress_analysis$NDVI$thresholds_used # $healthy: c(0.6, 1.0)         # NDVI 0.6-1.0 = healthy # $moderate_stress: c(0.4, 0.6) # NDVI 0.4-0.6 = moderate stress # $severe_stress: c(0.0, 0.4)   # NDVI 0.0-0.4 = severe stress # Access stress results for NDVI ndvi_stress <- result$analysis_results$stress_analysis$NDVI  # What percentage of my field is healthy? cat(sprintf(\"Healthy vegetation: %.1f%%\\n\", ndvi_stress$healthy_percentage))  # What's the average NDVI? cat(sprintf(\"Mean NDVI: %.3f\\n\", ndvi_stress$mean_value))  # Check all indices analyzed names(result$analysis_results$stress_analysis)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"growth_analysis-if-analysis_type-includes-growth-or-comprehensive","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List)","what":"2.2 growth_analysis (if analysis_type includes “growth” or “comprehensive”)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Estimates crop growth stage provides growth statistics Structure: Contents:","code":"result$analysis_results$growth_analysis"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"growth-stage-prediction-overall","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List) > 2.2 growth_analysis (if analysis_type includes “growth” or “comprehensive”)","what":"Growth stage prediction (overall):","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Growth Stage Classifications: Corn: “emergence”: NDVI < 0.3 “vegetative”: NDVI 0.3-0.6 “reproductive”: NDVI 0.6-0.8 “maturity”: NDVI > 0.8 Soybeans: “emergence”: NDVI < 0.4 “vegetative”: NDVI 0.4-0.65 “reproductive”: NDVI 0.65-0.8 “maturity”: NDVI > 0.8 Wheat: “tillering”: NDVI < 0.35 “stem_elongation”: NDVI 0.35-0.7 “grain_filling”: NDVI 0.7-0.8 “maturity”: NDVI > 0.8 Example Usage:","code":"# What growth stage is the crop in? growth <- result$analysis_results$growth_analysis cat(sprintf(\"Growth stage: %s (confidence: %.2f)\\n\",              growth$predicted_growth_stage,             growth$stage_confidence))  # Get detailed NDVI statistics ndvi_stats <- growth$NDVI cat(sprintf(\"NDVI range: %.3f - %.3f\\n\", ndvi_stats$min, ndvi_stats$max)) cat(sprintf(\"NDVI variability (CV): %.3f\\n\", ndvi_stats$coefficient_of_variation))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"yield_analysis-if-analysis_type-includes-yield-or-comprehensive","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List)","what":"2.3 yield_analysis (if analysis_type includes “yield” or “comprehensive”)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Estimates yield potential using multiple vegetation indices Structure: Contents: Index Contributions Structure: Composite Yield Index Calculation: index (NDVI, EVI, GNDVI, DVI, RVI) normalized 0-1 scale Normalized values averaged across available indices 0.0 = low yield potential 0.5 = Medium yield potential 1.0 = Maximum yield potential Yield Potential Classifications: Corn: “Low”: composite_index < 0.3 “Medium”: composite_index 0.3-0.6 “High”: composite_index 0.6-0.8 “High”: composite_index > 0.8 Soybeans: “Low”: composite_index < 0.35 “Medium”: composite_index 0.35-0.65 “High”: composite_index 0.65-0.85 “High”: composite_index > 0.85 Wheat: “Low”: composite_index < 0.3 “Medium”: composite_index 0.3-0.6 “High”: composite_index 0.6-0.8 “High”: composite_index > 0.8 Interpretation: Composite Yield Index (0.0-1.0): Higher values indicate better yield potential Yield Potential Class: Categorical assessment easier interpretation Index Contributions: Shows indices contributed individual scores Classification Confidence: Higher composite_index far class boundaries (e.g., 0.2 0.9 confident 0.5) Example Usage:","code":"result$analysis_results$yield_analysis result$analysis_results$yield_analysis$index_contributions$NDVI # $mean_normalized: 0.75    # Normalized contribution (0-1) # $raw_mean: 0.68           # Raw mean NDVI value # $raw_std: 0.12            # Raw standard deviation # What's the yield potential? yield <- result$analysis_results$yield_analysis cat(sprintf(\"Yield Potential: %s (score: %.2f)\\n\",              yield$yield_potential_class,             yield$composite_yield_index))  # Which indices contributed? cat(sprintf(\"Based on %d indices: %s\\n\",             yield$n_indices_used,             paste(yield$indices_used, collapse = \", \")))  # Get individual index contributions for (idx in names(yield$index_contributions)) {   contrib <- yield$index_contributions[[idx]]   cat(sprintf(\"%s: %.3f (raw: %.3f Ã‚Â± %.3f)\\n\",               idx,                contrib$mean_normalized,               contrib$raw_mean,               contrib$raw_std)) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"summary_statistics","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List)","what":"2.4 summary_statistics","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Basic statistical summary calculated indices Structure: Contents index: Plus Overall Summary: Example Usage:","code":"result$analysis_results$summary_statistics result$analysis_results$summary_statistics$summary # $total_indices_calculated: 6 # $indices_with_valid_data: c(\"NDVI\", \"EVI\", \"GNDVI\", ...) # $total_indices_requested: 6 # $success_rate: 100.0 # Get statistics for all indices stats <- result$analysis_results$summary_statistics  # NDVI statistics ndvi_stats <- stats$NDVI cat(sprintf(\"NDVI: %.3f Ã‚Â± %.3f (range: %.3f to %.3f)\\n\",             ndvi_stats$mean,             ndvi_stats$std_dev,             ndvi_stats$min,             ndvi_stats$max))  # Check data quality cat(sprintf(\"Coverage: %.1f%% (%d pixels)\\n\",             ndvi_stats$coverage_percent,             ndvi_stats$count))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"validation-if-reference_data-provided","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > 2. analysis_results (List)","what":"2.5 validation (if reference_data provided)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Validates analysis ground truth data Note: component appears provide reference_data parameter Structure: TBD (depends reference data format)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"metadata-list","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"3. metadata (List)","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Purpose: Documents analysis parameters processing information Structure: Contents: Example Usage:","code":"result$metadata # Check what was analyzed meta <- result$metadata cat(sprintf(\"Analyzed %s at %s growth stage\\n\",              meta$crop_type,              meta$growth_stage)) cat(sprintf(\"Used %d indices: %s\\n\",             length(meta$indices_used),             paste(meta$indices_used, collapse = \", \"))) cat(sprintf(\"Processed on: %s\\n\", meta$processing_date))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"complete-example-workflow","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"Complete Example Workflow","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"","code":"library(geospatialsuite) library(terra)  # Run comprehensive crop analysis result <- analyze_crop_vegetation(   spectral_data = \"path/to/sentinel2_data.tif\",   crop_type = \"corn\",   growth_stage = \"mid\",   analysis_type = \"comprehensive\",   verbose = TRUE )  # ===== 1. Check what was calculated ===== cat(\"Indices calculated:\\n\") print(names(result$vegetation_indices))  # ===== 2. Assess crop stress ===== stress <- result$analysis_results$stress_analysis$NDVI cat(sprintf(\"\\nStress Assessment:\\n\")) cat(sprintf(\"  Healthy: %.1f%%\\n\", stress$healthy_percentage)) cat(sprintf(\"  Moderate stress: %.1f%%\\n\", stress$moderate_stress_percentage)) cat(sprintf(\"  Severe stress: %.1f%%\\n\", stress$severe_stress_percentage))  # ===== 3. Identify growth stage ===== growth <- result$analysis_results$growth_analysis cat(sprintf(\"\\nGrowth Stage: %s (%.0f%% confidence)\\n\",             growth$predicted_growth_stage,             growth$stage_confidence * 100))  # ===== 4. Estimate yield potential ===== yield <- result$analysis_results$yield_analysis cat(sprintf(\"\\nYield Potential: %s\\n\", yield$yield_potential_class)) cat(sprintf(\"Composite Yield Index: %.3f\\n\", yield$composite_yield_index)) cat(sprintf(\"Based on %d indices: %s\\n\",             yield$n_indices_used,             paste(yield$indices_used, collapse = \", \")))  # ===== 5. Visualize results ===== # Plot stress map plot(result$vegetation_indices[[\"NDVI\"]],       main = \"NDVI - Stress Detection\",      col = terrain.colors(100))  # Create stress classification map ndvi <- result$vegetation_indices[[\"NDVI\"]] stress_map <- classify(ndvi,                        matrix(c(-Inf, 0.4, 1,    # Severe stress                               0.4, 0.6, 2,       # Moderate stress                               0.6, Inf, 3),      # Healthy                             ncol = 3, byrow = TRUE)) plot(stress_map,       main = \"Crop Stress Classification\",      col = c(\"red\", \"yellow\", \"green\"),      legend = FALSE) legend(\"topright\",         legend = c(\"Severe Stress\", \"Moderate Stress\", \"Healthy\"),        fill = c(\"red\", \"yellow\", \"green\"))  # ===== 6. Export results ===== # Save as geotiff writeRaster(result$vegetation_indices,              \"crop_indices.tif\",              overwrite = TRUE)  # Save statistics as CSV stats_df <- data.frame(   Index = names(result$analysis_results$summary_statistics)[-length(names(result$analysis_results$summary_statistics))],   Mean = sapply(result$analysis_results$summary_statistics[1:(length(result$analysis_results$summary_statistics)-1)], function(x) x$mean),   StdDev = sapply(result$analysis_results$summary_statistics[1:(length(result$analysis_results$summary_statistics)-1)], function(x) x$std_dev),   Min = sapply(result$analysis_results$summary_statistics[1:(length(result$analysis_results$summary_statistics)-1)], function(x) x$min),   Max = sapply(result$analysis_results$summary_statistics[1:(length(result$analysis_results$summary_statistics)-1)], function(x) x$max) ) write.csv(stats_df, \"crop_analysis_statistics.csv\", row.names = FALSE)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"identifying-problem-areas","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > Tips for Using Results","what":"1. Identifying Problem Areas","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"","code":"# Find pixels with severe stress ndvi <- result$vegetation_indices[[\"NDVI\"]] severe_stress <- ndvi < 0.4 plot(severe_stress, main = \"Severe Stress Areas\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"comparing-multiple-fields","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > Tips for Using Results","what":"2. Comparing Multiple Fields","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"","code":"# Run analysis for multiple fields and compare field1_result <- analyze_crop_vegetation(field1_data, crop_type = \"corn\") field2_result <- analyze_crop_vegetation(field2_data, crop_type = \"corn\")  # Compare yield potential cat(sprintf(\"Field 1 yield: %s (%.3f)\\n\",              field1_result$analysis_results$yield_analysis$yield_potential_class,             field1_result$analysis_results$yield_analysis$composite_yield_index)) cat(sprintf(\"Field 2 yield: %s (%.3f)\\n\",             field2_result$analysis_results$yield_analysis$yield_potential_class,             field2_result$analysis_results$yield_analysis$composite_yield_index))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"time-series-analysis","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure > Tips for Using Results","what":"3. Time Series Analysis","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"","code":"# Analyze the same field at different dates early_season <- analyze_crop_vegetation(june_data, growth_stage = \"early\") mid_season <- analyze_crop_vegetation(july_data, growth_stage = \"mid\") late_season <- analyze_crop_vegetation(august_data, growth_stage = \"late\")  # Track NDVI progression ndvi_progression <- c(   early_season$analysis_results$growth_analysis$NDVI$mean,   mid_season$analysis_results$growth_analysis$NDVI$mean,   late_season$analysis_results$growth_analysis$NDVI$mean ) plot(1:3, ndvi_progression, type = \"b\",      xlab = \"Time Period\", ylab = \"Mean NDVI\",      main = \"NDVI Progression Through Season\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"validation-notes","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"Validation Notes","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"Important Caveats: Threshold-based: Stress yield classifications use literature-based thresholds may need adjustment specific region/conditions Composite Yield Index: vegetation-based proxy, direct yield prediction. Correlation actual yield varies crop, region, year Growth Stage: Predictions based NDVI patterns may align perfectly field observations guarantee: analytical tools support decision-making, definitive assessments Recommended Validation: Compare ground truth data (yield monitors, field scouting) Calibrate thresholds specific conditions Use multiple years data establish local patterns Combine data sources (weather, soil, management)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/analyze-crop-vegetation.html","id":"acknowledgments","dir":"Articles","previous_headings":"Complete Documentation: analyze_crop_vegetation() Output Structure","what":"Acknowledgments","title":"Using analyze_crop_vegetation() in geospatialsuite","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Vibha Mandayam, Yinghui Wu, Jeffrey Yarus, Erika . Barcelos, Roger H. French.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with geospatialsuite","text":"geospatialsuite comprehensive R package geospatial analysis visualization. provides universal functions work region, robust error handling, simplified workflows complex spatial analysis tasks.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"key-features","dir":"Articles","previous_headings":"Introduction","what":"Key Features","title":"Getting Started with geospatialsuite","text":"60+ vegetation indices automatic band detection Universal spatial mapping one-line functionality Reliable terra-based visualization without complex dependencies Agricultural applications including CDL crop analysis Water quality assessment multiple indices Robust error handling throughout functions Built-sample data learning testing Flexible data loading files, directories, objects","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"Introduction","what":"Installation","title":"Getting Started with geospatialsuite","text":"","code":"# Install from CRAN install.packages(\"geospatialsuite\") # Load the package library(geospatialsuite) library(terra)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"quick-start-with-built-in-sample-data","dir":"Articles","previous_headings":"Introduction","what":"Quick Start with Built-in Sample Data","title":"Getting Started with geospatialsuite","text":"geospatialsuite includes built-sample data can start immediately:","code":"library(geospatialsuite) library(terra)  # List available sample datasets list_sample_datasets() #>                 filename       type size_kb #> 1         sample_red.rds SpatRaster       2 #> 2         sample_nir.rds SpatRaster       2 #> 3        sample_blue.rds SpatRaster       2 #> 4       sample_green.rds SpatRaster       2 #> 5       sample_swir1.rds SpatRaster       2 #> 6   sample_multiband.rds SpatRaster       8 #> 7      sample_points.rds         sf       3 #> 8    sample_boundary.rds         sf       2 #> 9 sample_coordinates.csv data.frame       1 #>                                          description #> 1   Red band reflectance (10x10 pixels, Ohio region) #> 2   NIR band reflectance (10x10 pixels, Ohio region) #> 3  Blue band reflectance (10x10 pixels, Ohio region) #> 4 Green band reflectance (10x10 pixels, Ohio region) #> 5 SWIR1 band reflectance (10x10 pixels, Ohio region) #> 6   Multi-band raster (Blue, Green, Red, NIR, SWIR1) #> 7 Sample field locations (20 points with attributes) #> 8                 Sample study area boundary polygon #> 9    Sample coordinates with elevation and soil data #>                                          use_case available #> 1 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 2 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 3     Enhanced vegetation index (EVI) calculation      TRUE #> 4           Water index calculation (NDWI, GNDVI)      TRUE #> 5        Water and moisture indices (NDMI, MNDWI)      TRUE #> 6    Auto band detection, multi-index calculation      TRUE #> 7     Spatial join examples, extraction workflows      TRUE #> 8    Region boundary examples, masking operations      TRUE #> 9         Geocoding, spatial integration examples      TRUE #>                                access_method #> 1         load_sample_data('sample_red.rds') #> 2         load_sample_data('sample_nir.rds') #> 3        load_sample_data('sample_blue.rds') #> 4       load_sample_data('sample_green.rds') #> 5       load_sample_data('sample_swir1.rds') #> 6   load_sample_data('sample_multiband.rds') #> 7      load_sample_data('sample_points.rds') #> 8    load_sample_data('sample_boundary.rds') #> 9 load_sample_data('sample_coordinates.csv')  # Load sample raster data red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\")  # Calculate NDVI ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # Visualize plot(ndvi, main = \"NDVI from Sample Data\", col = terrain.colors(100))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"calculate-vegetation-indices","dir":"Articles","previous_headings":"Introduction > Core Workflows","what":"1. Calculate Vegetation Indices","title":"Getting Started with geospatialsuite","text":"","code":"# Load sample spectral bands red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") blue <- load_sample_data(\"sample_blue.rds\")  # Calculate NDVI ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\") plot(ndvi, main = \"NDVI\") # Calculate EVI (requires blue band) evi <- calculate_vegetation_index(red = red, nir = nir, blue = blue, index_type = \"EVI\") plot(evi, main = \"EVI\") # Calculate multiple indices at once indices <- calculate_multiple_indices(   red = red,   nir = nir,   blue = blue,   indices = c(\"NDVI\", \"EVI\", \"SAVI\"),   output_stack = TRUE )  # Plot all indices plot(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"working-with-multi-band-data","dir":"Articles","previous_headings":"Introduction > Core Workflows","what":"2. Working with Multi-band Data","title":"Getting Started with geospatialsuite","text":"","code":"# Load multi-band sample raster multiband <- load_sample_data(\"sample_multiband.rds\")  # Check band names names(multiband) #> [1] \"blue\"  \"green\" \"red\"   \"nir\"   \"swir1\"  # Auto-detect bands and calculate index ndvi_auto <- calculate_vegetation_index(   spectral_data = multiband,   index_type = \"NDVI\",   auto_detect_bands = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"spatial-operations","dir":"Articles","previous_headings":"Introduction > Core Workflows","what":"3. Spatial Operations","title":"Getting Started with geospatialsuite","text":"","code":"# Load sample vector data points <- load_sample_data(\"sample_points.rds\") boundary <- load_sample_data(\"sample_boundary.rds\")  # Calculate NDVI red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # Extract raster values to points points_with_values <- universal_spatial_join(   source_data = points,   target_data = ndvi,   method = \"extract\" )  # Check result head(points_with_values) #> Simple feature collection with 6 features and 7 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -83.94662 ymin: 39.00987 xmax: -83.91607 ymax: 39.09223 #> Geodetic CRS:  WGS 84 #>   site_id  ndvi   evi crop_type elevation_m soil_moisture #> 1 SITE_01 0.593 0.274  soybeans         269          0.27 #> 2 SITE_02 0.660 0.485     wheat         283          0.28 #> 3 SITE_03 0.646 0.579      corn         211          0.21 #> 4 SITE_04 0.388 0.483   pasture         256          0.31 #> 5 SITE_05 0.776 0.588      corn         219          0.35 #> 6 SITE_06 0.645 0.539  soybeans         205          0.30 #>                     geometry extracted_NDVI #> 1 POINT (-83.94662 39.04604)      0.7709993 #> 2 POINT (-83.94162 39.00987)      0.7667765 #> 3 POINT (-83.94104 39.02066)      0.7647660 #> 4  POINT (-83.9309 39.09223)      0.7207893 #> 5 POINT (-83.93327 39.03194)      0.6405917 #> 6 POINT (-83.91607 39.02653)      0.7215534"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"data-visualization","dir":"Articles","previous_headings":"Introduction > Core Workflows","what":"4. Data Visualization","title":"Getting Started with geospatialsuite","text":"","code":"# Load sample data points <- load_sample_data(\"sample_points.rds\")  # Quick map (auto-detects everything) quick_map(points, variable = \"ndvi\", title = \"NDVI at Sample Sites\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"available-sample-datasets","dir":"Articles","previous_headings":"Introduction","what":"Available Sample Datasets","title":"Getting Started with geospatialsuite","text":"Sample datasets include: sample_red.rds - Red band SpatRaster (10×10 pixels) sample_nir.rds - NIR band SpatRaster sample_blue.rds - Blue band SpatRaster sample_green.rds - Green band SpatRaster sample_swir1.rds - SWIR1 band SpatRaster sample_multiband.rds - Multi-band stack (5 bands) sample_points.rds - Sample field locations (sf object) sample_boundary.rds - Study area polygon (sf object) sample_coordinates.csv - Tabular data coordinates","code":"# List all available datasets datasets <- list_sample_datasets() print(datasets[, c(\"filename\", \"type\", \"description\")]) #>                 filename       type #> 1         sample_red.rds SpatRaster #> 2         sample_nir.rds SpatRaster #> 3        sample_blue.rds SpatRaster #> 4       sample_green.rds SpatRaster #> 5       sample_swir1.rds SpatRaster #> 6   sample_multiband.rds SpatRaster #> 7      sample_points.rds         sf #> 8    sample_boundary.rds         sf #> 9 sample_coordinates.csv data.frame #>                                          description #> 1   Red band reflectance (10x10 pixels, Ohio region) #> 2   NIR band reflectance (10x10 pixels, Ohio region) #> 3  Blue band reflectance (10x10 pixels, Ohio region) #> 4 Green band reflectance (10x10 pixels, Ohio region) #> 5 SWIR1 band reflectance (10x10 pixels, Ohio region) #> 6   Multi-band raster (Blue, Green, Red, NIR, SWIR1) #> 7 Sample field locations (20 points with attributes) #> 8                 Sample study area boundary polygon #> 9    Sample coordinates with elevation and soil data"},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"single-geotiff-file","dir":"Articles","previous_headings":"Working with Your Own Data > Loading Raster Files with geospatialsuite","what":"Single GeoTIFF File","title":"Getting Started with geospatialsuite","text":"","code":"# Use geospatialsuite's load_raster_data() function # It provides robust error handling and validation  # Load a single .tif file my_raster <- load_raster_data(\"path/to/your/ndvi.tif\")  # Result is a list, extract the raster ndvi_raster <- my_raster[[1]]  # Now use with geospatialsuite functions # The raster is ready for analysis summary(ndvi_raster)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"multiple-geotiff-files","dir":"Articles","previous_headings":"Working with Your Own Data > Loading Raster Files with geospatialsuite","what":"Multiple GeoTIFF Files","title":"Getting Started with geospatialsuite","text":"","code":"# Load multiple Landsat bands with geospatialsuite # Handles validation automatically  landsat_files <- c(   \"LC08_B4_red.tif\",   \"LC08_B5_nir.tif\",   \"LC08_B3_green.tif\" )  # geospatialsuite loads them with error checking bands <- load_raster_data(landsat_files, verbose = TRUE)  # Extract individual bands red_band <- bands[[1]] nir_band <- bands[[2]] green_band <- bands[[3]]  # Calculate indices using geospatialsuite ndvi <- calculate_vegetation_index(   red = red_band,   nir = nir_band,   index_type = \"NDVI\" )  gndvi <- calculate_vegetation_index(   green = green_band,   nir = nir_band,   index_type = \"GNDVI\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"load-from-directory","dir":"Articles","previous_headings":"Working with Your Own Data > Loading Raster Files with geospatialsuite","what":"Load from Directory","title":"Getting Started with geospatialsuite","text":"","code":"# geospatialsuite can load all rasters from a directory # Perfect for batch processing  # Load all .tif files from Landsat directory all_bands <- load_raster_data(   \"/path/to/landsat/imagery/\",   pattern = \"\\\\.(tif|tiff)$\",   verbose = TRUE )  # geospatialsuite finds, loads, and validates all files # Returns a list of SpatRaster objects ready to use cat(\"Loaded\", length(all_bands), \"raster files\\n\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"real-world-landsat-workflow","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Real-World Landsat Workflow","title":"Getting Started with geospatialsuite","text":"","code":"# Complete workflow using geospatialsuite functions  library(geospatialsuite)  # 1. Load Landsat bands using geospatialsuite landsat_bands <- load_raster_data(   \"landsat/LC08_L2SP_021033_20240715/\",   pattern = \"SR_B[2-5].TIF$\",   verbose = TRUE )  # geospatialsuite loaded them with validation # Extract bands (scaled values 0-1 after Collection 2 scaling) blue <- landsat_bands[[1]]   # After scaling green <- landsat_bands[[2]] red <- landsat_bands[[3]] nir <- landsat_bands[[4]]  # 2. Calculate vegetation indices using geospatialsuite # The package has 60+ pre-programmed indices veg_indices <- calculate_multiple_indices(   red = red,   nir = nir,   blue = blue,   green = green,   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"GNDVI\"),   output_stack = TRUE )  # 3. Visualize using geospatialsuite quick_map(veg_indices$NDVI, title = \"Landsat 8 NDVI - July 15, 2024\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"loading-shapefiles","dir":"Articles","previous_headings":"Working with Your Own Data > Working with Vector Data","what":"Loading Shapefiles","title":"Getting Started with geospatialsuite","text":"","code":"# Load shapefile with sf (standard approach) library(sf) field_boundaries <- sf::st_read(\"data/farm_fields.shp\")  # Then use with geospatialsuite's spatial functions # Calculate NDVI first ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # Extract NDVI to field boundaries using geospatialsuite fields_with_ndvi <- universal_spatial_join(   source_data = field_boundaries,   target_data = ndvi,   method = \"extract\" )  # geospatialsuite handles CRS mismatches automatically # Returns field boundaries with extracted NDVI statistics head(fields_with_ndvi)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"working-with-geopackages","dir":"Articles","previous_headings":"Working with Your Own Data > Working with Vector Data","what":"Working with GeoPackages","title":"Getting Started with geospatialsuite","text":"","code":"# Load GeoPackage (modern format, better than shapefile) farm_data <- sf::st_read(\"farm_management.gpkg\", layer = \"fields\") sample_points <- sf::st_read(\"farm_management.gpkg\", layer = \"samples\")  # Use geospatialsuite's spatial join samples_with_indices <- universal_spatial_join(   source_data = sample_points,   target_data = veg_indices,   method = \"extract\",   buffer_distance = 30  # 30m buffer )  # geospatialsuite extracted all indices in the stack # Each index becomes a column in the result names(samples_with_indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"multi-band-raster-with-auto-detection","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Multi-band Raster with Auto-Detection","title":"Getting Started with geospatialsuite","text":"","code":"# geospatialsuite's auto-detection feature  # Load a stacked multi-band GeoTIFF multiband_raster <- load_raster_data(\"sentinel2_stack.tif\")[[1]]  # Name the bands (Sentinel-2 example) names(multiband_raster) <- c(\"blue\", \"green\", \"red\", \"nir\", \"swir1\")  # Use geospatialsuite's auto-detection # It finds the right bands automatically! indices <- calculate_multiple_indices(   spectral_data = multiband_raster,   indices = c(\"NDVI\", \"EVI\", \"MNDWI\"),   auto_detect_bands = TRUE,  # This is geospatialsuite's feature!   output_stack = TRUE )  # No need to specify which band is which # geospatialsuite figured it out!"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"complete-real-world-example","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Complete Real-World Example","title":"Getting Started with geospatialsuite","text":"","code":"# End-to-end agricultural monitoring with geospatialsuite  library(geospatialsuite) library(sf)  # 1. Load satellite imagery using geospatialsuite spectral_bands <- load_raster_data(   \"/path/to/satellite/bands/\",   pattern = \"B[0-9].tif$\",   verbose = TRUE )  # 2. Extract bands red <- spectral_bands[[3]] nir <- spectral_bands[[4]] green <- spectral_bands[[2]]  # 3. Calculate indices using geospatialsuite crop_health <- calculate_multiple_indices(   red = red,   nir = nir,   green = green,   indices = c(\"NDVI\", \"GNDVI\", \"SAVI\"),   output_stack = TRUE )  # 4. Load field data fields <- sf::st_read(\"farm_data/fields.shp\")  # 5. Extract to fields using geospatialsuite fields_analysis <- universal_spatial_join(   source_data = fields,   target_data = crop_health,   method = \"extract\" )  # 6. Visualize using geospatialsuite quick_map(fields_analysis,            variable = \"NDVI\",           title = \"Field Health Assessment\")  # geospatialsuite handled: # - Loading multiple files # - Calculating indices # - Spatial extraction with CRS handling # - Visualization"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"listing-available-indices","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Listing Available Indices","title":"Getting Started with geospatialsuite","text":"","code":"# See all vegetation indices geospatialsuite provides veg_indices <- list_vegetation_indices() head(veg_indices[, c(\"Index\", \"Category\", \"Description\")]) #>   Index Category                              Description #> 1  NDVI    basic   Normalized Difference Vegetation Index #> 2  SAVI    basic           Soil Adjusted Vegetation Index #> 3 MSAVI    basic  Modified Soil Adjusted Vegetation Index #> 4 OSAVI    basic Optimized Soil Adjusted Vegetation Index #> 5   EVI    basic                Enhanced Vegetation Index #> 6  EVI2    basic       Two-band Enhanced Vegetation Index  # See water indices water_indices <- list_water_indices() head(water_indices) #>   Index                Type Required_Bands Primary_Application #> 1  NDWI     Water Detection     Green, NIR     water_detection #> 2 MNDWI     Water Detection   Green, SWIR1     water_detection #> 3  NDMI Vegetation Moisture     NIR, SWIR1 moisture_monitoring #> 4   MSI     Moisture Stress     NIR, SWIR1  drought_assessment #> 5  NDII Vegetation Moisture     NIR, SWIR1 moisture_monitoring #> 6    WI       Water Content     NIR, SWIR1 moisture_monitoring #>                                                                           Description #> 1 Normalized Difference Water Index (McFeeters 1996) - Original water detection index #> 2 Modified NDWI (Xu 2006) - Enhanced water detection, reduces built-up area confusion #> 3          Normalized Difference Moisture Index (Gao 1996) - Vegetation water content #> 4        Moisture Stress Index - Plant water stress detection (lower = more moisture) #> 5     Normalized Difference Infrared Index - Alternative name for vegetation moisture #> 6                             Water Index - Simple ratio for water content assessment #>   Value_Range  Water_Threshold          Reference #> 1     [-1, 1]            > 0.3   McFeeters (1996) #> 2     [-1, 1]            > 0.5          Xu (2006) #> 3     [-1, 1] N/A (vegetation)         Gao (1996) #> 4    [0, 10+]            < 1.0            Various #> 5     [-1, 1] N/A (vegetation) Hunt & Rock (1989) #> 6    [0, 10+]            > 1.0            Various"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"getting-help","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Getting Help","title":"Getting Started with geospatialsuite","text":"","code":"# Package documentation help(package = \"geospatialsuite\")  # Function help ?calculate_vegetation_index ?load_raster_data ?universal_spatial_join ?quick_map # Test package installation test_geospatialsuite_package_simple() #> $test_results #> $test_results$basic_ndvi_test #> [1] TRUE #>  #> $test_results$water_index_test #> [1] TRUE #>  #> $test_results$basic_visualization_test #> [1] TRUE #>  #> $test_results$multiple_indices_simple_test #> [1] TRUE #>  #> $test_results$enhanced_ndvi_simple_test #> [1] TRUE #>  #> $test_results$dependencies_test #> [1] TRUE #>  #> $test_results$spatial_operations_test #> [1] TRUE #>  #> $test_results$data_loading_test #> [1] TRUE #>  #>  #> $summary #> $summary$total_tests #> [1] 8 #>  #> $summary$passed_tests #> [1] 8 #>  #> $summary$failed_tests #> [1] 0 #>  #> $summary$success_rate #> [1] 100 #>  #> $summary$duration_seconds #> [1] 0.27 #>  #> $summary$version #> [1] \"0.1.0\" #>  #>  #> $test_output_dir #> [1] \"/tmp/Rtmp65VTUq\" #>  #> $timestamp #> [1] \"2026-02-05 16:49:55 EST\" #>  #> $test_approach #> [1] \"simplified_robust\" #>  #> $core_message #> [1] \"Focused on essential functionality with minimal complexity\""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/getting-started.html","id":"summary","dir":"Articles","previous_headings":"Working with Your Own Data","what":"Summary","title":"Getting Started with geospatialsuite","text":"geospatialsuite provides: Data Loading: load_raster_data() - Load .tif files validation load_sample_data() - Access built-samples Analysis: calculate_vegetation_index() - 60+ indices calculate_multiple_indices() - Batch processing Auto band detection feature Spatial Operations: universal_spatial_join() - Extract values, automatic CRS handling Visualization: quick_map() - One-line mapping create_spatial_map() - Custom maps robust error handling simplified workflows! detailed tutorials, see vignettes: Vegetation Indices Analysis Agricultural Applications Spatial Analysis Integration Water Quality Assessment Complete Workflows Case Studies","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"document provides performance benchmarking geospatialsuite::quick_map() alternative R visualization approaches large raster datasets. benchmarks demonstrate package’s claims regarding memory efficiency robust error handling. Note: benchmarks require large external datasets (100+ MB) executed package installation. code provided reproducibility can run user-supplied data.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"benchmark-setup","dir":"Articles","previous_headings":"","what":"Benchmark Setup","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"library(geospatialsuite) library(terra) library(ggplot2) library(bench)  # Simulate large raster dataset characteristics # In practice, use real satellite imagery (Landsat, Sentinel-2, etc.) create_test_raster <- function(nrow = 5000, ncol = 5000) {   r <- rast(nrows = nrow, ncols = ncol,              xmin = -180, xmax = 180,              ymin = -90, ymax = 90)   values(r) <- runif(ncell(r), 0, 1)   names(r) <- \"test_value\"   return(r) }  # Create test datasets of varying sizes cat(\"Creating test datasets (this may take a moment)...\\n\") small_raster <- create_test_raster(1000, 1000)    # ~7.6 MB medium_raster <- create_test_raster(3000, 3000)   # ~68.7 MB   large_raster <- create_test_raster(5000, 5000)    # ~190.7 MB"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"comparative-approaches","dir":"Articles","previous_headings":"","what":"Comparative Approaches","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"compare three visualization methods raster data:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"method-1-geospatialsuitequick_map","dir":"Articles","previous_headings":"Comparative Approaches","what":"Method 1: geospatialsuite::quick_map()","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"plot_geospatialsuite <- function(raster_data) {   quick_map(raster_data, title = \"geospatialsuite Plot\") }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"method-2-base-terraplot","dir":"Articles","previous_headings":"Comparative Approaches","what":"Method 2: Base terra::plot()","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"plot_terra_base <- function(raster_data) {   plot(raster_data, main = \"terra Base Plot\") }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"method-3-ggplot2-with-geom_raster","dir":"Articles","previous_headings":"Comparative Approaches","what":"Method 3: ggplot2 with geom_raster","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"plot_ggplot2 <- function(raster_data) {   # Convert raster to data frame (this is what causes memory scaling)   df <- as.data.frame(raster_data, xy = TRUE)   ggplot(df, aes(x = x, y = y, fill = test_value)) +     geom_raster() +     scale_fill_viridis_c() +     theme_minimal() +     labs(title = \"ggplot2 Plot\") }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"memory-usage-comparison","dir":"Articles","previous_headings":"Performance Benchmarks","what":"Memory Usage Comparison","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"test_datasets <- list(   Small = small_raster,   Medium = medium_raster,   Large = large_raster )  cat(\"\\n=== MEMORY FOOTPRINT ANALYSIS ===\\n\\n\")  memory_summary <- data.frame(   Dataset = character(),   Dimensions = character(),   Pixels = character(),   ggplot2_MB = numeric(),   terra_geospatial_MB = character(),   stringsAsFactors = FALSE )  for (dataset_name in names(test_datasets)) {   raster_data <- test_datasets[[dataset_name]]   dims <- sprintf(\"%d x %d\", nrow(raster_data), ncol(raster_data))   n_pixels <- format(ncell(raster_data), big.mark = \",\")      # The critical measurement: ggplot2's data frame size   df <- as.data.frame(raster_data, xy = TRUE)   df_size_mb <- as.numeric(object.size(df)) / 1024^2   rm(df); gc(verbose = FALSE)         if (df_size_mb > 75) {     cat(sprintf(\"  Memory advantage:        %.1fx less memory\\n\\n\", df_size_mb / 75))   } else {     cat(sprintf(\"  Memory ratio:            %.2fx\\n\\n\", df_size_mb / 75))   }      memory_summary <- rbind(memory_summary, data.frame(     Dataset = dataset_name,     Dimensions = dims,     Pixels = n_pixels,     ggplot2_MB = round(df_size_mb, 1),     terra_geospatial_MB = \"~75\",     stringsAsFactors = FALSE   )) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"timing-comparison","dir":"Articles","previous_headings":"Performance Benchmarks","what":"Timing Comparison","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"","code":"# Benchmark execution time WITHOUT memory profiling # (memory profiling fails with terra's internal parallelization)   timing_results <- bench::press(   dataset = c(\"Small\", \"Medium\", \"Large\"),   {     raster_data <- test_datasets[[dataset]]          bench::mark(       geospatialsuite = quick_map(raster_data),       terra_base = plot(raster_data),       ggplot2 = plot_ggplot2(raster_data),       check = FALSE,       min_iterations = 3,       max_iterations = 5,       memory = FALSE     )   } )  # Extract and display timing results timing_df <- as.data.frame(timing_results)  # Create summary - handle possible column name variations if (\"dataset\" %in% names(timing_df)) {   dataset_col <- \"dataset\" } else if (\"Dataset\" %in% names(timing_df)) {   dataset_col <- \"Dataset\" } else {   # Fallback: infer from row groups   dataset_col <- NULL }  cat(\"=== TIMING RESULTS ===\\n\\n\")  # Display by dataset for (ds in c(\"Small\", \"Medium\", \"Large\")) {   cat(sprintf(\"%s Dataset:\\n\", ds))      if (!is.null(dataset_col)) {     subset_data <- timing_df[timing_df[[dataset_col]] == ds, ]   } else {     # Fallback: each dataset has 3 rows (3 methods)     idx <- which(c(\"Small\", \"Medium\", \"Large\") == ds)     subset_data <- timing_df[((idx-1)*3 + 1):(idx*3), ]   }      for (i in 1:nrow(subset_data)) {     method <- as.character(subset_data$expression[i])     time_sec <- as.numeric(subset_data$median[i])     time_ms <- time_sec * 1000          # Simplify method name for display     method_display <- method     if (grepl(\"quick_map|geospatialsuite\", method, ignore.case = TRUE)) {       method_display <- \"geospatialsuite\"     } else if (grepl(\"plot_ggplot|ggplot\", method, ignore.case = TRUE)) {       method_display <- \"ggplot2\"     } else if (grepl(\"plot.*terra|^plot\\\\(\", method, ignore.case = TRUE)) {       method_display <- \"terra_base\"     }          cat(sprintf(\"  %-20s: %6.0f ms\\n\", method_display, time_ms))   }      # Calculate speedup vs ggplot2 using pattern matching   expr_str <- as.character(subset_data$expression)   gg_idx <- grep(\"ggplot|plot_ggplot2\", expr_str, ignore.case = TRUE)   geo_idx <- grep(\"quick_map|geospatialsuite\", expr_str, ignore.case = TRUE)      if (length(gg_idx) > 0 && length(geo_idx) > 0) {     ggplot_time <- subset_data$median[gg_idx[1]]     geospatial_time <- subset_data$median[geo_idx[1]]          speedup <- as.numeric(ggplot_time) / as.numeric(geospatial_time)     if (speedup > 1) {       cat(sprintf(\"  → geospatialsuite is %.1fx FASTER than ggplot2\\n\", speedup))     } else {       cat(sprintf(\"  → geospatialsuite is %.1fx slower than ggplot2\\n\", 1/speedup))     }   }   cat(\"\\n\") }  # Create summary table timing_summary <- data.frame(   Dataset = character(),   geospatialsuite_ms = numeric(),   terra_base_ms = numeric(),   ggplot2_ms = numeric(),   Speedup_vs_ggplot2 = character(),   stringsAsFactors = FALSE )  for (ds in c(\"Small\", \"Medium\", \"Large\")) {   if (!is.null(dataset_col)) {     subset_data <- timing_df[timing_df[[dataset_col]] == ds, ]   } else {     idx <- which(c(\"Small\", \"Medium\", \"Large\") == ds)     subset_data <- timing_df[((idx-1)*3 + 1):(idx*3), ]   }      # Expression names are the full calls, need to match on pattern   expr_str <- as.character(subset_data$expression)      # Find which row is which by looking for function names in the expression   geo_idx <- grep(\"quick_map|geospatialsuite\", expr_str, ignore.case = TRUE)   terra_idx <- grep(\"plot.*terra|terra.*plot|^plot\\\\(\", expr_str, ignore.case = TRUE)   terra_idx <- terra_idx[!terra_idx %in% geo_idx]  # Exclude geospatialsuite   gg_idx <- grep(\"ggplot|plot_ggplot2\", expr_str, ignore.case = TRUE)      geo_ms <- if (length(geo_idx) > 0) as.numeric(subset_data$median[geo_idx[1]]) * 1000 else NA   terra_ms <- if (length(terra_idx) > 0) as.numeric(subset_data$median[terra_idx[1]]) * 1000 else NA   gg_ms <- if (length(gg_idx) > 0) as.numeric(subset_data$median[gg_idx[1]]) * 1000 else NA      if (!is.na(geo_ms) && !is.na(gg_ms)) {     speedup <- gg_ms / geo_ms     if (speedup > 1) {       speedup_text <- sprintf(\"%.1fx faster\", speedup)     } else {       speedup_text <- sprintf(\"%.1fx slower\", 1/speedup)     }   } else {     speedup_text <- \"N/A\"   }      timing_summary <- rbind(timing_summary, data.frame(     Dataset = ds,     geospatialsuite_ms = round(geo_ms, 0),     terra_base_ms = round(terra_ms, 0),     ggplot2_ms = round(gg_ms, 0),     Speedup_vs_ggplot2 = speedup_text,     stringsAsFactors = FALSE   )) }  cat(\"=== SUMMARY TABLE ===\\n\") print(timing_summary, row.names = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"benchmark-results","dir":"Articles","previous_headings":"","what":"Benchmark Results","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Based actual testing simulated satellite imagery datasets:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"memory-efficiency-table","dir":"Articles","previous_headings":"Benchmark Results","what":"Memory Efficiency Table","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"actual benchmark testing: Key Finding: geospatialsuite terra maintain constant ~75 MB overhead regardless raster size, ggplot2 scales linearly pixels (22.9 → 572.2 MB). represents 7.6× memory advantage realistic satellite imagery.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"plotting-time-comparison","dir":"Articles","previous_headings":"Benchmark Results","what":"Plotting Time Comparison","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"actual benchmark testing: Key Finding: small datasets, ggplot2’s optimized data frame rendering faster. However, medium large datasets (realistic satellite imagery), geospatialsuite 1.7-4.2× faster. performance advantage grows data size due overhead data frame conversion.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"xlarge-dataset-handling-10k10k-762-9-mb","dir":"Articles","previous_headings":"Benchmark Results","what":"XLarge Dataset Handling (10K×10K, ~762.9 MB)","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Testing large datasets reveals critical differences: Critical Finding: ggplot2 converts entire raster data frame, causing memory usage scale linearly raster size. 10K×10K raster: - Terra/geospatialsuite: Maintains ~75 MB (constant, uses C++ rendering) - ggplot2: Requires ~8+ GB (linear scaling, R data frame conversion)","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"memory-efficiency","dir":"Articles","previous_headings":"Key Performance Characteristics","what":"1. Memory Efficiency","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"quick_map() leverages terra’s efficient raster handling avoids converting entire rasters data frames (ggplot2 requires). results : Constant memory usage: ~75 MB regardless raster size (tested 1M 25M pixels) conversion overhead: Works directly terra SpatRaster objects using C++ rendering Comparison: ggplot2 scales 22.9 MB (1K×1K) 572 MB (5K×5K) due data frame conversion - 7.6× memory advantage realistic scales matters: satellite imagery analysis, constant memory usage means: Predictable resource requirements memory-based failures Can process datasets require >2 GB ggplot2 approach (extrapolating 10K×10K)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"performance-at-scale","dir":"Articles","previous_headings":"Key Performance Characteristics","what":"2. Performance at Scale","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Performance characteristics vary dataset size (based actual benchmark results): Small datasets (1K×1K, ~1M pixels): - ggplot2 faster (97ms vs 554ms) due optimized data frame rendering - However, ggplot2 uses 0.3× memory (22.9 MB vs 75 MB) - advantage ggplot2 small data Medium datasets (3K×3K, ~9M pixels): - geospatialsuite becomes 1.7× faster (600ms vs 1,025ms) - Memory advantage: 2.7× less memory (75 MB vs 206 MB) Large datasets (5K×5K, ~25M pixels): - geospatialsuite 4.2× faster (684ms vs 2,897ms) - Memory advantage: 7.6× less memory (75 MB vs 572 MB) Critical insight: C++ rendering backend maintains constant ~75 MB memory speed increases slightly data size, data frame conversion overhead ggplot2 causes memory time scale pixels. crossover point around 2K×2K pixels (~4M pixels).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"robust-error-handling","dir":"Articles","previous_headings":"Key Performance Characteristics","what":"2. Robust Error Handling","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"function includes multiple safety mechanisms:","code":"# Handles missing data gracefully raster_with_na <- medium_raster values(raster_with_na)[sample(ncell(raster_with_na), 10000)] <- NA quick_map(raster_with_na)  # Succeeds with warning  # Handles projection issues automatically raster_wrong_crs <- project(medium_raster, \"EPSG:3857\") quick_map(raster_wrong_crs)  # Auto-detects and handles  # Handles empty/invalid data empty_raster <- medium_raster values(empty_raster) <- NA tryCatch(   quick_map(empty_raster),   error = function(e) message(\"Graceful failure with informative error\") )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"consistency-across-data-sizes","dir":"Articles","previous_headings":"Key Performance Characteristics","what":"3. Consistency Across Data Sizes","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Unlike methods fail become impractical large scales, quick_map() maintains consistent behavior:","code":"# Test consistent output quality across sizes datasets <- list(small_raster, medium_raster, large_raster)  for (i in seq_along(datasets)) {   cat(sprintf(\"\\nDataset %d (%.1f MB):\\n\", i,                as.numeric(object.size(datasets[[i]])) / 1024^2))      system.time({     result <- quick_map(datasets[[i]])     cat(\"Success: Plot generated\\n\")   }) }"},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"key-performance-differences","dir":"Articles","previous_headings":"Comparison with Related Packages","what":"Key Performance Differences","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Memory Scaling (actual benchmark results): geospatialsuite/terra: Constant ~75 MB regardless raster size (C++ backend) ggplot2: Linear scaling pixels (22.9 MB → 206 MB → 572 MB 1K×1K → 3K×3K → 5K×5K) Speed Scale (actual benchmark results): Small data (1K×1K): ggplot2 faster (97ms vs 554ms) - optimized data frames Medium data (3K×3K): geospatialsuite 1.7× faster (600ms vs 1,025ms) Large data (5K×5K): geospatialsuite 4.2× faster (684ms vs 2,897ms) Reliability: geospatialsuite: Consistent behavior across data sizes ggplot2: Often fails becomes impractical beyond 5K×5K due memory requirements","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"unique-advantages-of-quick_map","dir":"Articles","previous_headings":"Comparison with Related Packages","what":"Unique Advantages of quick_map()","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Universal data type support: Works SpatRaster, RasterLayer, sf objects, data frames Constant memory usage: ~75 MB regardless data size vs. ggplot2 linear scaling (7.6× advantage 5K×5K) Built-error recovery: Gracefully handles common failure modes (missing data, CRS issues, empty rasters) Performance scale: 4.2× faster ggplot2 realistic satellite imagery (5K×5K pixels) Minimal dependencies: Core functionality requires terra base R Consistent API: function call works spatial data types","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"performance-summary-table","dir":"Articles","previous_headings":"Comparison with Related Packages","what":"Performance Summary Table","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Actual benchmark results realistic satellite imagery (5K×5K pixels, 25M cells): Bottom Line: quick_map() combines terra’s memory efficiency enhanced features robust error handling. realistic satellite imagery analysis, provides 7.6× better memory efficiency 4.2× faster execution data frame-based approaches.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"reproducibility-notes","dir":"Articles","previous_headings":"","what":"Reproducibility Notes","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"reproduce benchmarks data:","code":"# Use your own raster data my_large_raster <- terra::rast(\"path/to/large_satellite_image.tif\")  # Simple timing test time_result <- system.time({   quick_map(my_large_raster) }) cat(sprintf(\"Execution time: %.2f seconds\\n\", time_result[\"elapsed\"]))  # Memory test - measure data frame size for ggplot2 comparison df_size <- object.size(as.data.frame(my_large_raster, xy = TRUE)) cat(sprintf(\"ggplot2 would require converting to data frame: %.0f MB\\n\",              as.numeric(df_size) / 1024^2))  # Benchmark comparison library(bench) comparison <- bench::mark(   geospatialsuite = quick_map(my_large_raster),   terra_base = terra::plot(my_large_raster),   memory = FALSE,  # Disable if parallel rendering causes issues   min_iterations = 3 ) print(comparison[, c(\"expression\", \"median\")])"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"benchmark demonstrates geospatialsuite::quick_map() provides: Memory efficiency: key difference ggplot2 requires converting entire raster R data frame, terra/geospatialsuite use efficient C++ rendering. 5K×5K raster, data frame alone requires ~4.5 GB vs terra’s constant ~75 MB rendering overhead. Speed: Performance advantage grows dataset size - comparable small scales 3-5× faster realistic satellite imagery. Reliability: Robust error handling prevents common failures (missing data, CRS issues, empty rasters) cause approaches crash. Scalability: Maintains consistent performance small large datasets. function achieves characteristics : - Building terra’s efficient C++ implementation - Avoiding unnecessary data conversions (raster → data frame) - Including comprehensive error checking - Automatically selecting appropriate visualization strategies","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"note-on-memory-profiling","dir":"Articles","previous_headings":"Conclusion","what":"Note on Memory Profiling","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Standard R memory profiling tools (including bench::mark’s memory profiling) can conflict terra’s internal parallelization. benchmarks focus : Timing: Measured reliably bench::mark(..., memory = FALSE) Memory footprint: Measured via data structure sizes, reveals key difference (ggplot2’s data frame conversion vs direct rendering) approach accurately captures performance characteristics relevant users: fast function runs much memory data transformations require. performance characteristics support use quick_map() interactive exploratory analysis automated workflow pipelines reliability critical.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/performance_benchmark.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Performance Benchmark: quick_map() vs Alternative Approaches","text":"Hijmans, R. J. (2022). terra: Spatial Data Analysis. R package version 1.6-17. Pebesma, E. (2018). Simple Features R: Standardized Support Spatial Vector Data. R Journal, 10(1), 439-446.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"universal-spatial-mapping-with-geospatialsuite","dir":"Articles","previous_headings":"","what":"Universal Spatial Mapping with geospatialsuite","title":"Universal Spatial Mapping with geospatialsuite","text":"vignette demonstrates powerful flexible mapping capabilities geospatialsuite, including auto-detection mapping, custom visualizations, publication-quality outputs.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"loading-the-package","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Loading the Package","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"library(geospatialsuite) library(terra) library(sf)  # Check package functionality test_package_minimal(verbose = TRUE) #> [1] TRUE"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"quick-start-one-line-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Quick Start: One-Line Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"quick_map() function auto-detects data type creates appropriate visualizations minimal code:","code":"# Create sample data for demonstration sample_points <- data.frame(   lon = c(-83.1, -83.2, -83.3, -82.9, -82.8),   lat = c(40.1, 40.2, 40.3, 40.0, 40.4),   ndvi = c(0.7, 0.8, 0.6, 0.75, 0.85),   yield = c(150, 180, 120, 160, 200) )  # One-line mapping with auto-detection quick_map(sample_points)  # Quick map with specific variable quick_map(sample_points, variable = \"ndvi\", title = \"NDVI Distribution\")  # Quick map with raster data (if available) # quick_map(\"path/to/raster.tif\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"universal-spatial-map-function","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Universal Spatial Map Function","title":"Universal Spatial Mapping with geospatialsuite","text":"create_spatial_map() function provides comprehensive mapping extensive customization options:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"basic-point-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Universal Spatial Map Function","what":"Basic Point Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Convert sample data to sf object sample_sf <- sf::st_as_sf(sample_points,                            coords = c(\"lon\", \"lat\"),                            crs = 4326)  # Basic point map basic_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   map_type = \"points\",   title = \"Sample NDVI Points\",   verbose = TRUE )  print(basic_map)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"custom-color-schemes","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Universal Spatial Map Function","what":"Custom Color Schemes","title":"Universal Spatial Mapping with geospatialsuite","text":"geospatialsuite provides specialized color schemes different applications:","code":"# NDVI-specific colors ndvi_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   color_scheme = \"ndvi\",   title = \"NDVI with Specialized Colors\" )  # Terrain colors for elevation data # terrain_map <- create_spatial_map( #   spatial_data = elevation_data, #   color_scheme = \"terrain\", #   title = \"Elevation Map\" # )  # Plasma colors for general data plasma_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"yield\",   color_scheme = \"plasma\",   title = \"Yield with Plasma Colors\" )  print(plasma_map)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"fast-raster-plotting","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Raster Mapping","what":"Fast Raster Plotting","title":"Universal Spatial Mapping with geospatialsuite","text":"plot_raster_fast() function provides efficient raster visualization using terra’s native plotting:","code":"# Create sample raster for demonstration sample_raster <- terra::rast(nrows = 50, ncols = 50,                               xmin = -84, xmax = -82,                               ymin = 39, ymax = 41) terra::values(sample_raster) <- runif(2500, 0.2, 0.9) names(sample_raster) <- \"NDVI\"  # Fast raster plot plot_raster_fast(   raster_data = sample_raster,   title = \"Sample NDVI Raster\",   color_scheme = \"ndvi\" )  # With custom breaks plot_raster_fast(   raster_data = sample_raster,   title = \"NDVI with Custom Classes\",   color_scheme = \"ndvi\",   breaks = c(0, 0.3, 0.5, 0.7, 1.0) )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"rgb-composite-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Raster Mapping","what":"RGB Composite Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"Create RGB composites multi-band imagery:","code":"# Create sample multi-band raster red_band <- terra::rast(nrows = 30, ncols = 30,                          xmin = -84, xmax = -82,                          ymin = 39, ymax = 41) terra::values(red_band) <- runif(900, 0.1, 0.3)  green_band <- red_band terra::values(green_band) <- runif(900, 0.2, 0.4)  blue_band <- red_band terra::values(blue_band) <- runif(900, 0.05, 0.15)  # Stack bands rgb_stack <- c(red_band, green_band, blue_band) names(rgb_stack) <- c(\"Red\", \"Green\", \"Blue\")  # RGB composite plot plot_rgb_raster(   raster_data = rgb_stack,   r = 1, g = 2, b = 3,   stretch = \"lin\",   title = \"RGB Composite\" )  # False color composite plot_rgb_raster(   raster_data = rgb_stack,   r = 2, g = 1, b = 3,  # Green-Red-Blue   stretch = \"hist\",   title = \"False Color Composite\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"interactive-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Interactive Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"Create interactive maps using leaflet integration:","code":"# Interactive point map (requires leaflet package) if (requireNamespace(\"leaflet\", quietly = TRUE)) {   interactive_map <- create_interactive_map(     spatial_data = sample_sf,     fill_variable = \"ndvi\",     basemap = \"terrain\",     title = \"Interactive NDVI Map\"   )      # Save interactive map   # htmlwidgets::saveWidget(interactive_map, \"interactive_ndvi.html\") }  # Interactive mapping with custom basemap if (requireNamespace(\"leaflet\", quietly = TRUE)) {   satellite_map <- create_interactive_map(     spatial_data = sample_sf,     fill_variable = \"yield\",     basemap = \"satellite\",     title = \"Yield on Satellite Imagery\"   ) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"auto-detection-with-region-boundaries","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Regional Boundary Integration","what":"Auto-Detection with Region Boundaries","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Simulate Ohio boundary for demonstration ohio_boundary <- sf::st_polygon(list(matrix(c(   -84.5, 38.5, -80.5, 38.5, -80.5, 42.0, -84.5, 42.0, -84.5, 38.5 ), ncol = 2, byrow = TRUE))) ohio_sf <- sf::st_sf(geometry = sf::st_sfc(ohio_boundary, crs = 4326))  # Map with region boundary map_with_boundary <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   region_boundary = ohio_sf,  # Would normally use \"Ohio\"   title = \"NDVI in Ohio\",   color_scheme = \"ndvi\" )  print(map_with_boundary)  # The package supports many boundary types: # create_spatial_map(data, region_boundary = \"Ohio\")          # US State # create_spatial_map(data, region_boundary = \"CONUS\")         # Continental US # create_spatial_map(data, region_boundary = \"Ohio:Franklin\") # State:County # create_spatial_map(data, region_boundary = c(-84, 39, -82, 41)) # Bounding box"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"comparison-maps","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Comparison Maps","title":"Universal Spatial Mapping with geospatialsuite","text":"Create side--side difference maps /analysis:","code":"# Create \"before\" and \"after\" rasters before_raster <- terra::rast(nrows = 30, ncols = 30,                               xmin = -84, xmax = -82,                               ymin = 39, ymax = 41) terra::values(before_raster) <- runif(900, 0.3, 0.7) names(before_raster) <- \"NDVI_Before\"  after_raster <- before_raster terra::values(after_raster) <- terra::values(before_raster) + runif(900, -0.1, 0.2) names(after_raster) <- \"NDVI_After\"  # Side-by-side comparison create_comparison_map(   data1 = before_raster,   data2 = after_raster,   comparison_type = \"side_by_side\",   titles = c(\"Before Treatment\", \"After Treatment\"),   color_scheme = \"ndvi\" )  # Difference map create_comparison_map(   data1 = before_raster,   data2 = after_raster,   comparison_type = \"difference\",   titles = c(\"Before\", \"After\"),   color_scheme = \"RdBu\" )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"custom-color-palettes","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Advanced Customization","what":"Custom Color Palettes","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Get available color schemes color_schemes <- c(\"viridis\", \"plasma\", \"ndvi\", \"terrain\", \"water\", \"categorical\")  # Apply different schemes to the same data for (scheme in color_schemes[1:3]) {   map <- create_spatial_map(     spatial_data = sample_sf,     fill_variable = \"ndvi\",     color_scheme = scheme,     title = paste(\"NDVI with\", scheme, \"colors\"),     point_size = 4   )      print(paste(\"Created map with\", scheme, \"color scheme\")) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"map-styling-options","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Advanced Customization","what":"Map Styling Options","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Customize point appearance styled_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"yield\",   map_type = \"points\",   point_size = 6,   color_scheme = \"plasma\",   title = \"Customized Point Map\" )  print(styled_map)  # Map with transparent points # (Demonstrated conceptually - actual implementation may vary)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"high-resolution-output","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Publication-Quality Maps","what":"High-Resolution Output","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Create high-resolution map for publication publication_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   color_scheme = \"ndvi\",   title = \"NDVI Distribution in Study Area\",   output_file = \"publication_ndvi_map.png\" )  # Customize for journal specifications journal_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"yield\",   color_scheme = \"viridis\",   title = \"\",  # No title for journal figure   output_file = \"figure_1.png\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"map-layout-and-legends","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Publication-Quality Maps","what":"Map Layout and Legends","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# The package automatically handles legends and layouts # Maps include appropriate legends, scale bars, and formatting  # For complex layouts, combine with other packages: # library(patchwork)  # For multi-panel figures # library(ggplot2)    # For additional customization"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"common-issues-and-solutions","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Error Handling and Troubleshooting","what":"Common Issues and Solutions","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Test data validation tryCatch({   # This should work   valid_map <- create_spatial_map(sample_sf, fill_variable = \"ndvi\")   print(\"Valid map created successfully\") }, error = function(e) {   print(paste(\"Error:\", e$message)) })  # Handle missing data sample_with_na <- sample_sf sample_with_na$ndvi[1:2] <- NA  na_map <- create_spatial_map(   spatial_data = sample_with_na,   fill_variable = \"ndvi\",   title = \"Data with Missing Values\" )  print(\"Map with NA values handled automatically\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"diagnostic-functions","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Error Handling and Troubleshooting","what":"Diagnostic Functions","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Quick diagnostic check diagnostic_result <- quick_diagnostic()  # Test specific mapping functions mapping_test <- tryCatch({   test_map <- create_spatial_map(sample_sf, fill_variable = \"ndvi\")   \"Mapping functions working\" }, error = function(e) {   paste(\"Mapping error:\", e$message) })  print(mapping_test)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"data-preparation","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Best Practices","what":"1. Data Preparation","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Always check your data first print(\"Sample data structure:\") print(head(sample_sf))  # Verify coordinate reference system print(paste(\"CRS:\", sf::st_crs(sample_sf)$input))  # Check for valid geometries valid_geoms <- sf::st_is_valid(sample_sf) print(paste(\"Valid geometries:\", all(valid_geoms)))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"progressive-enhancement","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Best Practices","what":"2. Progressive Enhancement","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Start simple, then add complexity simple_map <- quick_map(sample_sf)  # Add customization progressively enhanced_map <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   color_scheme = \"ndvi\",   title = \"Enhanced NDVI Map\",   point_size = 5 )  # Add interactivity if needed # interactive_version <- create_interactive_map(sample_sf, fill_variable = \"ndvi\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"performance-optimization","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Best Practices","what":"3. Performance Optimization","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# For large datasets, consider: # 1. Simplifying geometries # 2. Reducing point density # 3. Using raster instead of vector for very dense data  # Example: Check data size print(paste(\"Number of features:\", nrow(sample_sf))) print(paste(\"Number of variables:\", ncol(sample_sf) - 1))  # Minus geometry  # For large rasters, use terra's efficient plotting if (exists(\"sample_raster\")) {   print(paste(\"Raster dimensions:\", paste(dim(sample_raster), collapse = \" x \"))) }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"ggplot2-integration","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Integration with Other Packages","what":"ggplot2 Integration","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# geospatialsuite maps work well with ggplot2 library(ggplot2)  # Extract ggplot object for further customization base_map <- create_spatial_map(sample_sf, fill_variable = \"ndvi\")  # Customize with ggplot2 (if the map is a ggplot object) if (inherits(base_map, \"ggplot\")) {   enhanced_ggplot <- base_map +     theme_minimal() +     labs(caption = \"Data source: Field measurements\") +     theme(       plot.title = element_text(size = 16, face = \"bold\"),       legend.position = \"bottom\"     ) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"leaflet-integration","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Integration with Other Packages","what":"Leaflet Integration","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# For interactive web maps if (requireNamespace(\"leaflet\", quietly = TRUE)) {   web_map <- create_interactive_map(     spatial_data = sample_sf,     fill_variable = \"ndvi\",     popup_vars = c(\"ndvi\", \"yield\"),     basemap = \"terrain\"   )      # Further customize with leaflet functions   enhanced_web_map <- web_map %>%     leaflet::addMiniMap() %>%     leaflet::addScaleBar() }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"ndvi-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Specialized Mapping Functions","what":"NDVI Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Create sample NDVI raster ndvi_raster <- terra::rast(nrows = 40, ncols = 40,                             xmin = -84, xmax = -82,                             ymin = 39, ymax = 41) terra::values(ndvi_raster) <- runif(1600, 0.1, 0.9) names(ndvi_raster) <- \"NDVI\"  # Specialized NDVI visualization ndvi_map <- create_ndvi_map(   ndvi_data = ndvi_raster,   title = \"NDVI Analysis\",   ndvi_classes = \"none\"  # Use continuous colors )  print(\"NDVI map created with specialized colors\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"water-quality-mapping","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Specialized Mapping Functions","what":"Water Quality Mapping","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Create sample water quality data water_points <- data.frame(   lon = c(-83.0, -83.1, -83.2, -82.9, -82.8),   lat = c(40.0, 40.1, 40.2, 39.9, 40.3),   dissolved_oxygen = c(8.2, 7.5, 6.8, 8.9, 7.1),   temperature = c(18.5, 19.2, 20.1, 17.8, 19.5) )  water_sf <- sf::st_as_sf(water_points,                           coords = c(\"lon\", \"lat\"),                           crs = 4326)  # Water quality visualization water_map <- create_water_quality_plot(   water_data = water_sf,   variable = \"dissolved_oxygen\",   title = \"Dissolved Oxygen Levels\" )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"static-map-export","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Export Options","what":"Static Map Export","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# High-resolution PNG export create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   color_scheme = \"ndvi\",   title = \"NDVI Distribution\",   output_file = \"high_res_ndvi.png\" )  # PDF export for vector graphics create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"yield\",   color_scheme = \"viridis\",   title = \"Yield Distribution\",   output_file = \"yield_map.pdf\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"interactive-map-export","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Export Options","what":"Interactive Map Export","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Export interactive map as HTML if (requireNamespace(\"leaflet\", quietly = TRUE)) {   interactive_map <- create_interactive_map(     spatial_data = sample_sf,     fill_variable = \"ndvi\",     title = \"Interactive NDVI Map\"   )      # Save as HTML file   if (requireNamespace(\"htmlwidgets\", quietly = TRUE)) {     htmlwidgets::saveWidget(       interactive_map,       \"interactive_ndvi_map.html\",       selfcontained = TRUE     )   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"multi-layer-visualization","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Advanced Features","what":"Multi-Layer Visualization","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Create comparison visualization create_comparison_map(   data1 = sample_raster,   data2 = sample_raster * 1.2,  # Simulated change   comparison_type = \"side_by_side\",   titles = c(\"Year 1\", \"Year 2\"),   color_scheme = \"ndvi\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"automatic-map-type-detection","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Advanced Features","what":"Automatic Map Type Detection","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# The package automatically detects appropriate mapping approaches  # Point data -> scatter plot with colors point_auto <- create_spatial_map(   spatial_data = sample_sf,   fill_variable = \"ndvi\",   map_type = \"auto\"  # Auto-detects as points )  # Raster data -> raster plot raster_auto <- create_spatial_map(   spatial_data = sample_raster,   map_type = \"auto\"  # Auto-detects as raster )  print(\"Auto-detection completed successfully\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"for-large-datasets","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Performance Tips","what":"For Large Datasets","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# 1. Use terra plotting for speed plot_raster_fast(sample_raster, title = \"Fast Plotting\")  # 2. Simplify data when appropriate # simplified_sf <- sf::st_simplify(complex_sf, dTolerance = 100)  # 3. Use appropriate map types # For very dense points, consider raster interpolation # For large rasters, consider aggregation  # 4. Monitor memory usage print(paste(\"Sample data memory usage:\",              format(object.size(sample_sf), units = \"KB\")))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"memory-management","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Performance Tips","what":"Memory Management","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Clean up large objects when done # rm(large_raster) # gc()  # Garbage collection  # Use temporary files for intermediate results temp_file <- tempfile(fileext = \".tif\") print(paste(\"Temporary file:\", temp_file))  # For very large analyses, process in chunks # chunk_size <- 1000  # Adjust based on available memory"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"crs-mismatches","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Troubleshooting Common Issues","what":"CRS Mismatches","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Check CRS compatibility sample_utm <- sf::st_transform(sample_sf, crs = 3857)  # Web Mercator  # The package handles CRS automatically in most cases mixed_crs_map <- create_spatial_map(   spatial_data = sample_utm,  # UTM coordinates   fill_variable = \"ndvi\",   title = \"Map with Different CRS\" )  print(\"CRS handling completed automatically\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"data-format-issues","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Troubleshooting Common Issues","what":"Data Format Issues","title":"Universal Spatial Mapping with geospatialsuite","text":"","code":"# Test with different data formats formats_test <- list(   sf_object = sample_sf,   data_frame = sample_points,   raster_object = sample_raster )  for (format_name in names(formats_test)) {   tryCatch({     test_map <- quick_map(formats_test[[format_name]])     print(paste(format_name, \"format: OK\"))   }, error = function(e) {     print(paste(format_name, \"format error:\", e$message))   }) }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"summary","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Summary","title":"Universal Spatial Mapping with geospatialsuite","text":"geospatialsuite’s mapping capabilities provide: Auto-detection: quick_map() instant visualization Flexibility: Support points, polygons, lines, rasters Customization: Multiple color schemes styling options Interactivity: Optional leaflet integration Publication quality: High-resolution export options Regional integration: Automatic boundary handling Performance: Efficient terra-based rendering","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"key-functions-summary","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite > Summary","what":"Key Functions Summary","title":"Universal Spatial Mapping with geospatialsuite","text":"quick_map(): One-line mapping auto-detection create_spatial_map(): Comprehensive mapping customization plot_raster_fast(): Efficient raster visualization plot_rgb_raster(): RGB composite mapping create_interactive_map(): Web-based interactive maps create_comparison_map(): /comparisons create_ndvi_map(): Specialized vegetation mapping mapping system designed work reliably minimal dependencies providing extensive customization needed.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-analysis.html","id":"acknowledgments","dir":"Articles","previous_headings":"Universal Spatial Mapping with geospatialsuite","what":"Acknowledgments","title":"Universal Spatial Mapping with geospatialsuite","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Erika . Barcelos, Roger H. French.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatial Data Integration","text":"Spatial data integration essential combining information different sources scales. geospatialsuite package provides universal_spatial_join() function handles major spatial data combinations automatic method detection robust error handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"learning-objectives","dir":"Articles","previous_headings":"","what":"Learning Objectives","title":"Spatial Data Integration","text":"end vignette, able : Integrate vector raster datasets using universal spatial joins Extract raster values point/polygon locations Calculate zonal statistics regions Resample align raster data Handle different coordinate systems automatically Perform multi-scale spatial operations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Spatial Data Integration","text":"","code":"# Load required packages library(geospatialsuite) library(terra) library(sf)  # Verify package functionality test_function_availability() #> $function_status #> $function_status$calculate_vegetation_index #> [1] TRUE #>  #> $function_status$calculate_ndvi_enhanced #> [1] TRUE #>  #> $function_status$calculate_water_index #> [1] TRUE #>  #> $function_status$calculate_multiple_indices #> [1] TRUE #>  #> $function_status$create_spatial_map #> [1] TRUE #>  #> $function_status$quick_map #> [1] TRUE #>  #> $function_status$universal_spatial_join #> [1] TRUE #>  #> $function_status$get_region_boundary #> [1] TRUE #>  #> $function_status$load_raster_data #> [1] TRUE #>  #> $function_status$process_vector_data #> [1] TRUE #>  #>  #> $summary #> $summary$available #> [1] 10 #>  #> $summary$total #> [1] 10 #>  #> $summary$missing #> character(0)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"universal-spatial-join-overview","dir":"Articles","previous_headings":"","what":"Universal Spatial Join Overview","title":"Spatial Data Integration","text":"universal_spatial_join() function automatically detects data types selects appropriate spatial operation: Vector - Raster: Extract raster values points/polygons Raster - Vector: Calculate zonal statistics Raster - Raster: Resample, align, overlay Vector - Vector: Spatial intersection overlay","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"vector-to-raster-extraction-most-common","dir":"Articles","previous_headings":"Basic Spatial Joins","what":"Vector to Raster Extraction (Most Common)","title":"Spatial Data Integration","text":"","code":"# Create sample point data (field sites) field_sites <- data.frame(   site_id = paste0(\"Site_\", 1:20),   lon = runif(20, -83.5, -83.0),   lat = runif(20, 40.2, 40.7),   crop_type = sample(c(\"corn\", \"soybeans\", \"wheat\"), 20, replace = TRUE) )  # Create sample raster data (satellite imagery) satellite_raster <- rast(nrows = 50, ncols = 50,                          xmin = -83.5, xmax = -83.0,                          ymin = 40.2, ymax = 40.7) values(satellite_raster) <- runif(2500, 0.2, 0.9) names(satellite_raster) <- \"ndvi\"  # Extract raster values to points (automatic method detection) extracted_results <- universal_spatial_join(   source_data = field_sites,   target_data = satellite_raster,   method = \"auto\",  # Automatically detects \"extract\"   verbose = TRUE )  # View results - original data plus extracted values head(extracted_results) print(names(extracted_results))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"extraction-with-buffer","dir":"Articles","previous_headings":"Basic Spatial Joins","what":"Extraction with Buffer","title":"Spatial Data Integration","text":"","code":"# Extract values with 100m buffer around each point buffered_extraction <- universal_spatial_join(   source_data = field_sites,   target_data = satellite_raster,   method = \"extract\",   buffer_distance = 0.001,  # ~100m in degrees   summary_function = \"mean\",   verbose = TRUE )  # Compare point vs buffered extraction comparison_data <- data.frame(   site_id = extracted_results$site_id,   point_extraction = extracted_results$extracted_ndvi,   buffer_extraction = buffered_extraction$extracted_ndvi )  # Calculate differences comparison_data$difference <- abs(comparison_data$point_extraction -                                  comparison_data$buffer_extraction) print(summary(comparison_data$difference))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"raster-to-vector-analysis","dir":"Articles","previous_headings":"Zonal Statistics","what":"Raster to Vector Analysis","title":"Spatial Data Integration","text":"","code":"# Create sample polygon data (management zones) management_zones <- data.frame(   zone_id = 1:5,   x_center = runif(5, -83.4, -83.1),   y_center = runif(5, 40.3, 40.6),   zone_type = sample(c(\"irrigated\", \"dryland\"), 5, replace = TRUE) )  # Convert to polygons with buffers zones_sf <- st_as_sf(management_zones,                       coords = c(\"x_center\", \"y_center\"),                       crs = 4326) zones_polygons <- st_buffer(zones_sf, dist = 0.02)  # ~2km buffer  # Calculate zonal statistics zonal_results <- universal_spatial_join(   source_data = satellite_raster,  # Raster first for zonal   target_data = zones_polygons,    # Polygons second   method = \"zonal\",   summary_function = \"mean\",   verbose = TRUE )  # View zonal statistics head(zonal_results)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"multiple-summary-functions","dir":"Articles","previous_headings":"Zonal Statistics","what":"Multiple Summary Functions","title":"Spatial Data Integration","text":"","code":"# Calculate multiple statistics for each zone summary_functions <- c(\"mean\", \"median\", \"max\", \"min\", \"sd\")  zonal_multi_stats <- list() for (func in summary_functions) {   result <- universal_spatial_join(     source_data = satellite_raster,     target_data = zones_polygons,     method = \"zonal\",     summary_function = func,     verbose = FALSE   )      # Extract the new column   stat_col <- names(result)[!names(result) %in% names(zones_polygons)]   zonal_multi_stats[[func]] <- result[[stat_col[1]]] }  # Combine into summary data frame zone_summary <- data.frame(   zone_id = zones_polygons$zone_id,   zone_type = zones_polygons$zone_type,   mean_ndvi = zonal_multi_stats$mean,   median_ndvi = zonal_multi_stats$median,   max_ndvi = zonal_multi_stats$max,   min_ndvi = zonal_multi_stats$min,   sd_ndvi = zonal_multi_stats$sd )  print(zone_summary)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"raster-resampling-and-alignment","dir":"Articles","previous_headings":"Raster Operations","what":"Raster Resampling and Alignment","title":"Spatial Data Integration","text":"","code":"# Create rasters with different resolutions high_res_raster <- rast(nrows = 100, ncols = 100,                         xmin = -83.5, xmax = -83.0,                         ymin = 40.2, ymax = 40.7) values(high_res_raster) <- runif(10000, 0.3, 0.8) names(high_res_raster) <- \"detailed_ndvi\"  low_res_raster <- rast(nrows = 20, ncols = 20,                        xmin = -83.5, xmax = -83.0,                        ymin = 40.2, ymax = 40.7) values(low_res_raster) <- runif(400, 0.1, 0.6) names(low_res_raster) <- \"coarse_data\"  # Resample high resolution to match low resolution resampled_result <- universal_spatial_join(   source_data = high_res_raster,   target_data = low_res_raster,   method = \"resample\",   summary_function = \"mean\",   verbose = TRUE )  # Check resolution change cat(\"Original resolution:\", res(high_res_raster), \"\\n\") cat(\"Resampled resolution:\", res(resampled_result), \"\\n\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"scale-factor-operations","dir":"Articles","previous_headings":"Raster Operations","what":"Scale Factor Operations","title":"Spatial Data Integration","text":"","code":"# Aggregate by scale factor (coarser resolution) aggregated_raster <- universal_spatial_join(   source_data = high_res_raster,   target_data = NULL,  # No target needed for scaling   method = \"resample\",   scale_factor = 5,    # 5x coarser resolution   summary_function = \"mean\",   verbose = TRUE )  # Disaggregate (finer resolution) disaggregated_raster <- universal_spatial_join(   source_data = low_res_raster,   target_data = NULL,   method = \"resample\",   scale_factor = 0.5,  # 2x finer resolution   verbose = TRUE )  cat(\"Original low res:\", res(low_res_raster), \"\\n\") cat(\"Disaggregated res:\", res(disaggregated_raster), \"\\n\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"spatial-overlay","dir":"Articles","previous_headings":"Vector to Vector Operations","what":"Spatial Overlay","title":"Spatial Data Integration","text":"","code":"# Create county boundaries (simplified) counties <- data.frame(   county = c(\"Franklin\", \"Delaware\", \"Union\"),   x_center = c(-83.0, -83.1, -83.3),   y_center = c(40.0, 40.4, 40.2) )  counties_sf <- st_as_sf(counties, coords = c(\"x_center\", \"y_center\"), crs = 4326) counties_polygons <- st_buffer(counties_sf, dist = 0.15)  # Large county-like areas  # Find which county each field site is in sites_with_counties <- universal_spatial_join(   source_data = field_sites,   target_data = counties_polygons,   method = \"overlay\",   verbose = TRUE )  # View results head(sites_with_counties)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"nearest-neighbor-analysis","dir":"Articles","previous_headings":"Vector to Vector Operations","what":"Nearest Neighbor Analysis","title":"Spatial Data Integration","text":"","code":"# Find nearest weather station for each field site weather_stations <- data.frame(   station_id = paste0(\"WX_\", 1:8),   longitude = runif(8, -83.6, -82.9),   latitude = runif(8, 40.1, 40.8),   elevation = runif(8, 200, 400),   avg_temp = runif(8, 10, 15) )  nearest_results <- universal_spatial_join(   source_data = field_sites,   target_data = weather_stations,   method = \"nearest\",   verbose = TRUE )  # Check distances to nearest stations # The function automatically calculates spatial relationships head(nearest_results)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"multi-dataset-integration","dir":"Articles","previous_headings":"Advanced Integration Techniques","what":"Multi-Dataset Integration","title":"Spatial Data Integration","text":"","code":"# Integrate multiple datasets to field sites raster_datasets <- list(   elevation = rast(nrows = 30, ncols = 30,                    xmin = -83.5, xmax = -83.0,                    ymin = 40.2, ymax = 40.7),   temperature = rast(nrows = 30, ncols = 30,                      xmin = -83.5, xmax = -83.0,                      ymin = 40.2, ymax = 40.7),   precipitation = rast(nrows = 30, ncols = 30,                        xmin = -83.5, xmax = -83.0,                        ymin = 40.2, ymax = 40.7) )  # Add random values values(raster_datasets$elevation) <- runif(900, 200, 400) values(raster_datasets$temperature) <- runif(900, 8, 18) values(raster_datasets$precipitation) <- runif(900, 800, 1200)  # Extract all environmental variables to field sites environmental_data <- field_sites for (var_name in names(raster_datasets)) {   extraction_result <- universal_spatial_join(     source_data = environmental_data,     target_data = raster_datasets[[var_name]],     method = \"extract\",     verbose = FALSE   )      # Add extracted values to main dataset   new_col <- names(extraction_result)[!names(extraction_result) %in% names(environmental_data)]   environmental_data[[var_name]] <- extraction_result[[new_col[1]]] }  # View integrated dataset head(environmental_data)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"terrain-analysis-integration","dir":"Articles","previous_headings":"Advanced Integration Techniques","what":"Terrain Analysis Integration","title":"Spatial Data Integration","text":"","code":"# Create sample DEM dem_raster <- rast(nrows = 60, ncols = 60,                    xmin = -83.5, xmax = -83.0,                    ymin = 40.2, ymax = 40.7) values(dem_raster) <- runif(3600, 200, 500) names(dem_raster) <- \"elevation\"  # Use the integrated terrain analysis function terrain_results <- integrate_terrain_analysis(   vector_data = field_sites,   elevation_raster = dem_raster,   terrain_vars = c(\"slope\", \"aspect\", \"TRI\", \"TPI\"),   extraction_method = \"extract\" )  # View terrain-enhanced field sites head(terrain_results)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"automatic-crs-management","dir":"Articles","previous_headings":"Coordinate Reference System Handling","what":"Automatic CRS Management","title":"Spatial Data Integration","text":"","code":"# Create data in different coordinate systems utm_points <- data.frame(   id = 1:10,   x_utm = runif(10, 300000, 350000),  # UTM coordinates   y_utm = runif(10, 4450000, 4480000) )  # Convert to UTM Zone 17N utm_sf <- st_as_sf(utm_points, coords = c(\"x_utm\", \"y_utm\"), crs = 32617)  # Our raster is in WGS84 (EPSG:4326) wgs84_raster <- satellite_raster  # Universal spatial join handles CRS conversion automatically utm_extraction <- universal_spatial_join(   source_data = utm_sf,   target_data = wgs84_raster,   method = \"extract\",   verbose = TRUE  # Shows CRS conversion messages )  # Check that extraction worked despite different CRS head(utm_extraction)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"manual-crs-specification","dir":"Articles","previous_headings":"Coordinate Reference System Handling","what":"Manual CRS Specification","title":"Spatial Data Integration","text":"","code":"# Force specific output CRS projected_result <- universal_spatial_join(   source_data = field_sites,   target_data = satellite_raster,   method = \"extract\",   crs_target = 32617,  # UTM Zone 17N   verbose = TRUE )  # Check output CRS st_crs(projected_result)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"na-strategy-options","dir":"Articles","previous_headings":"Handling Missing Data","what":"NA Strategy Options","title":"Spatial Data Integration","text":"","code":"# Create raster with some NA values sparse_raster <- satellite_raster values(sparse_raster)[sample(1:ncell(sparse_raster), 500)] <- NA names(sparse_raster) <- \"sparse_data\"  # Different strategies for handling NAs strategies <- c(\"remove\", \"nearest\", \"zero\")  na_handling_results <- list() for (strategy in strategies) {   result <- universal_spatial_join(     source_data = field_sites,     target_data = sparse_raster,     method = \"extract\",     na_strategy = strategy,     verbose = FALSE   )      extracted_col <- names(result)[grepl(\"extracted\", names(result))]   na_handling_results[[strategy]] <- result[[extracted_col[1]]] }  # Compare different NA handling approaches na_comparison <- data.frame(   site_id = field_sites$site_id,   remove_na = na_handling_results$remove,   nearest_fill = na_handling_results$nearest,   zero_fill = na_handling_results$zero )  # Count NAs in each approach sapply(na_comparison[-1], function(x) sum(is.na(x)))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"multi-scale-analysis","dir":"Articles","previous_headings":"Advanced Spatial Operations","what":"Multi-Scale Analysis","title":"Spatial Data Integration","text":"","code":"# Create rasters at different scales scales <- c(1, 2, 4, 8)  # Different aggregation levels multi_scale_data <- list()  base_raster <- satellite_raster for (scale in scales) {   if (scale == 1) {     multi_scale_data[[paste0(\"scale_\", scale)]] <- base_raster   } else {     aggregated <- universal_spatial_join(       source_data = base_raster,       target_data = NULL,       method = \"resample\",       scale_factor = scale,       summary_function = \"mean\"     )     multi_scale_data[[paste0(\"scale_\", scale)]] <- aggregated   } }  # Extract values at different scales multi_scale_extraction <- field_sites for (scale_name in names(multi_scale_data)) {   result <- universal_spatial_join(     source_data = multi_scale_extraction,     target_data = multi_scale_data[[scale_name]],     method = \"extract\",     verbose = FALSE   )      # Add to main dataset   new_col <- names(result)[!names(result) %in% names(multi_scale_extraction)]   multi_scale_extraction[[scale_name]] <- result[[new_col[1]]] }  # Analyze scale effects scale_columns <- names(multi_scale_extraction)[grepl(\"scale_\", names(multi_scale_extraction))] scale_analysis <- multi_scale_extraction[c(\"site_id\", scale_columns)] head(scale_analysis)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"spatial-interpolation-integration","dir":"Articles","previous_headings":"Advanced Spatial Operations","what":"Spatial Interpolation Integration","title":"Spatial Data Integration","text":"","code":"# Create sparse monitoring data sparse_monitoring <- data.frame(   monitor_id = 1:8,   longitude = runif(8, -83.4, -83.1),   latitude = runif(8, 40.3, 40.6),   soil_ph = runif(8, 6.0, 7.5),   organic_matter = runif(8, 2, 6) )  # Some missing values sparse_monitoring$soil_ph[c(2, 5)] <- NA sparse_monitoring$organic_matter[c(3, 7)] <- NA  # Interpolate missing values interpolated_data <- spatial_interpolation_comprehensive(   spatial_data = sparse_monitoring,   target_variables = c(\"soil_ph\", \"organic_matter\"),   method = \"NN\",  # Nearest neighbor   verbose = TRUE )  # Compare before and after interpolation comparison <- data.frame(   original_ph = sparse_monitoring$soil_ph,   interpolated_ph = interpolated_data$soil_ph,   original_om = sparse_monitoring$organic_matter,   interpolated_om = interpolated_data$organic_matter )  print(comparison)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"chunked-processing","dir":"Articles","previous_headings":"Working with Large Datasets","what":"Chunked Processing","title":"Spatial Data Integration","text":"","code":"# Simulate large point dataset large_dataset <- data.frame(   point_id = 1:5000,   x = runif(5000, -83.5, -83.0),   y = runif(5000, 40.2, 40.7),   measurement = runif(5000, 0, 100) )  # Process in chunks for memory efficiency chunked_extraction <- universal_spatial_join(   source_data = large_dataset,   target_data = satellite_raster,   method = \"extract\",   chunk_size = 1000,  # Process 1000 points at a time   verbose = TRUE )  # Check processing efficiency cat(\"Processed\", nrow(chunked_extraction), \"points successfully\\n\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"memory-efficient-raster-operations","dir":"Articles","previous_headings":"Working with Large Datasets","what":"Memory-Efficient Raster Operations","title":"Spatial Data Integration","text":"","code":"# Create multiple large rasters raster_list <- list() for (i in 1:3) {   r <- rast(nrows = 200, ncols = 200,             xmin = -84, xmax = -82, ymin = 40, ymax = 42)   values(r) <- runif(40000, 0, 1)   names(r) <- paste0(\"band_\", i)   raster_list[[i]] <- r }  # Efficiently combine rasters combined_raster <- raster_to_raster_ops(   raster1 = raster_list[[1]],   raster2 = raster_list[[2]],   operation = \"add\",   handle_na = \"ignore\",   verbose = TRUE )  # Multi-raster operations mean_composite <- universal_spatial_join(   source_data = raster_list[[1]],   target_data = raster_list[[2]],   method = \"resample\",   summary_function = \"mean\",   verbose = TRUE )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"agricultural-field-analysis","dir":"Articles","previous_headings":"Real-World Integration Examples","what":"Agricultural Field Analysis","title":"Spatial Data Integration","text":"","code":"# Simulate complete agricultural analysis workflow farm_fields <- data.frame(   field_id = paste0(\"Field_\", LETTERS[1:15]),   longitude = runif(15, -83.4, -83.1),   latitude = runif(15, 40.3, 40.6),   crop_type = sample(c(\"corn\", \"soybeans\"), 15, replace = TRUE),   planting_date = as.Date(\"2023-05-01\") + sample(0:20, 15, replace = TRUE) )  # Convert to polygons (field boundaries) farm_sf <- st_as_sf(farm_fields, coords = c(\"longitude\", \"latitude\"), crs = 4326) field_polygons <- st_buffer(farm_sf, dist = 0.008)  # ~800m field size  # Environmental datasets environmental_rasters <- list(   ndvi = satellite_raster,   elevation = dem_raster,   soil_moisture = rast(nrows = 40, ncols = 40,                        xmin = -83.5, xmax = -83.0,                        ymin = 40.2, ymax = 40.7) ) values(environmental_rasters$soil_moisture) <- runif(1600, 0.1, 0.4)  # Comprehensive field characterization field_analysis <- farm_fields for (env_var in names(environmental_rasters)) {   # Calculate field averages using zonal statistics   zonal_result <- universal_spatial_join(     source_data = environmental_rasters[[env_var]],     target_data = field_polygons,     method = \"zonal\",     summary_function = \"mean\",     verbose = FALSE   )      # Extract the zonal statistic   stat_col <- names(zonal_result)[grepl(\"zonal\", names(zonal_result))]   field_analysis[[paste0(\"avg_\", env_var)]] <- zonal_result[[stat_col[1]]] }  # View comprehensive field analysis head(field_analysis)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"watershed-analysis","dir":"Articles","previous_headings":"Real-World Integration Examples","what":"Watershed Analysis","title":"Spatial Data Integration","text":"","code":"# Create watershed polygons watersheds <- data.frame(   watershed_id = paste0(\"WS_\", 1:6),   outlet_lon = runif(6, -83.4, -83.1),   outlet_lat = runif(6, 40.3, 40.6),   area_km2 = runif(6, 10, 100) )  watersheds_sf <- st_as_sf(watersheds, coords = c(\"outlet_lon\", \"outlet_lat\"), crs = 4326) # Create watershed polygons proportional to area watersheds_polygons <- st_buffer(watersheds_sf, dist = sqrt(watersheds$area_km2) * 0.002)  # Calculate watershed statistics from multiple sources watershed_stats <- watersheds raster_sources <- list(   mean_elevation = dem_raster,   mean_ndvi = satellite_raster,   vegetation_variability = satellite_raster  # Will calculate SD )  summary_functions <- list(   mean_elevation = \"mean\",   mean_ndvi = \"mean\",    vegetation_variability = \"sd\" )  for (var_name in names(raster_sources)) {   result <- universal_spatial_join(     source_data = raster_sources[[var_name]],     target_data = watersheds_polygons,     method = \"zonal\",     summary_function = summary_functions[[var_name]],     verbose = FALSE   )      stat_col <- names(result)[grepl(\"zonal\", names(result))]   watershed_stats[[var_name]] <- result[[stat_col[1]]] }  print(watershed_stats)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"common-issues-and-solutions","dir":"Articles","previous_headings":"Error Handling and Troubleshooting","what":"Common Issues and Solutions","title":"Spatial Data Integration","text":"","code":"# Handle geometry mismatches gracefully mismatched_raster <- rast(nrows = 25, ncols = 30,  # Different aspect ratio                          xmin = -83.6, xmax = -82.9,  # Slightly different extent                          ymin = 40.1, ymax = 40.8) values(mismatched_raster) <- runif(750, 0, 1)  # Function automatically handles alignment robust_extraction <- universal_spatial_join(   source_data = field_sites,   target_data = mismatched_raster,   method = \"extract\",   verbose = TRUE  # Shows alignment messages )  # Handle empty results gracefully empty_region <- data.frame(   x = c(-90, -89),  # Far from our data   y = c(35, 36) )  empty_sf <- st_as_sf(empty_region, coords = c(\"x\", \"y\"), crs = 4326)  # This will work but return NA values where appropriate empty_result <- universal_spatial_join(   source_data = empty_sf,   target_data = satellite_raster,   method = \"extract\",   verbose = TRUE )  print(empty_result)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"performance-monitoring","dir":"Articles","previous_headings":"Error Handling and Troubleshooting","what":"Performance Monitoring","title":"Spatial Data Integration","text":"","code":"# Monitor performance for different data sizes data_sizes <- c(10, 50, 100, 500) performance_results <- data.frame(   n_points = data_sizes,   processing_time = numeric(length(data_sizes)) )  for (i in seq_along(data_sizes)) {   n <- data_sizes[i]   test_points <- data.frame(     id = 1:n,     lon = runif(n, -83.4, -83.1),     lat = runif(n, 40.3, 40.6)   )      start_time <- Sys.time()   result <- universal_spatial_join(     source_data = test_points,     target_data = satellite_raster,     method = \"extract\",     verbose = FALSE   )   end_time <- Sys.time()      performance_results$processing_time[i] <- as.numeric(end_time - start_time) }  print(performance_results)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"combining-with-vegetation-analysis","dir":"Articles","previous_headings":"Integration with Other Package Functions","what":"Combining with Vegetation Analysis","title":"Spatial Data Integration","text":"","code":"# Extract vegetation indices to management zones vegetation_stack <- calculate_multiple_indices(   red = satellite_raster * 0.7,  # Simulate red band   nir = satellite_raster,   indices = c(\"NDVI\", \"DVI\", \"RVI\"),   output_stack = TRUE )  # Extract all vegetation indices to zones vegetation_by_zone <- universal_spatial_join(   source_data = zones_polygons,   target_data = vegetation_stack,   method = \"extract\",   buffer_distance = 0,  # No buffer for polygon extraction   summary_function = \"mean\",   verbose = TRUE )  # Analyze vegetation patterns by zone type zone_veg_summary <- aggregate(   vegetation_by_zone[grepl(\"extracted\", names(vegetation_by_zone))],   by = list(zone_type = vegetation_by_zone$zone_type),   FUN = mean,   na.rm = TRUE )  print(zone_veg_summary)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"integration-with-water-quality","dir":"Articles","previous_headings":"Integration with Other Package Functions","what":"Integration with Water Quality","title":"Spatial Data Integration","text":"","code":"# Combine water indices with field water quality measurements water_index_stack <- calculate_multiple_water_indices(   green = satellite_raster * 0.8,  # Simulate green band   nir = satellite_raster,   swir1 = satellite_raster * 0.5,  # Simulate SWIR1   indices = c(\"NDWI\", \"MNDWI\", \"NDMI\"),   output_stack = TRUE )  # Extract to water quality monitoring sites water_sites <- data.frame(   site_id = paste0(\"WQ_\", 1:12),   longitude = runif(12, -83.4, -83.1),   latitude = runif(12, 40.3, 40.6),   measured_turbidity = runif(12, 5, 25),   measured_chlorophyll = runif(12, 8, 35) )  remote_vs_field <- universal_spatial_join(   source_data = water_sites,   target_data = water_index_stack,   method = \"extract\",   buffer_distance = 0.002,  # 200m buffer   summary_function = \"mean\",   verbose = TRUE )  # Analyze relationships between remote sensing and field data correlations <- cor(   remote_vs_field[c(\"measured_turbidity\", \"measured_chlorophyll\")],   remote_vs_field[grepl(\"extracted\", names(remote_vs_field))],   use = \"complete.obs\" )  print(correlations)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"multi-scale-operations","dir":"Articles","previous_headings":"Specialized Integration Functions","what":"Multi-Scale Operations","title":"Spatial Data Integration","text":"","code":"# Use the specialized multi-scale function multi_scale_analysis <- multiscale_operations(   spatial_data = satellite_raster,   target_scales = c(1, 2, 4, 8),   operation = \"mean\",   pyramid = TRUE )  # Extract at multiple scales to compare spatial patterns scale_comparison <- field_sites for (scale_name in names(multi_scale_analysis)) {   result <- universal_spatial_join(     source_data = scale_comparison,     target_data = multi_scale_analysis[[scale_name]],     method = \"extract\",     verbose = FALSE   )      new_col <- names(result)[!names(result) %in% names(scale_comparison)]   scale_comparison[[scale_name]] <- result[[new_col[1]]] }  # Analyze scale effects scale_vars <- names(scale_comparison)[grepl(\"scale_\", names(scale_comparison))] scale_effects <- scale_comparison[c(\"site_id\", scale_vars)] head(scale_effects)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"raster-mathematical-operations","dir":"Articles","previous_headings":"Specialized Integration Functions","what":"Raster Mathematical Operations","title":"Spatial Data Integration","text":"","code":"# Create two related rasters for mathematical operations raster_a <- satellite_raster raster_b <- rast(nrows = 50, ncols = 50,                  xmin = -83.5, xmax = -83.0,                  ymin = 40.2, ymax = 40.7) values(raster_b) <- runif(2500, 0.1, 0.7)  # Mathematical operations between rasters addition_result <- raster_to_raster_ops(   raster1 = raster_a,   raster2 = raster_b,   operation = \"add\",   align_method = \"resample\",   verbose = TRUE )  difference_result <- raster_to_raster_ops(   raster1 = raster_a,   raster2 = raster_b,   operation = \"subtract\",   handle_na = \"ignore\",   verbose = TRUE )  ratio_result <- raster_to_raster_ops(   raster1 = raster_a,   raster2 = raster_b,   operation = \"ratio\",   verbose = TRUE )  # Extract mathematical results to points math_results <- universal_spatial_join(   source_data = field_sites,   target_data = c(addition_result, difference_result, ratio_result),   method = \"extract\",   verbose = TRUE )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"mapping-integrated-data","dir":"Articles","previous_headings":"Visualization of Integration Results","what":"Mapping Integrated Data","title":"Spatial Data Integration","text":"","code":"# Create comprehensive visualization of integrated results integrated_map <- create_spatial_map(   spatial_data = environmental_data,   fill_variable = \"elevation\",   color_scheme = \"terrain\",   title = \"Field Sites with Environmental Data\",   point_size = 5 )  # Quick visualization of zonal results zonal_map <- create_spatial_map(   spatial_data = zonal_results,   fill_variable = names(zonal_results)[grepl(\"zonal\", names(zonal_results))][1],   map_type = \"polygons\",   color_scheme = \"viridis\",   title = \"Management Zones - Mean NDVI\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"comparison-visualizations","dir":"Articles","previous_headings":"Visualization of Integration Results","what":"Comparison Visualizations","title":"Spatial Data Integration","text":"","code":"# Compare extraction methods comparison_data <- data.frame(   site_id = field_sites$site_id,   point_extraction = extracted_results$extracted_ndvi,   buffer_extraction = buffered_extraction$extracted_ndvi,   difference = abs(extracted_results$extracted_ndvi - buffered_extraction$extracted_ndvi) )  # Plot comparison plot(comparison_data$point_extraction, comparison_data$buffer_extraction,      xlab = \"Point Extraction\", ylab = \"Buffer Extraction\",      main = \"Point vs Buffer Extraction Comparison\") abline(0, 1, col = \"red\", lty = 2)  # 1:1 line"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"data-preparation","dir":"Articles","previous_headings":"Best Practices","what":"Data Preparation","title":"Spatial Data Integration","text":"","code":"# Always validate inputs before processing validate_spatial_data <- function(data) {   if (inherits(data, \"sf\")) {     # Check for valid geometries     invalid_geoms <- !st_is_valid(data)     if (any(invalid_geoms)) {       warning(paste(\"Found\", sum(invalid_geoms), \"invalid geometries\"))       data <- st_make_valid(data)     }   }      if (inherits(data, \"SpatRaster\")) {     # Check for data coverage     valid_cells <- sum(!is.na(values(data, mat = FALSE)))     total_cells <- ncell(data)     coverage <- (valid_cells / total_cells) * 100          if (coverage < 10) {       warning(paste(\"Low data coverage:\", round(coverage, 1), \"%\"))     }   }      return(data) }  # Use validation in workflows validated_sites <- validate_spatial_data(   st_as_sf(field_sites, coords = c(\"lon\", \"lat\"), crs = 4326) ) validated_raster <- validate_spatial_data(satellite_raster)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"method-selection-guidelines","dir":"Articles","previous_headings":"Best Practices","what":"Method Selection Guidelines","title":"Spatial Data Integration","text":"","code":"# Guidelines for choosing spatial join methods method_guide <- data.frame(   Source_Type = c(\"Points\", \"Polygons\", \"Raster\", \"Raster\", \"Points\"),   Target_Type = c(\"Raster\", \"Raster\", \"Polygons\", \"Raster\", \"Points\"),   Recommended_Method = c(\"extract\", \"extract\", \"zonal\", \"resample\", \"nearest\"),   Use_Case = c(\"Sample at locations\", \"Area averages\", \"Regional stats\", \"Align data\", \"Find closest\"),   stringsAsFactors = FALSE )  print(method_guide)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"performance-optimization","dir":"Articles","previous_headings":"Best Practices","what":"Performance Optimization","title":"Spatial Data Integration","text":"","code":"# Optimize for different scenarios optimization_tips <- list(   large_datasets = \"Use chunk_size parameter to control memory usage\",   different_crs = \"Let the function handle CRS conversion automatically\",    missing_data = \"Choose appropriate na_strategy for your analysis needs\",   multiple_variables = \"Process variables separately for better error handling\",   visualization = \"Use quick_map() for fast preliminary visualization\" )  for (tip_name in names(optimization_tips)) {   cat(tip_name, \":\", optimization_tips[[tip_name]], \"\\n\") }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Spatial Data Integration","text":"vignette demonstrated comprehensive spatial data integration using geospatialsuite: Universal Spatial Joins: Automatic method detection data combination Vector-Raster Integration: Extracting values calculating zonal statistics Raster Operations: Resampling, alignment, mathematical operations Multi-Scale Analysis: Working data different resolutions Error Handling: Robust processing automatic CRS geometry management Real-World Applications: Agricultural environmental analysis examples","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"key-functions-used","dir":"Articles","previous_headings":"Summary","what":"Key Functions Used","title":"Spatial Data Integration","text":"universal_spatial_join() - Core integration function auto-detection raster_to_raster_ops() - Mathematical operations rasters multiscale_operations() - Multi-scale analysis capabilities spatial_interpolation_comprehensive() - Fill missing data spatially integrate_terrain_analysis() - Specialized terrain integration","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/spatial-integration.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Spatial Data Integration","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Erika . Barcelos, Roger H. French.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Vegetation Index Analysis with geospatialsuite","text":"vignette demonstrates comprehensive vegetation analysis using geospatialsuite’s 60+ vegetation indices. Learn monitor plant health, detect stress, analyze agricultural productivity.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"loading-required-packages","dir":"Articles","previous_headings":"Introduction","what":"Loading Required Packages","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"library(geospatialsuite) library(terra)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"quick-start-with-sample-data","dir":"Articles","previous_headings":"Introduction","what":"Quick Start with Sample Data","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Load sample spectral bands red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") blue <- load_sample_data(\"sample_blue.rds\")  # Calculate NDVI using geospatialsuite ndvi <- calculate_vegetation_index(   red = red,   nir = nir,   index_type = \"NDVI\" )  # Visualize plot(ndvi, main = \"Normalized Difference Vegetation Index (NDVI)\",      col = terrain.colors(100))"},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"ndvi-normalized-difference-vegetation-index","dir":"Articles","previous_headings":"Understanding Vegetation Indices > Common Vegetation Indices","what":"NDVI (Normalized Difference Vegetation Index)","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Calculate NDVI with geospatialsuite ndvi <- calculate_vegetation_index(   red = red,   nir = nir,   index_type = \"NDVI\" )  # Summary statistics summary(values(ndvi)) #>       NDVI        #>  Min.   :0.4785   #>  1st Qu.:0.6473   #>  Median :0.7172   #>  Mean   :0.7069   #>  3rd Qu.:0.7725   #>  Max.   :0.8752  # Classify vegetation density vegetation_classes <- classify(ndvi,   rcl = matrix(c(-Inf, 0.2, 1,                  0.2, 0.6, 2,                  0.6, Inf, 3),                 ncol = 3, byrow = TRUE) )  plot(vegetation_classes,       main = \"Vegetation Density Classes\",      col = c(\"brown\", \"yellow\", \"darkgreen\"),      legend = FALSE) legend(\"topright\",         legend = c(\"Sparse\", \"Moderate\", \"Dense\"),        fill = c(\"brown\", \"yellow\", \"darkgreen\"))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"evi-enhanced-vegetation-index","dir":"Articles","previous_headings":"Understanding Vegetation Indices > Common Vegetation Indices","what":"EVI (Enhanced Vegetation Index)","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Calculate EVI using geospatialsuite evi <- calculate_vegetation_index(   red = red,   nir = nir,   blue = blue,   index_type = \"EVI\" )  # Compare NDVI and EVI par(mfrow = c(1, 2)) plot(ndvi, main = \"NDVI\", col = terrain.colors(100)) plot(evi, main = \"EVI\", col = terrain.colors(100)) par(mfrow = c(1, 1))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"savi-soil-adjusted-vegetation-index","dir":"Articles","previous_headings":"Understanding Vegetation Indices > Common Vegetation Indices","what":"SAVI (Soil Adjusted Vegetation Index)","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Calculate SAVI with geospatialsuite savi <- calculate_vegetation_index(   red = red,   nir = nir,   index_type = \"SAVI\" )  plot(savi, main = \"Soil Adjusted Vegetation Index (SAVI)\",      col = terrain.colors(100))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"calculate-multiple-indices","dir":"Articles","previous_headings":"Understanding Vegetation Indices","what":"Calculate Multiple Indices","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# geospatialsuite can calculate multiple indices at once indices <- calculate_multiple_indices(   red = red,   nir = nir,   blue = blue,   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"GNDVI\", \"NDRE\"),   output_stack = TRUE )  # Plot all indices plot(indices, main = names(indices)) # Access individual indices ndvi_layer <- indices$NDVI evi_layer <- indices$EVI"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"working-with-multi-band-rasters","dir":"Articles","previous_headings":"Understanding Vegetation Indices","what":"Working with Multi-band Rasters","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Load multi-band raster multiband <- load_sample_data(\"sample_multiband.rds\")  # Check available bands names(multiband) #> [1] \"blue\"  \"green\" \"red\"   \"nir\"   \"swir1\"  # geospatialsuite's auto-detect feature ndvi_auto <- calculate_vegetation_index(   spectral_data = multiband,   index_type = \"NDVI\",   auto_detect_bands = TRUE  # Automatically finds red and nir! )  # Calculate multiple indices with auto-detection indices_auto <- calculate_multiple_indices(   spectral_data = multiband,   indices = c(\"NDVI\", \"EVI\", \"GNDVI\"),   auto_detect_bands = TRUE,   output_stack = TRUE )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"loading-and-processing-landsat-data","dir":"Articles","previous_headings":"Working with Satellite Imagery","what":"Loading and Processing Landsat Data","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Use geospatialsuite with Landsat imagery  # 1. Load Landsat bands using geospatialsuite landsat_bands <- load_raster_data(   \"landsat/LC08_L2SP_021033_20240715/\",   pattern = \"SR_B[2-5].TIF$\",   verbose = TRUE )  # geospatialsuite validates and loads all bands # Extract individual bands (assuming they're scaled to 0-1) blue <- landsat_bands[[1]] green <- landsat_bands[[2]] red <- landsat_bands[[3]] nir <- landsat_bands[[4]]  # 2. Calculate indices using geospatialsuite # It has 60+ pre-programmed indices landsat_indices <- calculate_multiple_indices(   red = red,   nir = nir,   blue = blue,   green = green,   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"GNDVI\", \"MSAVI\", \"OSAVI\"),   output_stack = TRUE )  # 3. Visualize using geospatialsuite quick_map(landsat_indices$NDVI, title = \"Landsat 8 NDVI\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"processing-sentinel-2-imagery","dir":"Articles","previous_headings":"Working with Satellite Imagery","what":"Processing Sentinel-2 Imagery","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Use geospatialsuite with Sentinel-2  # 1. Load Sentinel-2 bands using geospatialsuite s2_bands <- load_raster_data(   \"sentinel2/S2A_MSIL2A_20240715/GRANULE/.../IMG_DATA/R10m/\",   pattern = \"*_B0[2-8]_10m.jp2$\",   verbose = TRUE )  # geospatialsuite handles JPEG2000 format # Assuming bands are ordered: blue, green, red, nir # and scaled to 0-1  # 2. Calculate comprehensive indices with geospatialsuite s2_indices <- calculate_multiple_indices(   red = s2_bands[[3]],   nir = s2_bands[[4]],   blue = s2_bands[[1]],   green = s2_bands[[2]],   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"GNDVI\", \"NDMI\"),   output_stack = TRUE )  # 3. Visualize quick_map(s2_indices$NDVI, title = \"Sentinel-2 NDVI (10m)\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"multi-temporal-analysis","dir":"Articles","previous_headings":"Working with Satellite Imagery","what":"Multi-Temporal Analysis","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Track vegetation changes with geospatialsuite  # Load imagery from different dates dates <- c(\"2024-05-01\", \"2024-06-01\", \"2024-07-01\") ndvi_series <- list()  for (date in dates) {   # Load bands for each date using geospatialsuite   bands <- load_raster_data(     sprintf(\"satellite/%s/\", date),     pattern = \"B[4-5].tif$\"   )      red_date <- bands[[1]]   nir_date <- bands[[2]]      # Calculate NDVI using geospatialsuite   ndvi_series[[date]] <- calculate_vegetation_index(     red = red_date,     nir = nir_date,     index_type = \"NDVI\"   ) }  # Stack time series ndvi_stack <- rast(ndvi_series) names(ndvi_stack) <- dates  # Visualize temporal progression plot(ndvi_stack, main = paste(\"NDVI -\", dates))  # Calculate change ndvi_change <- ndvi_stack[[3]] - ndvi_stack[[1]] plot(ndvi_change,       main = \"NDVI Change (Jul - May)\",      col = colorRampPalette(c(\"red\", \"white\", \"green\"))(100))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"chlorophyll-content-indices","dir":"Articles","previous_headings":"Specialized Vegetation Indices","what":"Chlorophyll Content Indices","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Green NDVI - sensitive to chlorophyll content green <- load_sample_data(\"sample_green.rds\")  # Calculate using geospatialsuite gndvi <- calculate_vegetation_index(   green = green,   nir = nir,   index_type = \"GNDVI\" )  plot(gndvi, main = \"Green NDVI - Chlorophyll Indicator\",      col = colorRampPalette(c(\"white\", \"lightgreen\", \"darkgreen\"))(100))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"water-content-indices","dir":"Articles","previous_headings":"Specialized Vegetation Indices","what":"Water Content Indices","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Load SWIR band for water content analysis swir1 <- load_sample_data(\"sample_swir1.rds\")  # NDMI using geospatialsuite ndmi <- calculate_vegetation_index(   nir = nir,   swir1 = swir1,   index_type = \"NDMI\" )  plot(ndmi, main = \"Vegetation Water Content (NDMI)\",      col = colorRampPalette(c(\"brown\", \"yellow\", \"blue\"))(100))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"zonal-statistics","dir":"Articles","previous_headings":"Advanced Analysis","what":"Zonal Statistics","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Load sample boundary boundary <- load_sample_data(\"sample_boundary.rds\")  # Calculate NDVI using geospatialsuite ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # Extract statistics for the region stats <- terra::extract(ndvi, vect(boundary), fun = function(x) {   c(mean = mean(x, na.rm = TRUE),     sd = sd(x, na.rm = TRUE),     min = min(x, na.rm = TRUE),     max = max(x, na.rm = TRUE)) })  print(stats) #>      ID     NDVI     NDVI.1    NDVI.2    NDVI.3 #> [1,]  1 0.706874 0.08445837 0.4784537 0.8752122"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"field-level-analysis","dir":"Articles","previous_headings":"Advanced Analysis","what":"Field-Level Analysis","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Load sample field points field_points <- load_sample_data(\"sample_points.rds\")  # Calculate NDVI using geospatialsuite ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # Extract using geospatialsuite's spatial join field_ndvi <- universal_spatial_join(   source_data = field_points,   target_data = ndvi,   method = \"extract\" )  # View results head(field_ndvi) #> Simple feature collection with 6 features and 7 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -83.94662 ymin: 39.00987 xmax: -83.91607 ymax: 39.09223 #> Geodetic CRS:  WGS 84 #>   site_id  ndvi   evi crop_type elevation_m soil_moisture #> 1 SITE_01 0.593 0.274  soybeans         269          0.27 #> 2 SITE_02 0.660 0.485     wheat         283          0.28 #> 3 SITE_03 0.646 0.579      corn         211          0.21 #> 4 SITE_04 0.388 0.483   pasture         256          0.31 #> 5 SITE_05 0.776 0.588      corn         219          0.35 #> 6 SITE_06 0.645 0.539  soybeans         205          0.30 #>                     geometry extracted_NDVI #> 1 POINT (-83.94662 39.04604)      0.7709993 #> 2 POINT (-83.94162 39.00987)      0.7667765 #> 3 POINT (-83.94104 39.02066)      0.7647660 #> 4  POINT (-83.9309 39.09223)      0.7207893 #> 5 POINT (-83.93327 39.03194)      0.6405917 #> 6 POINT (-83.91607 39.02653)      0.7215534"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"working-with-real-field-data","dir":"Articles","previous_headings":"Advanced Analysis","what":"Working with Real Field Data","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Complete field analysis workflow with geospatialsuite  library(sf)  # 1. Load field boundaries fields <- sf::st_read(\"farm_data/field_boundaries.shp\")  # 2. Load and process satellite data using geospatialsuite satellite_bands <- load_raster_data(   \"satellite/imagery/\",   pattern = \"B[2-5].tif$\" )  # 3. Calculate indices using geospatialsuite indices <- calculate_multiple_indices(   red = satellite_bands[[3]],   nir = satellite_bands[[4]],   blue = satellite_bands[[1]],   green = satellite_bands[[2]],   indices = c(\"NDVI\", \"EVI\", \"GNDVI\", \"SAVI\"),   output_stack = TRUE )  # 4. Extract to fields using geospatialsuite fields_with_indices <- universal_spatial_join(   source_data = fields,   target_data = indices,   method = \"extract\" )  # geospatialsuite extracted all 4 indices # Each field now has mean NDVI, EVI, GNDVI, SAVI names(fields_with_indices)  # 5. Visualize using geospatialsuite quick_map(fields_with_indices, variable = \"NDVI\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"list-available-indices","dir":"Articles","previous_headings":"","what":"List Available Indices","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# View all available vegetation indices in geospatialsuite all_indices <- list_vegetation_indices()  # Show first few indices head(all_indices[, c(\"Index\", \"Category\", \"Description\", \"Required_Bands\")], 10) #>    Index Category                              Description Required_Bands #> 1   NDVI    basic   Normalized Difference Vegetation Index       Red, NIR #> 2   SAVI    basic           Soil Adjusted Vegetation Index       Red, NIR #> 3  MSAVI    basic  Modified Soil Adjusted Vegetation Index       Red, NIR #> 4  OSAVI    basic Optimized Soil Adjusted Vegetation Index       Red, NIR #> 5    EVI    basic                Enhanced Vegetation Index Red, NIR, Blue #> 6   EVI2    basic       Two-band Enhanced Vegetation Index       Red, NIR #> 7    DVI    basic              Difference Vegetation Index       Red, NIR #> 8    RVI    basic                   Ratio Vegetation Index       Red, NIR #> 9  GNDVI    basic                               Green NDVI     Green, NIR #> 10  WDVI    basic     Weighted Difference Vegetation Index       Red, NIR  # Filter by category health_indices <- all_indices[all_indices$Category == \"basic\", ] print(health_indices[, c(\"Index\", \"Description\")]) #>    Index                              Description #> 1   NDVI   Normalized Difference Vegetation Index #> 2   SAVI           Soil Adjusted Vegetation Index #> 3  MSAVI  Modified Soil Adjusted Vegetation Index #> 4  OSAVI Optimized Soil Adjusted Vegetation Index #> 5    EVI                Enhanced Vegetation Index #> 6   EVI2       Two-band Enhanced Vegetation Index #> 7    DVI              Difference Vegetation Index #> 8    RVI                   Ratio Vegetation Index #> 9  GNDVI                               Green NDVI #> 10  WDVI     Weighted Difference Vegetation Index"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"index-selection-guidelines","dir":"Articles","previous_headings":"Best Practices","what":"Index Selection Guidelines","title":"Vegetation Index Analysis with geospatialsuite","text":"NDVI: General vegetation monitoring EVI: Dense vegetation, atmospheric correction SAVI: Sparse vegetation, early growth GNDVI: Chlorophyll content, nitrogen status NDMI: Water stress detection","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"data-quality-considerations","dir":"Articles","previous_headings":"Best Practices","what":"Data Quality Considerations","title":"Vegetation Index Analysis with geospatialsuite","text":"","code":"# Check for valid value ranges ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")  # NDVI should be between -1 and 1 ndvi_stats <- global(ndvi, fun = \"range\", na.rm = TRUE) cat(\"NDVI range:\", ndvi_stats[1,1], \"to\", ndvi_stats[2,1], \"\\n\") #> NDVI range: 0.4784537 to NA"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/vegetation-indices.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Vegetation Index Analysis with geospatialsuite","text":"vignette covered: Using geospatialsuite’s calculate_vegetation_index() 60+ indices Using calculate_multiple_indices() batch processing Auto band detection auto_detect_bands = TRUE Loading satellite data load_raster_data() Spatial extraction universal_spatial_join() Multi-temporal analysis workflows Field-level analysis Best practices index selection geospatialsuite simplifies vegetation analysis : Pre-programmed indices Automatic band detection Robust error handling Simple, consistent API information: Agricultural Applications geospatialsuite Complete Workflows Case Studies Getting Started geospatialsuite","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Water Quality Assessment","text":"geospatialsuite package provides comprehensive tools water quality assessment using remote sensing data. vignette demonstrates water detection indices, quality parameter monitoring, basic trend analysis using package’s reliable functions.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"learning-objectives","dir":"Articles","previous_headings":"","what":"Learning Objectives","title":"Water Quality Assessment","text":"end vignette, able : Calculate water detection indices (NDWI, MNDWI, NDMI) Analyze water quality parameters field data Detect temporal changes water conditions Create water quality visualizations Apply threshold-based classifications","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Water Quality Assessment","text":"","code":"# Load required packages library(geospatialsuite) library(terra) library(sf)  # Check package functionality test_package_minimal() #> [1] TRUE"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"basic-water-index-calculation","dir":"Articles","previous_headings":"Water Detection Indices","what":"Basic Water Index Calculation","title":"Water Quality Assessment","text":"package includes multiple water indices different applications:","code":"# Load sample bands (Green, NIR, SWIR1) green_band <- rast(nrows = 100, ncols = 100,                     xmin = -84, xmax = -83, ymin = 40, ymax = 41) values(green_band) <- runif(10000, 0.2, 0.4)  nir_band <- rast(nrows = 100, ncols = 100,                   xmin = -84, xmax = -83, ymin = 40, ymax = 41) values(nir_band) <- runif(10000, 0.4, 0.8)  swir1_band <- rast(nrows = 100, ncols = 100,                     xmin = -84, xmax = -83, ymin = 40, ymax = 41) values(swir1_band) <- runif(10000, 0.1, 0.3)  # Calculate Original NDWI (McFeeters 1996) - Water body detection ndwi <- calculate_water_index(   green = green_band,   nir = nir_band,   index_type = \"NDWI\",   verbose = TRUE )  # Calculate Modified NDWI (Xu 2006) - Enhanced water detection mndwi <- calculate_water_index(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   index_type = \"MNDWI\",   verbose = TRUE )  # Calculate NDMI (Gao 1996) - Vegetation moisture content ndmi <- calculate_water_index(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   index_type = \"NDMI\",   verbose = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"available-water-indices","dir":"Articles","previous_headings":"Water Detection Indices","what":"Available Water Indices","title":"Water Quality Assessment","text":"See available water indices applications:","code":"# List all available water indices water_indices_info <- list_water_indices(detailed = TRUE) print(water_indices_info) #>   Index                Type Required_Bands Primary_Application #> 1  NDWI     Water Detection     Green, NIR     water_detection #> 2 MNDWI     Water Detection   Green, SWIR1     water_detection #> 3  NDMI Vegetation Moisture     NIR, SWIR1 moisture_monitoring #> 4   MSI     Moisture Stress     NIR, SWIR1  drought_assessment #> 5  NDII Vegetation Moisture     NIR, SWIR1 moisture_monitoring #> 6    WI       Water Content     NIR, SWIR1 moisture_monitoring #> 7  SRWI       Water Content     NIR, SWIR1 moisture_monitoring #> 8  LSWI       Surface Water     NIR, SWIR1     water_detection #>                                                                           Description #> 1 Normalized Difference Water Index (McFeeters 1996) - Original water detection index #> 2 Modified NDWI (Xu 2006) - Enhanced water detection, reduces built-up area confusion #> 3          Normalized Difference Moisture Index (Gao 1996) - Vegetation water content #> 4        Moisture Stress Index - Plant water stress detection (lower = more moisture) #> 5     Normalized Difference Infrared Index - Alternative name for vegetation moisture #> 6                             Water Index - Simple ratio for water content assessment #> 7                       Simple Ratio Water Index - Water content using NIR/SWIR ratio #> 8                         Land Surface Water Index - Surface water content assessment #>   Value_Range  Water_Threshold          Reference #> 1     [-1, 1]            > 0.3   McFeeters (1996) #> 2     [-1, 1]            > 0.5          Xu (2006) #> 3     [-1, 1] N/A (vegetation)         Gao (1996) #> 4    [0, 10+]            < 1.0            Various #> 5     [-1, 1] N/A (vegetation) Hunt & Rock (1989) #> 6    [0, 10+]            > 1.0            Various #> 7    [0, 10+]            > 1.0            Various #> 8     [-1, 1]            > 0.0 Xiao et al. (2002) #>                             Formula #> 1     (Green - NIR) / (Green + NIR) #> 2 (Green - SWIR1) / (Green + SWIR1) #> 3     (NIR - SWIR1) / (NIR + SWIR1) #> 4                       SWIR1 / NIR #> 5     (NIR - SWIR1) / (NIR + SWIR1) #> 6                       NIR / SWIR1 #> 7                       NIR / SWIR1 #> 8     (NIR - SWIR1) / (NIR + SWIR1) #>                                      Satellite_Bands #> 1  Landsat: B3,B5 | Sentinel-2: B3,B8 | MODIS: B4,B2 #> 2 Landsat: B3,B6 | Sentinel-2: B3,B11 | MODIS: B4,B6 #> 3 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #> 4 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #> 5 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #> 6 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #> 7 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #> 8 Landsat: B5,B6 | Sentinel-2: B8,B11 | MODIS: B2,B6 #>                                                                            Interpretation #> 1       Water bodies: >0.3, Vegetation: <0, Built-up: 0-0.2. Sensitive to built-up areas. #> 2       Water bodies: >0.5, Vegetation: <0, Built-up: <0.3. Better urban water detection. #> 3        High moisture: >0.4, Moderate: 0.1-0.4, Low: <0.1. For vegetation water content. #> 4     High moisture: <1.0, Moderate: 1.0-1.6, Stress: >1.6. Lower values = more moisture. #> 5                  Same as NDMI. High values indicate higher vegetation moisture content. #> 6 Higher values generally indicate higher water content. Threshold varies by application. #> 7                                Similar to WI. Used for simple water content assessment. #> 8  Higher values indicate more surface water. Used for wetland and irrigation monitoring.  # Get indices for specific applications water_detection <- list_water_indices(application_filter = \"water_detection\") moisture_monitoring <- list_water_indices(application_filter = \"moisture_monitoring\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"multiple-water-index-calculation","dir":"Articles","previous_headings":"Water Detection Indices","what":"Multiple Water Index Calculation","title":"Water Quality Assessment","text":"Calculate multiple indices simultaneously comprehensive analysis:","code":"# Calculate multiple water indices at once water_analysis <- calculate_multiple_water_indices(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   indices = c(\"NDWI\", \"MNDWI\", \"NDMI\", \"MSI\"),   output_stack = TRUE,   verbose = TRUE )  # Access individual indices ndwi_layer <- water_analysis[[\"NDWI\"]] mndwi_layer <- water_analysis[[\"MNDWI\"]]"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"comprehensive-water-body-characterization","dir":"Articles","previous_headings":"Water Body Analysis","what":"Comprehensive Water Body Characterization","title":"Water Quality Assessment","text":"","code":"# Perform complete water body analysis water_body_analysis <- analyze_water_bodies(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   water_threshold_ndwi = 0.3,   water_threshold_mndwi = 0.5,   verbose = TRUE )  # Access results water_indices <- water_body_analysis$water_indices water_masks <- water_body_analysis$water_masks statistics <- water_body_analysis$statistics  # Print water body statistics print(statistics) #> $ndwi_water #> $ndwi_water$water_pixels #> [1] 0 #>  #> $ndwi_water$total_pixels #> [1] 10000 #>  #> $ndwi_water$water_percentage #> [1] 0 #>  #> $ndwi_water$pixel_area_m2 #> [1] 1e-04 #>  #> $ndwi_water$estimated_water_area_m2 #> [1] 0 #>  #>  #> $mndwi_water #> $mndwi_water$water_pixels #> [1] 440 #>  #> $mndwi_water$total_pixels #> [1] 10000 #>  #> $mndwi_water$water_percentage #> [1] 4.4 #>  #> $mndwi_water$pixel_area_m2 #> [1] 1e-04 #>  #> $mndwi_water$estimated_water_area_m2 #> [1] 0.044 #>  #>  #> $consensus #> $consensus$water_pixels #> [1] 0 #>  #> $consensus$total_pixels #> [1] 10000 #>  #> $consensus$water_percentage #> [1] 0 #>  #> $consensus$pixel_area_m2 #> [1] 1e-04 #>  #> $consensus$estimated_water_area_m2 #> [1] 0"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"loading-and-processing-water-quality-data","dir":"Articles","previous_headings":"Field Water Quality Data Analysis","what":"Loading and Processing Water Quality Data","title":"Water Quality Assessment","text":"","code":"# Create sample water quality monitoring data sample_water_data <- data.frame(   station_id = paste0(\"WQ_\", 1:50),   longitude = runif(50, -84, -83),   latitude = runif(50, 40, 41),   temperature = runif(50, 15, 25),   ph = runif(50, 6.5, 8.5),   dissolved_oxygen = runif(50, 5, 12),   turbidity = runif(50, 2, 15),   nitrate = runif(50, 0.5, 5.0),   phosphorus = runif(50, 0.1, 2.0),   sample_date = as.Date(\"2023-06-01\") + sample(0:180, 50, replace = TRUE) )  # Comprehensive water quality analysis water_quality_results <- analyze_water_quality_comprehensive(   water_data = sample_water_data,   variable = \"dissolved_oxygen\",   coord_cols = c(\"longitude\", \"latitude\"),   thresholds = list(     Excellent = c(8, Inf),     Good = c(6, 8),     Fair = c(4, 6),     Poor = c(0, 4)   ),   verbose = TRUE )  # Access analysis results quality_stats <- water_quality_results$statistics spatial_patterns <- water_quality_results$spatial_analysis temporal_trends <- water_quality_results$temporal_analysis"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"multi-parameter-analysis","dir":"Articles","previous_headings":"Field Water Quality Data Analysis","what":"Multi-Parameter Analysis","title":"Water Quality Assessment","text":"","code":"# Analyze multiple water quality parameters parameters <- c(\"temperature\", \"ph\", \"dissolved_oxygen\", \"turbidity\")  multi_param_results <- list() for (param in parameters) {   multi_param_results[[param]] <- analyze_water_quality_comprehensive(     water_data = sample_water_data,     variable = param,     verbose = FALSE   ) }  # Extract key statistics param_summary <- sapply(parameters, function(p) {   stats <- multi_param_results[[p]]$statistics$primary_variable   c(mean = stats$mean, sd = stats$sd, min = stats$min, max = stats$max) })  print(param_summary)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"water-index-visualization","dir":"Articles","previous_headings":"Visualization","what":"Water Index Visualization","title":"Water Quality Assessment","text":"","code":"# Quick water index mapping quick_map(ndwi, title = \"NDWI - Water Detection\") quick_map(mndwi, title = \"MNDWI - Enhanced Water Detection\")  # Create water quality map with region boundary water_map <- create_spatial_map(   spatial_data = water_quality_results$water_data,   fill_variable = \"dissolved_oxygen\",   region_boundary = c(-84, 40, -83, 41),  # Custom bounding box   color_scheme = \"water\",   title = \"Dissolved Oxygen Concentrations\",   point_size = 4 )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"comparison-maps","dir":"Articles","previous_headings":"Visualization","what":"Comparison Maps","title":"Water Quality Assessment","text":"","code":"# Compare different water indices comparison_map <- create_comparison_map(   data1 = ndwi,   data2 = mndwi,   comparison_type = \"side_by_side\",   titles = c(\"NDWI (Original)\", \"MNDWI (Modified)\"),   color_scheme = \"water\" )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"water-quality-classification","dir":"Articles","previous_headings":"Threshold Analysis","what":"Water Quality Classification","title":"Water Quality Assessment","text":"","code":"# Apply water quality standards quality_thresholds <- list(   Excellent = c(9, Inf),   Good = c(7, 9),   Moderate = c(5, 7),   Poor = c(3, 5),   Very_Poor = c(0, 3) )  # Classify water quality classified_results <- analyze_water_quality_comprehensive(   water_data = sample_water_data,   variable = \"dissolved_oxygen\",   thresholds = quality_thresholds,   verbose = TRUE )  # View classification results threshold_stats <- classified_results$threshold_analysis$threshold_statistics print(threshold_stats$category_percentages)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"water-body-detection-thresholds","dir":"Articles","previous_headings":"Threshold Analysis","what":"Water Body Detection Thresholds","title":"Water Quality Assessment","text":"","code":"# Apply standard water detection thresholds water_pixels_ndwi <- ndwi > 0.3   # Standard NDWI threshold water_pixels_mndwi <- mndwi > 0.5  # Standard MNDWI threshold  # Combine for consensus water mask consensus_water <- water_pixels_ndwi & water_pixels_mndwi names(consensus_water) <- \"consensus_water_mask\"  # Visualize water detection quick_map(consensus_water, title = \"Consensus Water Detection\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"time-series-water-quality-monitoring","dir":"Articles","previous_headings":"Temporal Analysis","what":"Time Series Water Quality Monitoring","title":"Water Quality Assessment","text":"","code":"# Create temporal water quality data temporal_data <- data.frame(   station_id = rep(paste0(\"WQ_\", 1:10), each = 12),   longitude = rep(runif(10, -84, -83), each = 12),   latitude = rep(runif(10, 40, 41), each = 12),   month = rep(1:12, 10),   dissolved_oxygen = runif(120, 4, 12),   temperature = runif(120, 5, 25),   sample_date = rep(seq(as.Date(\"2023-01-01\"),                         as.Date(\"2023-12-01\"), by = \"month\"), 10) )  # Analyze temporal patterns temporal_results <- analyze_water_quality_comprehensive(   water_data = temporal_data,   variable = \"dissolved_oxygen\",   date_column = \"sample_date\",   station_id_col = \"station_id\",   verbose = TRUE )  # Check for temporal trends if (!is.null(temporal_results$temporal_analysis$trend)) {   trend_info <- temporal_results$temporal_analysis$trend   cat(\"Temporal trend slope:\", trend_info$slope, \"\\n\")   cat(\"Significance (p-value):\", trend_info$p_value, \"\\n\")   cat(\"R-squared:\", trend_info$r_squared, \"\\n\") }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"lake-water-quality-assessment","dir":"Articles","previous_headings":"Real-World Applications","what":"Lake Water Quality Assessment","title":"Water Quality Assessment","text":"","code":"# Simulate lake monitoring scenario lake_stations <- data.frame(   station = paste0(\"Lake_\", LETTERS[1:20]),   lon = runif(20, -83.5, -83.0),   lat = runif(20, 40.2, 40.7),   depth_m = runif(20, 1, 15),   temp_celsius = runif(20, 18, 24),   ph = runif(20, 7.0, 8.5),   do_mg_l = runif(20, 6, 11),   chlorophyll_ug_l = runif(20, 5, 25),   secchi_depth_m = runif(20, 1, 4) )  # Comprehensive lake analysis lake_analysis <- analyze_water_quality_comprehensive(   water_data = lake_stations,   variable = \"do_mg_l\",   coord_cols = c(\"lon\", \"lat\"),   thresholds = list(     Hypoxic = c(0, 2),     Low = c(2, 5),     Adequate = c(5, 8),     High = c(8, Inf)   ) )  # Analyze chlorophyll patterns chlorophyll_analysis <- analyze_water_quality_comprehensive(   water_data = lake_stations,   variable = \"chlorophyll_ug_l\",   thresholds = list(     Oligotrophic = c(0, 4),     Mesotrophic = c(4, 10),     Eutrophic = c(10, Inf)   ) )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"stream-network-integration","dir":"Articles","previous_headings":"Real-World Applications","what":"Stream Network Integration","title":"Water Quality Assessment","text":"","code":"# Analyze water quality along stream network stream_monitoring <- data.frame(   site_id = paste0(\"Stream_\", 1:30),   longitude = runif(30, -83.8, -83.2),   latitude = runif(30, 40.1, 40.8),   stream_order = sample(1:4, 30, replace = TRUE),   flow_cms = runif(30, 0.1, 50),   water_temp = runif(30, 12, 22),   conductivity = runif(30, 200, 800),   total_nitrogen = runif(30, 0.5, 8.0),   total_phosphorus = runif(30, 0.05, 1.5) )  # Analyze nutrient patterns nitrogen_analysis <- analyze_water_quality_comprehensive(   water_data = stream_monitoring,   variable = \"total_nitrogen\",   thresholds = list(     Low = c(0, 2),     Moderate = c(2, 5),     High = c(5, Inf)   ),   verbose = TRUE )  phosphorus_analysis <- analyze_water_quality_comprehensive(   water_data = stream_monitoring,   variable = \"total_phosphorus\",   thresholds = list(     Low = c(0, 0.3),     Moderate = c(0.3, 0.8),     High = c(0.8, Inf)   ) )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"common-issues-and-solutions","dir":"Articles","previous_headings":"Error Handling and Troubleshooting","what":"Common Issues and Solutions","title":"Water Quality Assessment","text":"","code":"# Handle missing coordinate data incomplete_data <- sample_water_data incomplete_data$latitude[1:5] <- NA  # The function automatically handles missing coordinates robust_results <- analyze_water_quality_comprehensive(   water_data = incomplete_data,   variable = \"dissolved_oxygen\",   verbose = TRUE )  # Handle different coordinate column names alt_coord_data <- sample_water_data names(alt_coord_data)[names(alt_coord_data) == \"longitude\"] <- \"x\" names(alt_coord_data)[names(alt_coord_data) == \"latitude\"] <- \"y\"  # Function auto-detects coordinate columns auto_detect_results <- analyze_water_quality_comprehensive(   water_data = alt_coord_data,   variable = \"ph\",   verbose = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"data-quality-checks","dir":"Articles","previous_headings":"Error Handling and Troubleshooting","what":"Data Quality Checks","title":"Water Quality Assessment","text":"","code":"# Apply quality filters during analysis filtered_analysis <- analyze_water_quality_comprehensive(   water_data = sample_water_data,   variable = \"turbidity\",   quality_filters = list(     valid_range = c(0, 100),  # Reasonable turbidity range     remove_outliers = TRUE,     remove_na = TRUE   ),   verbose = TRUE )"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"combining-water-indices-with-vegetation-analysis","dir":"Articles","previous_headings":"Integration with Other Package Functions","what":"Combining Water Indices with Vegetation Analysis","title":"Water Quality Assessment","text":"","code":"# Calculate both water and vegetation indices from the same data # Assume we have a multi-band satellite image red_band <- nir_band * 0.6  # Simulate red band  # Water detection water_indices <- calculate_multiple_water_indices(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   indices = c(\"NDWI\", \"MNDWI\", \"NDMI\") )  # Vegetation analysis veg_indices <- calculate_multiple_indices(   red = red_band,   nir = nir_band,   green = green_band,   indices = c(\"NDVI\", \"GNDVI\", \"DVI\"),   output_stack = TRUE )  # Create combined analysis combined_stack <- c(water_indices, veg_indices) names(combined_stack) <- c(\"NDWI\", \"MNDWI\", \"NDMI\", \"NDVI\", \"GNDVI\", \"DVI\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"spatial-integration-with-field-data","dir":"Articles","previous_headings":"Integration with Other Package Functions","what":"Spatial Integration with Field Data","title":"Water Quality Assessment","text":"","code":"# Extract satellite-derived water indices to field monitoring points extracted_values <- universal_spatial_join(   source_data = sample_water_data,   target_data = water_indices,   method = \"extract\",   buffer_distance = 100,  # 100m buffer around each point   summary_function = \"mean\" )  # Check correlations between field measurements and remote sensing field_vs_remote <- data.frame(   field_turbidity = extracted_values$turbidity,   remote_ndwi = extracted_values$extracted_NDWI,   remote_mndwi = extracted_values$extracted_MNDWI )  # Calculate correlations cor(field_vs_remote, use = \"complete.obs\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"index-selection-guidelines","dir":"Articles","previous_headings":"Best Practices","what":"Index Selection Guidelines","title":"Water Quality Assessment","text":"NDWI: Use general water body detection, especially clear water MNDWI: Better urban areas turbid water detection NDMI: Focus vegetation moisture content drought monitoring MSI: Detect plant water stress (lower values = higher moisture)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"threshold-recommendations","dir":"Articles","previous_headings":"Best Practices","what":"Threshold Recommendations","title":"Water Quality Assessment","text":"","code":"# Standard water detection thresholds standard_thresholds <- list(   NDWI = list(water = 0.3, vegetation = 0.0),   MNDWI = list(water = 0.5, built_up = 0.0),   NDMI = list(high_moisture = 0.4, low_moisture = 0.1) )  # Apply thresholds to create binary water masks water_mask_ndwi <- ndwi > standard_thresholds$NDWI$water water_mask_mndwi <- mndwi > standard_thresholds$MNDWI$water"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"quality-control","dir":"Articles","previous_headings":"Best Practices","what":"Quality Control","title":"Water Quality Assessment","text":"","code":"# Always mask invalid values and apply reasonable ranges quality_controlled_ndwi <- calculate_water_index(   green = green_band,   nir = nir_band,   index_type = \"NDWI\",   clamp_range = c(-1, 1),   mask_invalid = TRUE,   verbose = TRUE )  # Check data coverage values_ndwi <- values(quality_controlled_ndwi, mat = FALSE) coverage_percent <- (sum(!is.na(values_ndwi)) / length(values_ndwi)) * 100 cat(\"Data coverage:\", round(coverage_percent, 1), \"%\\n\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Water Quality Assessment","text":"vignette demonstrated: Water Detection Indices: NDWI, MNDWI, NDMI calculation interpretation Field Data Analysis: Comprehensive water quality parameter assessment Threshold Classification: Application water quality standards Temporal Analysis: Trend detection water quality time series Visualization: Creating effective water quality maps Integration: Combining remote sensing field data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"key-functions-used","dir":"Articles","previous_headings":"Summary","what":"Key Functions Used","title":"Water Quality Assessment","text":"calculate_water_index() - Single water index calculation calculate_multiple_water_indices() - Multiple indices analyze_water_bodies() - Comprehensive water body analysis analyze_water_quality_comprehensive() - Field data analysis list_water_indices() - Available indices information universal_spatial_join() - Spatial data integration create_spatial_map() quick_map() - Visualization","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/water-quality.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Water Quality Assessment","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Vibha Mandayam, Yinghui Wu, Jeffrey Yarus, Erika . Barcelos, Roger H. French.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Complete Workflows and Case Studies","text":"geospatialsuite package provides comprehensive workflow functions integrate multiple analysis types complete, automated pipelines. vignette demonstrates build execute advanced workflows real-world geospatial analysis scenarios.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"learning-objectives","dir":"Articles","previous_headings":"","what":"Learning Objectives","title":"Complete Workflows and Case Studies","text":"end vignette, able : Execute complete analysis pipelines minimal code Build custom workflows specific applications Integrate multiple data sources automatically Handle complex multi-step analysis scenarios Optimize workflows performance reliability Generate comprehensive reports outputs","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Complete Workflows and Case Studies","text":"","code":"# Load required packages library(geospatialsuite) library(terra) library(sf)  # Verify package functionality test_geospatialsuite_package_simple(verbose = TRUE) #> $test_results #> $test_results$basic_ndvi_test #> [1] TRUE #>  #> $test_results$water_index_test #> [1] TRUE #>  #> $test_results$basic_visualization_test #> [1] TRUE #>  #> $test_results$multiple_indices_simple_test #> [1] TRUE #>  #> $test_results$enhanced_ndvi_simple_test #> [1] TRUE #>  #> $test_results$dependencies_test #> [1] TRUE #>  #> $test_results$spatial_operations_test #> [1] TRUE #>  #> $test_results$data_loading_test #> [1] TRUE #>  #>  #> $summary #> $summary$total_tests #> [1] 8 #>  #> $summary$passed_tests #> [1] 8 #>  #> $summary$failed_tests #> [1] 0 #>  #> $summary$success_rate #> [1] 100 #>  #> $summary$duration_seconds #> [1] 0.37 #>  #> $summary$version #> [1] \"0.1.0\" #>  #>  #> $test_output_dir #> [1] \"/tmp/RtmpbuNies\" #>  #> $timestamp #> [1] \"2026-02-05 16:52:38 EST\" #>  #> $test_approach #> [1] \"simplified_robust\" #>  #> $core_message #> [1] \"Focused on essential functionality with minimal complexity\""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"comprehensive-workflow-architecture","dir":"Articles","previous_headings":"","what":"Comprehensive Workflow Architecture","title":"Complete Workflows and Case Studies","text":"package includes pre-built workflows common analysis scenarios: NDVI Crop Analysis: Enhanced vegetation monitoring quality control Vegetation Comprehensive: Multi-index vegetation assessment Water Quality Analysis: Complete water parameter assessment Terrain Analysis: Topographic characterization workflows Temporal Analysis: Time series change detection Interactive Mapping: Multi-layer interactive visualization Multi-Dataset Integration: Combining diverse spatial datasets","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"basic-enhanced-ndvi-workflow","dir":"Articles","previous_headings":"NDVI Crop Analysis Workflow","what":"Basic Enhanced NDVI Workflow","title":"Complete Workflows and Case Studies","text":"","code":"# Create sample multi-temporal data red_raster <- rast(nrows = 80, ncols = 80,                    xmin = -83.5, xmax = -83.0,                    ymin = 40.2, ymax = 40.7) values(red_raster) <- runif(6400, 0.1, 0.3)  nir_raster <- rast(nrows = 80, ncols = 80,                    xmin = -83.5, xmax = -83.0,                    ymin = 40.2, ymax = 40.7) values(nir_raster) <- runif(6400, 0.4, 0.8)  # Configure comprehensive NDVI analysis ndvi_config <- list(   analysis_type = \"ndvi_crop_analysis\",   input_data = list(red = red_raster, nir = nir_raster),   region_boundary = c(-83.5, 40.2, -83.0, 40.7),  # Bounding box   indices = c(\"NDVI\", \"EVI2\", \"SAVI\"),   quality_filter = TRUE,   temporal_smoothing = FALSE,   visualization_config = list(     create_maps = TRUE,     ndvi_classes = \"none\",     interactive = FALSE   ) )  # Execute comprehensive workflow ndvi_workflow_results <- run_comprehensive_geospatial_workflow(ndvi_config)  # Access results ndvi_data <- ndvi_workflow_results$results$vegetation_data ndvi_stats <- ndvi_workflow_results$results$statistics ndvi_maps <- ndvi_workflow_results$results$visualizations"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"enhanced-ndvi-with-crop-masking","dir":"Articles","previous_headings":"NDVI Crop Analysis Workflow","what":"Enhanced NDVI with Crop Masking","title":"Complete Workflows and Case Studies","text":"","code":"# Simulate CDL crop data cdl_raster <- rast(nrows = 80, ncols = 80,                    xmin = -83.5, xmax = -83.0,                    ymin = 40.2, ymax = 40.7) values(cdl_raster) <- sample(c(1, 5, 24, 36, 61), 6400, replace = TRUE)  # Corn, soybeans, wheat, alfalfa, fallow  # Enhanced configuration with crop masking enhanced_ndvi_config <- list(   analysis_type = \"ndvi_crop_analysis\",   input_data = list(red = red_raster, nir = nir_raster),   region_boundary = \"custom\",   cdl_data = cdl_raster,   crop_codes = c(1, 5),  # Corn and soybeans only   indices = c(\"NDVI\", \"SAVI\", \"DVI\"),   quality_filter = TRUE,   visualization_config = list(     create_maps = TRUE,     interactive = FALSE   ) )  # Run enhanced workflow enhanced_results <- run_comprehensive_geospatial_workflow(enhanced_ndvi_config)  # Compare masked vs unmasked results print(\"Original NDVI stats:\") print(global(ndvi_data, \"mean\", na.rm = TRUE)) print(\"Crop-masked NDVI stats:\") print(global(enhanced_results$results$vegetation_data, \"mean\", na.rm = TRUE))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"multi-index-vegetation-assessment","dir":"Articles","previous_headings":"Comprehensive Vegetation Analysis Workflow","what":"Multi-Index Vegetation Assessment","title":"Complete Workflows and Case Studies","text":"","code":"# Create multi-band spectral data spectral_stack <- c(   red_raster,                    # Band 1: Red   red_raster * 1.2,             # Band 2: Green (simulated)   red_raster * 0.8,             # Band 3: Blue (simulated)   nir_raster                     # Band 4: NIR ) names(spectral_stack) <- c(\"red\", \"green\", \"blue\", \"nir\")  # Configure comprehensive vegetation analysis vegetation_config <- list(   analysis_type = \"vegetation_comprehensive\",   input_data = spectral_stack,   indices = c(\"NDVI\", \"EVI2\", \"SAVI\", \"GNDVI\", \"DVI\", \"RVI\"),   crop_type = \"general\",   analysis_type_detail = \"comprehensive\",   region_boundary = c(-83.5, 40.2, -83.0, 40.7),   visualization_config = list(     create_maps = TRUE,     comparison_plots = TRUE   ) )  # Execute comprehensive vegetation workflow vegetation_results <- run_comprehensive_geospatial_workflow(vegetation_config)  # Access detailed results vegetation_indices <- vegetation_results$results$vegetation_analysis$vegetation_indices analysis_details <- vegetation_results$results$vegetation_analysis$analysis_results metadata <- vegetation_results$results$vegetation_analysis$metadata  print(\"Vegetation indices calculated:\") print(names(vegetation_indices)) print(\"Analysis metadata:\") print(metadata$indices_used)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"crop-specific-analysis-workflow","dir":"Articles","previous_headings":"Comprehensive Vegetation Analysis Workflow","what":"Crop-Specific Analysis Workflow","title":"Complete Workflows and Case Studies","text":"","code":"# Corn-specific analysis workflow corn_config <- list(   analysis_type = \"vegetation_comprehensive\",   input_data = spectral_stack,   crop_type = \"corn\",   analysis_type_detail = \"comprehensive\",   cdl_mask = cdl_raster == 1,  # Corn mask   indices = c(\"NDVI\", \"EVI2\", \"GNDVI\"),  # Corn-appropriate indices   visualization_config = list(create_maps = TRUE) )  corn_results <- run_comprehensive_geospatial_workflow(corn_config)  # Extract corn-specific insights if (\"stress_analysis\" %in% names(corn_results$results$vegetation_analysis$analysis_results)) {   stress_results <- corn_results$results$vegetation_analysis$analysis_results$stress_analysis   print(\"Corn stress analysis:\")   print(stress_results) }"},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"case-study-2-environmental-monitoring-and-water-quality-assessment","dir":"Articles","previous_headings":"","what":"Case Study 2: Environmental Monitoring and Water Quality Assessment","title":"Complete Workflows and Case Studies","text":"Objective: Monitor environmental conditions around water bodies, assess agricultural impacts water quality, identify priority areas conservation.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-1-environmental-monitoring-setup","dir":"Articles","previous_headings":"Case Study 2: Environmental Monitoring and Water Quality Assessment","what":"Step 1: Environmental Monitoring Setup","title":"Complete Workflows and Case Studies","text":"","code":"# Create environmental monitoring scenario monitoring_extent <- c(-82.8, 39.5, -81.8, 40.5)  # Water quality monitoring stations water_stations <- data.frame(   station_id = paste0(\"WQ_\", sprintf(\"%03d\", 1:18)),   lon = runif(18, monitoring_extent[1] + 0.1, monitoring_extent[3] - 0.1),   lat = runif(18, monitoring_extent[2] + 0.1, monitoring_extent[4] - 0.1),   nitrate_mg_l = runif(18, 0.5, 15.0),   phosphorus_mg_l = runif(18, 0.02, 2.5),   turbidity_ntu = runif(18, 1, 45),   dissolved_oxygen_mg_l = runif(18, 4, 12),   ph = runif(18, 6.8, 8.4),   sampling_date = sample(seq(as.Date(\"2024-05-01\"), as.Date(\"2024-09-30\"), by = \"day\"), 18),   watershed = sample(c(\"Upper_Creek\", \"Lower_Creek\", \"Tributary_A\"), 18, replace = TRUE) )  # Land use/land cover data lulc_raster <- terra::rast(nrows = 150, ncols = 150,                           xmin = monitoring_extent[1], xmax = monitoring_extent[3],                           ymin = monitoring_extent[2], ymax = monitoring_extent[4])  # Simulate realistic LULC pattern lulc_codes <- c(1, 5, 41, 42, 81, 82, 11, 21)  # Developed, Forest, Wetland, Agriculture lulc_probs <- c(0.15, 0.25, 0.05, 0.40, 0.08, 0.05, 0.01, 0.01) terra::values(lulc_raster) <- sample(lulc_codes, 22500, replace = TRUE, prob = lulc_probs) names(lulc_raster) <- \"LULC\"  print(\"Environmental monitoring setup completed\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-2-comprehensive-water-quality-analysis","dir":"Articles","previous_headings":"Case Study 2: Environmental Monitoring and Water Quality Assessment","what":"Step 2: Comprehensive Water Quality Analysis","title":"Complete Workflows and Case Studies","text":"","code":"# Comprehensive water quality assessment water_quality_results <- list()  # Analyze each water quality parameter parameters <- c(\"nitrate_mg_l\", \"phosphorus_mg_l\", \"turbidity_ntu\", \"dissolved_oxygen_mg_l\")  for (param in parameters) {         # Define parameter-specific thresholds   thresholds <- switch(param,     \"nitrate_mg_l\" = list(\"Low\" = c(0, 3), \"Moderate\" = c(3, 6),                           \"High\" = c(6, 10), \"Excessive\" = c(10, Inf)),     \"phosphorus_mg_l\" = list(\"Low\" = c(0, 0.1), \"Moderate\" = c(0.1, 0.3),                              \"High\" = c(0.3, 0.8), \"Excessive\" = c(0.8, Inf)),     \"turbidity_ntu\" = list(\"Clear\" = c(0, 5), \"Moderate\" = c(5, 15),                            \"Turbid\" = c(15, 30), \"Very_Turbid\" = c(30, Inf)),     \"dissolved_oxygen_mg_l\" = list(\"Critical\" = c(0, 4), \"Stressed\" = c(4, 6),                                    \"Good\" = c(6, 8), \"Excellent\" = c(8, Inf))   )      # Comprehensive analysis   water_quality_results[[param]] <- analyze_water_quality_comprehensive(     water_data = water_stations,     variable = param,     region_boundary = monitoring_extent,     thresholds = thresholds,     output_folder = paste0(\"water_quality_\", param)   ) }  print(\"Water quality analysis completed for all parameters\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-3-land-use-impact-assessment","dir":"Articles","previous_headings":"Case Study 2: Environmental Monitoring and Water Quality Assessment","what":"Step 3: Land Use Impact Assessment","title":"Complete Workflows and Case Studies","text":"","code":"# Assess land use impacts on water quality land_use_impact_analysis <- function(water_stations, lulc_raster, buffer_sizes = c(500, 1000, 2000)) {      results <- list()      for (buffer_size in buffer_sizes) {          # Extract land use composition around each station     buffered_lulc <- spatial_join_universal(       vector_data = water_stations,       raster_data = lulc_raster,       method = \"buffer\",       buffer_size = buffer_size,       summary_function = \"mode\",  # Most common land use       variable_names = paste0(\"dominant_lulc_\", buffer_size, \"m\")     )          # Calculate land use percentages     for (i in 1:nrow(water_stations)) {       station_point <- water_stations[i, ]       station_buffer <- sf::st_buffer(sf::st_as_sf(station_point,                                                    coords = c(\"lon\", \"lat\"),                                                    crs = 4326),                                       dist = buffer_size)              # Extract all LULC values within buffer       lulc_values <- terra::extract(lulc_raster, terra::vect(station_buffer))       lulc_table <- table(lulc_values)              # Calculate percentages       total_pixels <- sum(lulc_table)       agriculture_pct <- sum(lulc_table[names(lulc_table) %in% c(\"1\", \"5\")]) / total_pixels * 100       developed_pct <- sum(lulc_table[names(lulc_table) %in% c(\"21\", \"22\", \"23\", \"24\")]) / total_pixels * 100              water_stations[i, paste0(\"agriculture_pct_\", buffer_size, \"m\")] <- agriculture_pct       water_stations[i, paste0(\"developed_pct_\", buffer_size, \"m\")] <- developed_pct     }          results[[paste0(\"buffer_\", buffer_size, \"m\")]] <- water_stations   }      return(results) }  # Perform land use impact analysis land_use_impacts <- land_use_impact_analysis(water_stations, lulc_raster)  # Analyze correlations between land use and water quality correlation_analysis <- function(data) {      # Select relevant columns   water_quality_vars <- c(\"nitrate_mg_l\", \"phosphorus_mg_l\", \"turbidity_ntu\")   land_use_vars <- grep(\"agriculture_pct|developed_pct\", names(data), value = TRUE)      correlation_matrix <- cor(data[, c(water_quality_vars, land_use_vars)],                             use = \"complete.obs\")      return(correlation_matrix) }  # Analyze correlations for different buffer sizes correlations_500m <- correlation_analysis(land_use_impacts$buffer_500m) correlations_1000m <- correlation_analysis(land_use_impacts$buffer_1000m) correlations_2000m <- correlation_analysis(land_use_impacts$buffer_2000m)  print(\"Land use impact analysis completed\") print(\"Correlations at 1000m buffer:\") print(round(correlations_1000m[1:3, 4:7], 3))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-4-watershed-scale-assessment","dir":"Articles","previous_headings":"Case Study 2: Environmental Monitoring and Water Quality Assessment","what":"Step 4: Watershed-Scale Assessment","title":"Complete Workflows and Case Studies","text":"","code":"# Watershed-scale environmental assessment watershed_assessment <- function(water_stations, environmental_layers) {      # Group stations by watershed   watershed_summary <- list()      for (watershed in unique(water_stations$watershed)) {          watershed_stations <- water_stations[water_stations$watershed == watershed, ]          # Calculate watershed-level statistics     watershed_summary[[watershed]] <- list(       n_stations = nrow(watershed_stations),       mean_nitrate = mean(watershed_stations$nitrate_mg_l, na.rm = TRUE),       mean_phosphorus = mean(watershed_stations$phosphorus_mg_l, na.rm = TRUE),       mean_turbidity = mean(watershed_stations$turbidity_ntu, na.rm = TRUE),       stations_exceeding_nitrate_threshold = sum(watershed_stations$nitrate_mg_l > 6, na.rm = TRUE),       stations_exceeding_phosphorus_threshold = sum(watershed_stations$phosphorus_mg_l > 0.3, na.rm = TRUE)     )   }      return(watershed_summary) }  # Environmental layers for watershed analysis environmental_layers <- list(   vegetation = enhanced_ndvi,  # From previous case study   elevation = elevation,   lulc = lulc_raster )  watershed_results <- watershed_assessment(water_stations, environmental_layers)  print(\"Watershed Assessment Results:\") for (watershed in names(watershed_results)) {   cat(\"\\n\", watershed, \":\\n\")   result <- watershed_results[[watershed]]   cat(\"  Stations:\", result$n_stations, \"\\n\")   cat(\"  Mean Nitrate:\", round(result$mean_nitrate, 2), \"mg/L\\n\")   cat(\"  Mean Phosphorus:\", round(result$mean_phosphorus, 3), \"mg/L\\n\")   cat(\"  Stations exceeding nitrate threshold:\", result$stations_exceeding_nitrate_threshold, \"\\n\") }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-5-conservation-priority-mapping","dir":"Articles","previous_headings":"Case Study 2: Environmental Monitoring and Water Quality Assessment","what":"Step 5: Conservation Priority Mapping","title":"Complete Workflows and Case Studies","text":"","code":"# Identify priority areas for conservation based on water quality risk conservation_priority_analysis <- function(lulc_raster, water_quality_data, slope_data = NULL) {      # Create risk factors   risk_factors <- list()      # Agricultural intensity risk   ag_risk <- lulc_raster   ag_risk[lulc_raster != 1 & lulc_raster != 5] <- 0  # Non-ag areas = 0 risk   ag_risk[lulc_raster == 1 | lulc_raster == 5] <- 1  # Ag areas = 1 risk   names(ag_risk) <- \"agricultural_risk\"      # Water quality risk based on monitoring data   # Create risk surface using interpolation of water quality data   high_risk_stations <- water_quality_data[water_quality_data$nitrate_mg_l > 6 |                                            water_quality_data$phosphorus_mg_l > 0.3, ]      if (nrow(high_risk_stations) > 0) {     # Simple distance-based risk (closer to high-risk stations = higher risk)     risk_raster <- terra::rast(lulc_raster)     terra::values(risk_raster) <- 0          for (i in 1:nrow(high_risk_stations)) {       station_point <- c(high_risk_stations$lon[i], high_risk_stations$lat[i])       # Create simple distance decay function (this is simplified)       distances <- terra::distance(risk_raster, station_point)       station_risk <- 1 / (1 + distances / 5000)  # 5km decay distance       risk_raster <- risk_raster + station_risk     }          names(risk_raster) <- \"water_quality_risk\"   } else {     risk_raster <- ag_risk * 0  # No high-risk stations   }      # Combined priority score   combined_priority <- (ag_risk * 0.6) + (risk_raster * 0.4)   names(combined_priority) <- \"conservation_priority\"      # Classify priority levels   priority_values <- terra::values(combined_priority, mat = FALSE)   priority_breaks <- quantile(priority_values[priority_values > 0],                               c(0, 0.25, 0.5, 0.75, 1.0), na.rm = TRUE)      priority_classified <- terra::classify(combined_priority,                                         cbind(priority_breaks[-length(priority_breaks)],                                               priority_breaks[-1],                                               1:4))   names(priority_classified) <- \"priority_class\"      return(list(     priority_surface = combined_priority,     priority_classified = priority_classified,     high_risk_stations = high_risk_stations   )) }  # Generate conservation priorities conservation_priorities <- conservation_priority_analysis(lulc_raster, water_stations)  print(\"Conservation priority analysis completed\") print(paste(\"High-risk stations identified:\", nrow(conservation_priorities$high_risk_stations)))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"case-study-3-temporal-change-detection-and-monitoring","dir":"Articles","previous_headings":"","what":"Case Study 3: Temporal Change Detection and Monitoring","title":"Complete Workflows and Case Studies","text":"Objective: Analyze landscape changes time, detect deforestation/land use conversion, monitor ecosystem health trends.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-1-multi-temporal-data-preparation","dir":"Articles","previous_headings":"Case Study 3: Temporal Change Detection and Monitoring","what":"Step 1: Multi-Temporal Data Preparation","title":"Complete Workflows and Case Studies","text":"","code":"# Simulate multi-temporal satellite data (5-year time series) years <- 2020:2024 temporal_extent <- c(-83.0, 40.2, -82.0, 41.2)  # Create temporal NDVI series with realistic trends temporal_ndvi_series <- list() base_ndvi <- terra::rast(nrows = 120, ncols = 120,                         xmin = temporal_extent[1], xmax = temporal_extent[3],                         ymin = temporal_extent[2], ymax = temporal_extent[4])  # Create base NDVI pattern x_coords <- terra::xFromCell(base_ndvi, 1:terra::ncell(base_ndvi)) y_coords <- terra::yFromCell(base_ndvi, 1:terra::ncell(base_ndvi)) base_pattern <- 0.6 + 0.2 * sin((x_coords - min(x_coords)) * 6) +                  0.1 * cos((y_coords - min(y_coords)) * 4) +                 rnorm(terra::ncell(base_ndvi), 0, 0.1) terra::values(base_ndvi) <- pmax(0.1, pmin(0.9, base_pattern))  # Simulate temporal changes for (i in 1:length(years)) {   year <- years[i]      # Add temporal trends   # 1. General vegetation improvement (climate change effect)   climate_trend <- (i - 1) * 0.02      # 2. Localized disturbances (development, deforestation)   disturbance_effect <- 0   if (i >= 3) {  # Disturbance starts in year 3     # Simulate development in lower-left quadrant     disturbance_mask <- (x_coords < (min(x_coords) + (max(x_coords) - min(x_coords)) * 0.4)) &                        (y_coords < (min(y_coords) + (max(y_coords) - min(y_coords)) * 0.4))     disturbance_effect <- ifelse(disturbance_mask, -0.3, 0)   }      # 3. Inter-annual variability   annual_variation <- rnorm(terra::ncell(base_ndvi), 0, 0.05)      # Combine effects   year_ndvi <- base_ndvi + climate_trend + disturbance_effect + annual_variation   year_ndvi <- pmax(0.05, pmin(0.95, year_ndvi))   names(year_ndvi) <- paste0(\"NDVI_\", year)      temporal_ndvi_series[[as.character(year)]] <- year_ndvi }  print(\"Multi-temporal data series created for years:\", paste(years, collapse = \", \"))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-2-comprehensive-temporal-analysis","dir":"Articles","previous_headings":"Case Study 3: Temporal Change Detection and Monitoring","what":"Step 2: Comprehensive Temporal Analysis","title":"Complete Workflows and Case Studies","text":"","code":"# Comprehensive temporal change analysis temporal_analysis_results <- analyze_temporal_changes(   data_list = temporal_ndvi_series,   dates = as.character(years),   region_boundary = temporal_extent,   analysis_type = \"trend\",   output_folder = \"temporal_analysis_results\" )  # Additional change detection analysis change_detection_results <- analyze_temporal_changes(   data_list = temporal_ndvi_series,   dates = as.character(years),   analysis_type = \"change_detection\" )  # Statistical analysis statistics_results <- analyze_temporal_changes(   data_list = temporal_ndvi_series,   dates = as.character(years),   analysis_type = \"statistics\" )  print(\"Temporal analysis completed:\") print(\"Trend analysis:\", !is.null(temporal_analysis_results$trend_rasters)) print(\"Change detection:\", length(change_detection_results$change_rasters), \"change maps\") print(\"Statistical summary:\", length(statistics_results$statistics_rasters), \"statistic layers\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-3-change-hotspot-identification","dir":"Articles","previous_headings":"Case Study 3: Temporal Change Detection and Monitoring","what":"Step 3: Change Hotspot Identification","title":"Complete Workflows and Case Studies","text":"","code":"# Identify areas of significant change identify_change_hotspots <- function(trend_results, change_results, threshold_slope = 0.02) {      # Extract slope (trend) raster   slope_raster <- trend_results$trend_rasters$slope   r_squared_raster <- trend_results$trend_rasters$r_squared      # Identify significant trends   significant_trends <- abs(slope_raster) > threshold_slope & r_squared_raster > 0.5      # Classify change types   change_types <- slope_raster   change_types[slope_raster > threshold_slope & significant_trends] <- 2   # Increasing   change_types[slope_raster < -threshold_slope & significant_trends] <- 1  # Decreasing   change_types[!significant_trends] <- 0  # No significant change      names(change_types) <- \"change_type\"      # Calculate change statistics   n_total <- terra::ncell(change_types)   n_increasing <- sum(terra::values(change_types) == 2, na.rm = TRUE)   n_decreasing <- sum(terra::values(change_types) == 1, na.rm = TRUE)   n_stable <- sum(terra::values(change_types) == 0, na.rm = TRUE)      change_stats <- list(     total_pixels = n_total,     increasing_pixels = n_increasing,     decreasing_pixels = n_decreasing,     stable_pixels = n_stable,     increasing_percent = round(n_increasing / n_total * 100, 1),     decreasing_percent = round(n_decreasing / n_total * 100, 1)   )      return(list(     change_types = change_types,     significant_trends = significant_trends,     change_statistics = change_stats   )) }  # Identify hotspots change_hotspots <- identify_change_hotspots(temporal_analysis_results, change_detection_results)  print(\"Change Hotspot Analysis:\") print(paste(\"Pixels with increasing vegetation:\", change_hotspots$change_statistics$increasing_pixels)) print(paste(\"Pixels with decreasing vegetation:\", change_hotspots$change_statistics$decreasing_pixels)) print(paste(\"Percentage of area with significant decline:\",             change_hotspots$change_statistics$decreasing_percent, \"%\"))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"step-4-integrated-multi-case-study-synthesis","dir":"Articles","previous_headings":"Case Study 3: Temporal Change Detection and Monitoring","what":"Step 4: Integrated Multi-Case Study Synthesis","title":"Complete Workflows and Case Studies","text":"","code":"# Synthesize results from all case studies comprehensive_synthesis <- function(agricultural_results, environmental_results, temporal_results) {      synthesis_report <- list()      # 1. Agricultural insights   synthesis_report$agricultural_summary <- list(     total_fields_analyzed = nrow(field_boundaries),     management_zones_created = management_zones$optimal_zones,     average_ndvi = round(mean(terra::values(enhanced_ndvi), na.rm = TRUE), 3),     precision_ag_benefits = \"Variable-rate applications recommended for all zones\"   )      # 2. Environmental insights     synthesis_report$environmental_summary <- list(     water_stations_monitored = nrow(water_stations),     parameters_analyzed = length(parameters),     watersheds_assessed = length(unique(water_stations$watershed)),     high_risk_areas_identified = nrow(conservation_priorities$high_risk_stations)   )      # 3. Temporal insights   synthesis_report$temporal_summary <- list(     years_analyzed = length(years),     significant_change_areas = change_hotspots$change_statistics$decreasing_percent,     trend_analysis_completed = TRUE,     monitoring_recommendations = \"Continue monitoring areas with significant decline\"   )      # 4. Integrated recommendations   synthesis_report$integrated_recommendations <- list(     precision_agriculture = \"Implement zone-based management for optimal yields\",     water_quality = \"Focus conservation efforts on high-risk watersheds\",     land_change_monitoring = \"Establish permanent monitoring plots in change hotspots\",     data_integration = \"Continue multi-source data integration for comprehensive assessment\"   )      return(synthesis_report) }  # Generate comprehensive synthesis final_synthesis <- comprehensive_synthesis(   agricultural_results,    water_quality_results,    temporal_analysis_results )  print(\"COMPREHENSIVE ANALYSIS SYNTHESIS\") print(\"=====================================\") for (section in names(final_synthesis)) {   cat(\"\\n\", toupper(gsub(\"_\", \" \", section)), \":\\n\")   for (item in names(final_synthesis[[section]])) {     cat(\"  \", gsub(\"_\", \" \", item), \":\", final_synthesis[[section]][[item]], \"\\n\")   } }"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"workflow-optimization","dir":"Articles","previous_headings":"Advanced Workflow Tips and Best Practices","what":"1. Workflow Optimization","title":"Complete Workflows and Case Studies","text":"","code":"# Performance optimization for large-scale analyses optimization_tips <- function() {   cat(\"WORKFLOW OPTIMIZATION GUIDE\\n\")   cat(\"===========================\\n\\n\")      cat(\"Data Management:\\n\")   cat(\"  - Process data in chunks for large datasets\\n\")   cat(\"  - Use appropriate raster resolutions for analysis scale\\n\")   cat(\"  - Implement data caching for repeated analyses\\n\")   cat(\"  - Clean up intermediate files regularly\\n\\n\")      cat(\"Memory Management:\\n\")   cat(\"  - Monitor memory usage with gc() and object.size()\\n\")   cat(\"  - Use terra's out-of-memory processing for large rasters\\n\")   cat(\"  - Remove unused objects with rm()\\n\")   cat(\"  - Consider parallel processing for independent operations\\n\\n\")      cat(\"Quality Control:\\n\")   cat(\"  - Validate inputs before processing\\n\")   cat(\"  - Implement checkpoints in long workflows\\n\")   cat(\"  - Log processing steps and parameters\\n\")   cat(\"  - Create reproducible analysis scripts\\n\") }  optimization_tips()"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"reproducible-research-framework","dir":"Articles","previous_headings":"Advanced Workflow Tips and Best Practices","what":"2. Reproducible Research Framework","title":"Complete Workflows and Case Studies","text":"","code":"# Framework for reproducible geospatial research create_reproducible_workflow <- function(project_name, analysis_config) {      # Create project structure   project_dirs <- c(     file.path(project_name, \"data\", \"raw\"),     file.path(project_name, \"data\", \"processed\"),     file.path(project_name, \"scripts\"),     file.path(project_name, \"results\", \"figures\"),     file.path(project_name, \"results\", \"tables\"),     file.path(project_name, \"documentation\")   )      for (dir in project_dirs) {     if (!dir.exists(dir)) dir.create(dir, recursive = TRUE)   }      # Create analysis log   analysis_log <- list(     project_name = project_name,     creation_date = Sys.time(),     geospatialsuite_version = \"0.1.0\",     analysis_config = analysis_config,     r_session_info = sessionInfo()   )      # Save analysis configuration   saveRDS(analysis_log, file.path(project_name, \"analysis_log.rds\"))      cat(\"Reproducible workflow structure created for:\", project_name, \"\\n\")   cat(\"Project directories:\", length(project_dirs), \"created\\n\")   cat(\"Analysis log saved\\n\")      return(project_dirs) }  # Example usage workflow_config <- list(   analysis_types = c(\"agricultural\", \"environmental\", \"temporal\"),   study_region = \"Ohio Agricultural Region\",   temporal_extent = \"2020-2024\",   spatial_resolution = \"30m\",   coordinate_system = \"WGS84\" )  project_structure <- create_reproducible_workflow(\"integrated_geospatial_analysis\", workflow_config)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Complete Workflows and Case Studies","text":"comprehensive workflow vignette demonstrates:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"complete-case-studies","dir":"Articles","previous_headings":"Summary","what":"Complete Case Studies:","title":"Complete Workflows and Case Studies","text":"Precision Agriculture Analysis - Field-scale management zones variable-rate recommendations Environmental Monitoring - Water quality assessment land use impact analysis Temporal Change Detection - Multi-year trend analysis change hotspot identification","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"key-workflow-components","dir":"Articles","previous_headings":"Summary","what":"Key Workflow Components:","title":"Complete Workflows and Case Studies","text":"Data Integration: Multi-source data fusion analysis Spatial Analysis: Universal spatial joins multi-scale extraction Temporal Analysis: Change detection trend analysis Visualization: Professional maps comprehensive dashboards Reporting: Automated report generation synthesis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"best-practices-demonstrated","dir":"Articles","previous_headings":"Summary","what":"Best Practices Demonstrated:","title":"Complete Workflows and Case Studies","text":"Systematic approach complex geospatial problems Quality control validation step Reproducible workflows documented parameters Multi-scale analysis field landscape levels Integrated assessment combining multiple data types","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"real-world-applications","dir":"Articles","previous_headings":"Summary","what":"Real-World Applications:","title":"Complete Workflows and Case Studies","text":"Agricultural consultancy precision farming services Environmental monitoring regulatory compliance Land management conservation planning Research development geospatial sciences Policy development impact assessment","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"scalability","dir":"Articles","previous_headings":"Summary","what":"Scalability:","title":"Complete Workflows and Case Studies","text":"Methods work field scale (hectares) regional scale (thousands kmÃ‚Â²) Temporal flexibility single time points multi-decade series Universal applicability - adapt geographic region crop type Modular design - use individual components complete workflows workflows geospatialsuite provide complete toolkit professional geospatial analysis, data preparation final reporting recommendations!","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/articles/workflows-case-studies.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Complete Workflows and Case Studies","text":"work developed geospatialsuite team contributions : Olatunde D. Akanbi, Vibha Mandayam, Yinghui Wu, Jeffrey Yarus, Erika . Barcelos, Roger H. French.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Olatunde D. Akanbi. Author, maintainer, copyright holder. Vibha Mandayam. Author. Yinghui Wu. Author. Jeffrey Yarus. Author. Erika . Barcelos. Author, copyright holder. Roger H. French. Author, copyright holder.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Akanbi O, Mandayam V, Wu Y, Yarus J, Barcelos E, French R (2025). geospatialsuite: Comprehensive Geospatiotemporal Analysis Multimodal Integration Toolkit. R package version 0.1.1, https://github.com/cwru-sdle/geospatialsuite. Akanbi O, Mandayam V, Wu Y, Yarus J, Barcelos E, French R (2025). “geospatialsuite: Comprehensive Geospatiotemporal Analysis Multimodal Integration Toolkit R.” Journal Open Source Software. review, https://joss.theoj.org/papers/8147cac49f5caae89b8bd2b0d91c56fe. Akanbi O, Bhuvanagiri D, Barcelos E, Nihar , Gonzalez Hernandez B, Yarus J, French R (2024). “Integrating multiscale geospatial analysis monitoring crop growth, nutrient distribution, hydrological dynamics large-scale agricultural systems.” Journal Geovisualization Spatial Analysis, 8(1), 9. doi:10.1007/s41651-023-00164-y.","code":"@Manual{,   title = {geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit},   author = {Olatunde D. Akanbi and Vibha Mandayam and Yinghui Wu and Jeffrey Yarus and Erika I. Barcelos and Roger H. French},   year = {2025},   note = {R package version 0.1.1},   url = {https://github.com/cwru-sdle/geospatialsuite}, } @Article{,   title = {geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit for R},   author = {Olatunde D. Akanbi and Vibha Mandayam and Yinghui Wu and Jeffrey Yarus and Erika I. Barcelos and Roger H. French},   journal = {Journal of Open Source Software},   year = {2025},   note = {Under review},   url = {https://joss.theoj.org/papers/8147cac49f5caae89b8bd2b0d91c56fe}, } @Article{akanbi2024integrating,   title = {Integrating multiscale geospatial analysis for monitoring crop growth, nutrient distribution, and hydrological dynamics in large-scale agricultural systems},   author = {Olatunde D. Akanbi and Deepa C. Bhuvanagiri and Erika I. Barcelos and Arafath Nihar and Brian {Gonzalez Hernandez} and Jeffrey M. Yarus and Roger H. French},   journal = {Journal of Geovisualization and Spatial Analysis},   year = {2024},   volume = {8},   number = {1},   pages = {9},   publisher = {Springer},   doi = {10.1007/s41651-023-00164-y}, }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"geospatialsuite-earth_africa","dir":"","previous_headings":"","what":"geospatialsuite","title":"geospatialsuite","text":"Comprehensive Geospatiotemporal Analysis Multimodal Integration Toolkit R geospatialsuite powerful R package geospatial analysis featuring 60+ vegetation indices, universal spatial analysis, auto-geocoding without coordinates, efficient raster visualization, comprehensive workflows agricultural research, environmental monitoring, remote sensing applications.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"clipboard-table-of-contents","dir":"","previous_headings":"","what":"📋 Table of Contents","title":"geospatialsuite","text":"Key Features Quick Links Installation Quick Start Auto-Geocoding Documentation Real-World Examples Makes geospatialsuite Special Supported Vegetation Indices Performance System Requirements Citation Contact License Acknowledgments","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"link-quick-links","dir":"","previous_headings":"","what":"🔗 Quick Links","title":"geospatialsuite","text":"CRAN: https://cran.r-project.org/package=geospatialsuite Documentation: https://exelegch.github.io/geospatialsuite-docs/ GitHub: https://github.com/cwru-sdle/geospatialsuite Bug Reports: https://github.com/cwru-sdle/geospatialsuite/issues","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"world_map-auto-geocoding-without-coordinates-star-new","dir":"","previous_headings":"✨ Key Features","what":"🗺️ Auto-Geocoding Without Coordinates ⭐ NEW!","title":"geospatialsuite","text":"Work data lat/lon! Automatically geocode using geographic identifiers States: Full names abbreviations (e.g., “Ohio”, “OH”) Counties: County names without state FIPS codes: 5-digit Federal codes HUC codes: Watershed codes (handles HUC_8, HUC-8, huc8, etc.) ZIP codes: US postal codes Cities: City names (works best state column) Flexible column naming: Handles spaces, hyphens, underscores, mixed case","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"seedling-advanced-vegetation-analysis","dir":"","previous_headings":"✨ Key Features","what":"🌱 Advanced Vegetation Analysis","title":"geospatialsuite","text":"60+ vegetation indices including NDVI, EVI, SAVI, PRI, SIPI, NDRE, MTCI Automatic band detection Landsat, Sentinel, satellite imagery Crop-specific analysis corn, soybeans, wheat, cotton, rice Stress detection yield assessment workflows","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"world_map-universal-spatial-analysis","dir":"","previous_headings":"✨ Key Features","what":"🗺️ Universal Spatial Analysis","title":"geospatialsuite","text":"Works data combination - points, polygons, rasters Automatic coordinate system handling spatial validation Multiple extraction methods - simple, buffer, bilinear, nearest neighbor Multi-dataset integration comprehensive environmental analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"bar_chart-efficient-visualization","dir":"","previous_headings":"✨ Key Features","what":"📊 Efficient Visualization","title":"geospatialsuite","text":"data frame conversion large rasters (uses tidyterra, RStoolbox) Interactive maps leaflet integration Publication-quality graphics automatic method selection RGB composites advanced stretching algorithms","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"arrows_counterclockwise-comprehensive-workflows","dir":"","previous_headings":"✨ Key Features","what":"🔄 Comprehensive Workflows","title":"geospatialsuite","text":"End--end analysis pipelines common geospatial tasks NDVI crop analysis quality filtering temporal smoothing Water quality assessment spatial integration Terrain temporal analysis workflows","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"zap-performance-features","dir":"","previous_headings":"✨ Key Features","what":"⚡ Performance Features","title":"geospatialsuite","text":"Smart fallback systems optional packages unavailable Parallel processing support multiple indices Efficient memory usage optimized large datasets Robust error handling informative messages","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"from-cran-recommended","dir":"","previous_headings":"📦 Installation","what":"From CRAN (Recommended)","title":"geospatialsuite","text":"","code":"# Install the stable version from CRAN install.packages(\"geospatialsuite\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"development-version-from-github","dir":"","previous_headings":"📦 Installation","what":"Development Version from GitHub","title":"geospatialsuite","text":"","code":"# Install development version with latest features (includes auto-geocoding!) # install.packages(\"devtools\") devtools::install_github(\"cwru-sdle/geospatialsuite\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"install-recommended-packages-for-best-performance","dir":"","previous_headings":"📦 Installation","what":"Install Recommended Packages for Best Performance","title":"geospatialsuite","text":"","code":"# Enhanced visualization and functionality install.packages(c(\"tidyterra\", \"RStoolbox\", \"leaflet\", \"patchwork\"))  # For auto-geocoding features (optional) install.packages(c(\"tigris\", \"nhdplusTools\", \"zipcodeR\", \"tidygeocoder\"))"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"load-package-and-test-installation","dir":"","previous_headings":"🚀 Quick Start","what":"Load Package and Test Installation","title":"geospatialsuite","text":"","code":"library(geospatialsuite)  # Test your installation test_geospatialsuite_package_simple()  # Check function availability test_function_availability(verbose = TRUE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"basic-usage-examples","dir":"","previous_headings":"🚀 Quick Start","what":"Basic Usage Examples","title":"geospatialsuite","text":"","code":"# Load built-in sample data red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") blue <- load_sample_data(\"sample_blue.rds\")  # 1. One-line mapping (auto-detects everything!) quick_map(\"mydata.shp\")  # 2. Universal spatial join (most common operation) result <- universal_spatial_join(   source_data = \"study_sites.csv\",   target_data = \"elevation.tif\",   method = \"extract\" )  # 3. Calculate vegetation indices with sample data ndvi <- calculate_vegetation_index(   red = red,    nir = nir,    index_type = \"NDVI\",   verbose = TRUE )  # 4. Enhanced NDVI with quality filtering enhanced_ndvi <- calculate_ndvi_enhanced(   red = red,   nir = nir,   quality_filter = TRUE,   mask_invalid = TRUE )  # 5. Multiple indices at once indices <- calculate_multiple_indices(   red = red,    nir = nir,    blue = blue,   indices = c(\"NDVI\", \"EVI\", \"SAVI\"),   output_stack = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"world_map-auto-geocoding-without-coordinates","dir":"","previous_headings":"","what":"🗺️ Auto-Geocoding Without Coordinates","title":"geospatialsuite","text":"NEW! Work data doesn’t latitude/longitude coordinates. geospatialsuite automatically detects geocodes geographic identifiers: Supported geographic entities: - ✅ States (names abbreviations) - ✅ Counties - ✅ FIPS codes - ✅ HUC watershed codes (HUC-8, HUC_8, huc8, etc.) - ✅ ZIP codes - ✅ City names Column name flexibility: package handles naming convention - HUC_8, HUC-8, huc8, State, STATE, state_name, etc.","code":"# Works with state names or abbreviations state_data <- data.frame(   state = c(\"Ohio\", \"PA\", \"Michigan\"),   population = c(11.8, 13.0, 10.1) ) spatial_data <- auto_geocode_data(state_data) quick_map(spatial_data, variable = \"population\")  # Works with FIPS codes county_data <- data.frame(   fips = c(\"39049\", \"39035\", \"39113\"),   unemployment = c(4.2, 5.1, 4.8) ) county_sf <- auto_geocode_data(county_data)  # Works with HUC codes (any format!) watershed_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\"),  # or HUC-8, huc8, Huc 8, etc.   water_quality = c(72, 65) ) huc_sf <- auto_geocode_data(watershed_data)  # Works with ZIP codes zip_data <- data.frame(   zip = c(\"43215\", \"44113\", \"45202\"),   median_income = c(58000, 45000, 72000) ) zip_sf <- auto_geocode_data(zip_data)  # Preview what will be detected before geocoding preview_geocoding(my_data)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"vignettes-and-tutorials","dir":"","previous_headings":"📖 Documentation","what":"Vignettes and Tutorials","title":"geospatialsuite","text":"Getting Started - Package overview quick start examples Analyze Crop Vegetation - Using analyze_crop_vegetation() geospatialsuite ⭐ NEW! Universal Spatial Analysis - Core spatial join capabilities Spatial Integration - Robust multi-modal spatial integration capabilities Vegetation Analysis - 60+ vegetation indices crop analysis Agricultural Analysis - Efficient domain-specific analysis Comprehensive Workflows - End--end analysis pipelines","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"function-reference","dir":"","previous_headings":"📖 Documentation","what":"Function Reference","title":"geospatialsuite","text":"","code":"# View all available functions help(package = \"geospatialsuite\")  # New auto-geocoding functions ?auto_geocode_data ?preview_geocoding  # Test function availability test_function_availability()  # Run basic package tests test_geospatialsuite_package_simple()  # Run minimal functionality test test_package_minimal(verbose = TRUE)"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"census-data-analysis-no-coordinates-needed","dir":"","previous_headings":"🎯 Real-World Examples","what":"Census Data Analysis (No Coordinates Needed!)","title":"geospatialsuite","text":"","code":"# Load census data with just state names - no coordinates! census_data <- data.frame(   state = c(\"California\", \"Texas\", \"Florida\", \"New York\"),   population_millions = c(39.5, 29.1, 22.2, 20.2),   median_income = c(75000, 64000, 59000, 72000),   unemployment_rate = c(4.8, 4.1, 3.2, 4.3) )  # Auto-geocode and visualize census_sf <- auto_geocode_data(census_data, verbose = TRUE) quick_map(census_sf, variable = \"median_income\",            title = \"Median Household Income by State\")  # Combine with satellite data ndvi_raster <- terra::rast(\"vegetation_data.tif\") census_with_ndvi <- universal_spatial_join(   source_data = census_sf,   target_data = ndvi_raster,   method = \"extract\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"watershed-analysis-with-huc-codes","dir":"","previous_headings":"🎯 Real-World Examples","what":"Watershed Analysis with HUC Codes","title":"geospatialsuite","text":"","code":"# Water quality data with HUC-8 codes (no coordinates!) watershed_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\", \"04110002\", \"05120201\"),   basin_name = c(\"Great Miami\", \"Mill Creek-Cincinnati\",                   \"Middle Ohio\", \"Upper Wabash\"),   nitrogen_mg_l = c(2.3, 3.1, 1.8, 2.7),   phosphorus_mg_l = c(0.08, 0.12, 0.06, 0.09) )  # Auto-geocode watersheds huc_sf <- auto_geocode_data(watershed_data, verbose = TRUE)  # Comprehensive water quality analysis water_results <- analyze_water_quality_comprehensive(   water_data = huc_sf,   variable = \"nitrogen_mg_l\",   thresholds = list(     Normal = c(0, 2),      Elevated = c(2, 5),     High = c(5, Inf)   ) )  quick_map(huc_sf, variable = \"nitrogen_mg_l\",           title = \"Nitrogen Levels by Watershed\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"agricultural-monitoring","dir":"","previous_headings":"🎯 Real-World Examples","what":"Agricultural Monitoring","title":"geospatialsuite","text":"","code":"# Comprehensive crop analysis workflow crop_analysis <- run_enhanced_ndvi_crop_workflow(   config = list(     red_data = \"satellite/red_bands/\",     nir_data = \"satellite/nir_bands/\",      region_boundary = \"Iowa\",     crop_codes = get_comprehensive_cdl_codes(\"soybeans\"),     quality_filter = TRUE,     temporal_smoothing = TRUE,     visualization_config = list(       interactive = TRUE,       create_maps = TRUE     )   ),   output_folder = \"results/\" )  # Get crop codes for analysis corn_codes <- get_comprehensive_cdl_codes(\"corn\") grain_codes <- get_comprehensive_cdl_codes(\"grains\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"county-level-environmental-analysis","dir":"","previous_headings":"🎯 Real-World Examples","what":"County-Level Environmental Analysis","title":"geospatialsuite","text":"","code":"# County data with FIPS codes (no coordinates needed!) county_data <- data.frame(   fips = c(\"39049\", \"39035\", \"39113\", \"39061\"),   county_name = c(\"Franklin\", \"Cuyahoga\", \"Montgomery\", \"Hamilton\"),   air_quality_index = c(45, 52, 48, 41),   tree_canopy_pct = c(28, 35, 32, 40) )  # Auto-geocode counties county_sf <- auto_geocode_data(county_data, verbose = TRUE)  # Multi-dataset environmental integration ndvi_data <- terra::rast(\"vegetation.tif\") temp_data <- terra::rast(\"temperature.tif\")  # Extract satellite data for each county county_analysis <- universal_spatial_join(   source_data = county_sf,   target_data = ndvi_data,   method = \"extract\",   summary_function = \"mean\" )  # Add temperature data county_complete <- universal_spatial_join(   source_data = county_analysis,   target_data = temp_data,   method = \"extract\" )  # Visualize quick_map(county_complete, variable = \"extracted_mean_ndvi\",           title = \"Vegetation Health by County\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"remote-sensing-applications","dir":"","previous_headings":"🎯 Real-World Examples","what":"Remote Sensing Applications","title":"geospatialsuite","text":"","code":"# Run comprehensive geospatial workflow config <- list(   analysis_type = \"vegetation_comprehensive\",   input_data = satellite_data,   region_boundary = \"study_area.shp\",   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"GNDVI\"),   output_folder = \"analysis_results/\" )  results <- run_comprehensive_geospatial_workflow(config)  # Quick visualization of results quick_map(results$vegetation_data, title = \"Vegetation Analysis Results\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_1-auto-geocoding-revolution-star-new","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"1. Auto-Geocoding Revolution ⭐ NEW!","title":"geospatialsuite","text":"manual coordinate lookups! Work directly : - State names, county names, FIPS codes - HUC watershed codes (format) - ZIP codes, city names - Flexible column naming (HUC_8, HUC-8, huc8 work!)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_2-universal-design","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"2. Universal Design","title":"geospatialsuite","text":"Works spatial data combination - need learn different functions different data types. universal_spatial_join() function automatically handles: - Vector--vector joins - Vector--raster extractions - Raster--raster operations - Multi-dataset integrations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_3-intelligent-automation","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"3. Intelligent Automation","title":"geospatialsuite","text":"Auto-detects coordinate columns (lat/lng, x/y, longitude/latitude) Auto-geocodes geographic entities (states, counties, FIPS, HUCs, ZIPs) Automatically identifies satellite bands across Landsat, Sentinel-2, MODIS Smart coordinate system transformations validation Optimal method selection performance accuracy","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_4-efficient-visualization","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"4. Efficient Visualization","title":"geospatialsuite","text":"Terra-based plotting using reliable terra::plot() terra::plotRGB() Quick mapping quick_map() function instant visualization Multiple color schemes: viridis, plasma, ndvi, terrain, categorical Interactive mapping automatic leaflet integration available","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_5-comprehensive-coverage","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"5. Comprehensive Coverage","title":"geospatialsuite","text":"60+ vegetation indices including latest research developments Complete spatial operations universal_spatial_join() Robust error handling informative messages recovery strategies Cross-platform compatibility (Windows, macOS, Linux)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"id_6-research-ready","dir":"","previous_headings":"🌟 What Makes geospatialsuite Special","what":"6. Research-Ready","title":"geospatialsuite","text":"Designed specifically reproducible research : - Comprehensive testing suite (test_geospatialsuite_package_simple()) - Function availability checking (test_function_availability()) - Quality control filtering options - Integration modern R spatial ecosystem","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"zap-performance","dir":"","previous_headings":"","what":"⚡ Performance","title":"geospatialsuite","text":"geospatialsuite optimized : Large rasters: Efficient memory usage terra backend Multiple datasets: Parallel processing capabilities vegetation indices Cross-platform: Tested Windows, macOS, Linux geographic region: Universal coordinate system handling Big data: Streaming chunked processing large satellite imagery Interactive analysis: Fast visualization without data conversion overhead Geocoding: Efficient caching batch processing large datasets realistic satellite imagery (5K×5K pixels): 7.6× memory efficient ggplot2 (75 MB vs 572 MB) 4.2× faster execution (684 ms vs 2,897 ms) See vignette(\"performance-benchmark\") complete benchmarks reproducible code.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"performance-tips","dir":"","previous_headings":"⚡ Performance","what":"Performance Tips","title":"geospatialsuite","text":"","code":"# Test basic functionality test_package_minimal(verbose = TRUE)  # Check which functions are available test_function_availability(verbose = TRUE)  # Preview geocoding before processing large datasets preview_geocoding(my_data)  # Use efficient spatial operations result <- universal_spatial_join(   source_data = \"points.csv\",   target_data = \"large_raster.tif\",   method = \"extract\",   chunk_size = 1000000  # Process in chunks for large data )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"bar_chart-supported-vegetation-indices","dir":"","previous_headings":"","what":"📊 Supported Vegetation Indices","title":"geospatialsuite","text":"Total: 60+ indices automatic band detection across satellite platforms","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"required-dependencies","dir":"","previous_headings":"🛠 System Requirements","what":"Required Dependencies","title":"geospatialsuite","text":"","code":"# Core dependencies (automatically installed with geospatialsuite) terra (>= 1.6-17) sf (>= 1.0-0) dplyr (>= 1.0.0) ggplot2 (>= 3.3.0) magrittr viridis"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"recommended-packages-for-enhanced-functionality","dir":"","previous_headings":"🛠 System Requirements","what":"Recommended Packages for Enhanced Functionality","title":"geospatialsuite","text":"","code":"# Install these for optimal performance and features install.packages(c(   \"tidyterra\",    # Efficient raster visualization with ggplot2   \"RStoolbox\",    # Remote sensing tools and visualization   \"leaflet\",      # Interactive web mapping   \"patchwork\",    # Multi-panel figures and layouts   \"gganimate\",    # Animated visualizations   \"rnaturalearth\", # Natural Earth country boundaries   \"tigris\"        # US administrative boundaries ))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"optional-packages-for-auto-geocoding","dir":"","previous_headings":"🛠 System Requirements","what":"Optional Packages for Auto-Geocoding","title":"geospatialsuite","text":"","code":"# Install these for geocoding features (NEW!) install.packages(c(   \"tigris\",        # US Census boundaries (states, counties, FIPS)   \"nhdplusTools\",  # HUC watershed boundaries   \"zipcodeR\",      # ZIP code centroids   \"tidygeocoder\"   # City name geocoding ))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"additional-optional-packages","dir":"","previous_headings":"🛠 System Requirements","what":"Additional Optional Packages","title":"geospatialsuite","text":"","code":"# Additional packages for specialized functions install.packages(c(   \"htmlwidgets\", # Interactive widgets   \"mice\",        # Multiple imputation   \"RColorBrewer\", # Color palettes   \"parallel\"     # Parallel processing ))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"minimum-r-version","dir":"","previous_headings":"🛠 System Requirements","what":"Minimum R Version","title":"geospatialsuite","text":"R >= 3.5.0 (recommended: R >= 4.0.0)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"page_facing_up-citation","dir":"","previous_headings":"","what":"📄 Citation","title":"geospatialsuite","text":"use geospatialsuite research, please cite:","code":"citation(\"geospatialsuite\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"e-mail-contact","dir":"","previous_headings":"","what":"📧 Contact","title":"geospatialsuite","text":"Maintainer: Olatunde D. Akanbi (olatunde.akanbi@case.edu) Senior Maintainer: Roger H. French (roger.french@case.edu) Lead Developer: Olatunde D. Akanbi (olatunde.akanbi@case.edu) Issues & Bug Reports: https://github.com/cwru-sdle/geospatialsuite/issues","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"handshake-contributing","dir":"","previous_headings":"","what":"🤝 Contributing","title":"geospatialsuite","text":"welcome contributions! Please see Contributing Guidelines details : Reporting bugs issues Suggesting enhancements Submitting pull requests Code style testing requirements","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"code-of-conduct","dir":"","previous_headings":"🤝 Contributing","what":"Code of Conduct","title":"geospatialsuite","text":"project adheres Code Conduct. participating, expected uphold code.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"getting-help","dir":"","previous_headings":"🤝 Contributing","what":"Getting Help","title":"geospatialsuite","text":"📖 Documentation: Check vignettes 🐛 Bug Reports: GitHub Issues 💬 Questions: Contact maintainers open discussion issue 📧 Email: olatunde.akanbi@case.edu","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"pencil-license","dir":"","previous_headings":"","what":"📝 License","title":"geospatialsuite","text":"MIT License - see LICENSE file details.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"pray-acknowledgments","dir":"","previous_headings":"","what":"🙏 Acknowledgments","title":"geospatialsuite","text":"Development Institution: Solar Durability Lifetime Extension (SDLE) Center, Case Western Reserve University, Cleveland, Ohio, U.S.. Built : excellent work terra, sf, ggplot2, broader R spatial community Funding: material based upon financial support National Science Foundation, EEC Division Engineering Education Centers, NSF Engineering Research Center Advancing Sustainable Distributed Fertilizer production (CASFER), NSF 20-553 Gen-4 Engineering Research Centers award 2133576.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"contributing-institutions","dir":"","previous_headings":"🙏 Acknowledgments","what":"Contributing Institutions","title":"geospatialsuite","text":"Case Western Reserve University NSF Engineering Research Center Advancing Sustainable Distributed Fertilizer production (CASFER)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/index.html","id":"special-thanks","dir":"","previous_headings":"🙏 Acknowledgments","what":"Special Thanks","title":"geospatialsuite","text":"R Core Team CRAN maintainers terra package developers (Robert J. Hijmans et al.) sf package developers (Edzer Pebesma et al.) Remote sensing geospatial R community geocoding package developers (tigris, nhdplusTools, zipcodeR, tidygeocoder) Ready get started? Install CRAN install.packages(\"geospatialsuite\") get development version auto-geocoding GitHub! Check Getting Started vignette","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_boundary_overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Add boundary overlay to existing plot — add_boundary_overlay","title":"Add boundary overlay to existing plot — add_boundary_overlay","text":"Add boundary overlay existing plot","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_boundary_overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add boundary overlay to existing plot — add_boundary_overlay","text":"","code":"add_boundary_overlay(region_boundary, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_crop_statistics_overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Add crop statistics overlay — add_crop_statistics_overlay","title":"Add crop statistics overlay — add_crop_statistics_overlay","text":"Add crop statistics overlay","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_crop_statistics_overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add crop statistics overlay — add_crop_statistics_overlay","text":"","code":"add_crop_statistics_overlay(plot_obj, cdl_raster, crop_codes, crop_names)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_lines_to_leaflet.html","id":null,"dir":"Reference","previous_headings":"","what":"Add lines to leaflet - — add_lines_to_leaflet","title":"Add lines to leaflet - — add_lines_to_leaflet","text":"Add lines leaflet -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_lines_to_leaflet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add lines to leaflet - — add_lines_to_leaflet","text":"","code":"add_lines_to_leaflet(   map_obj,   spatial_data,   fill_variable,   popup_vars,   color_scheme )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_points_to_leaflet.html","id":null,"dir":"Reference","previous_headings":"","what":"Add points to leaflet - — add_points_to_leaflet","title":"Add points to leaflet - — add_points_to_leaflet","text":"Add points leaflet -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_points_to_leaflet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add points to leaflet - — add_points_to_leaflet","text":"","code":"add_points_to_leaflet(   map_obj,   spatial_data,   fill_variable,   popup_vars,   color_scheme,   cluster_points )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_polygons_to_leaflet.html","id":null,"dir":"Reference","previous_headings":"","what":"Add polygons to leaflet - — add_polygons_to_leaflet","title":"Add polygons to leaflet - — add_polygons_to_leaflet","text":"Add polygons leaflet -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/add_polygons_to_leaflet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add polygons to leaflet - — add_polygons_to_leaflet","text":"","code":"add_polygons_to_leaflet(   map_obj,   spatial_data,   fill_variable,   popup_vars,   color_scheme )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"Perform dynamic analysis CDL crop data including area calculations, classification, masking crop combination. Now accepts file paths directly.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"","code":"analyze_cdl_crops_dynamic(   cdl_data,   crop_selection,   region_boundary = NULL,   analysis_type = \"classify\",   output_folder = NULL,   year = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"cdl_data CDL raster data (file path, directory, SpatRaster object) crop_selection Crop selection (names, codes, categories) region_boundary Region boundary analysis_type Type analysis: \"mask\", \"classify\", \"area\" output_folder Output directory year Year analysis (optional)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"Analysis results depend analysis_type: \"mask\": SpatRaster binary mask (1 = crop, 0 = ) \"classify\": SpatRaster binary classification \"area\": List detailed area analysis: crop_areas_ha: Named list areas crop code (hectares) total_area_ha: Total crop area (hectares) pixel_size_ha: Individual pixel size (hectares) crop_codes: CDL codes analyzed crop_name: Crop name(s) region: Region analyzed raster_info: Technical raster information total_pixels: Total number pixels valid_pixels: Number valid (non-NA) pixels","code":""},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"area-analysis-results-","dir":"Reference","previous_headings":"","what":"Area Analysis Results:","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"","code":"# Access specific results result$total_area_ha          # Total area in hectares result$crop_areas_ha          # Area by crop code result$crop_areas_ha[[\"5\"]]   # Soybean area (code 5)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"visualization-","dir":"Reference","previous_headings":"","what":"Visualization:","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"","code":"# For mask/classify results (SpatRaster): terra::plot(result)           # Plot the raster  # For area results (list): print(result$total_area_ha)   # Print total area barplot(unlist(result$crop_areas_ha))  # Simple bar plot"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_cdl_crops_dynamic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze CDL crops dynamically — analyze_cdl_crops_dynamic","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require actual CDL data files # Analyze soybean area in Iowa - accepts file path directly soybean_area <- analyze_cdl_crops_dynamic(   \"/path/to/cdl_2023.tif\", \"soybeans\", \"Iowa\", \"area\" )  # Access area results soybean_area$total_area_ha                    # Total hectares soybean_area$crop_areas_ha[[\"5\"]]            # Soybean area (code 5) soybean_area$total_area_ha * 2.47105         # Convert to acres  # Create grain classification grain_classes <- analyze_cdl_crops_dynamic(   cdl_data, \"grains\", \"CONUS\", \"classify\" ) terra::plot(grain_classes)  # Plot the classification  # Works with directories too results <- analyze_cdl_crops_dynamic(   \"/path/to/cdl/files/\", \"corn\", \"Ohio\", \"area\" ) } # }  # \\donttest{ # Example with mock CDL data (this can run) # Create sample CDL raster mock_cdl <- terra::rast(nrows = 10, ncols = 10, xmin = 0, xmax = 10,                        ymin = 0, ymax = 10, crs = \"EPSG:4326\") terra::values(mock_cdl) <- sample(c(1, 5, 24), 100, replace = TRUE)  # corn, soy, wheat  # Analyze mock data result <- analyze_cdl_crops_dynamic(mock_cdl, \"corn\", analysis_type = \"mask\") #> Starting dynamic CDL crop analysis... #> Analyzing 1 crop codes for corn #> CDL analysis completed! print(class(result))  # Should be SpatRaster #> [1] \"SpatRaster\" #> attr(,\"package\") #> [1] \"terra\" # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":null,"dir":"Reference","previous_headings":"","what":"Specialized crop vegetation analysis — analyze_crop_vegetation","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"Perform comprehensive vegetation analysis specifically designed crop monitoring including growth stage detection, stress identification, yield prediction support. Handles test scenarios properly better input validation.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"","code":"analyze_crop_vegetation(   spectral_data,   crop_type = \"general\",   growth_stage = \"unknown\",   analysis_type = \"comprehensive\",   cdl_mask = NULL,   reference_data = NULL,   output_folder = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"spectral_data Multi-band spectral data (file, directory, SpatRaster) crop_type Crop type specialized analysis (\"corn\", \"soybeans\", \"wheat\", \"general\") growth_stage Growth stage known (\"early\", \"mid\", \"late\", \"harvest\") analysis_type Type analysis: \"comprehensive\", \"stress\", \"growth\", \"yield\" cdl_mask Optional CDL mask crop-specific analysis reference_data Optional reference data validation output_folder Optional output folder results verbose Print detailed progress","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"List comprehensive vegetation analysis results: vegetation_indices: SpatRaster calculated indices analysis_results: Detailed analysis results type metadata: Analysis metadata parameters","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"crop-specific-index-selection-","dir":"Reference","previous_headings":"","what":"Crop-Specific Index Selection:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"Corn: NDVI, EVI, GNDVI, DVI, RVI, PRI Soybeans: NDVI, EVI, SAVI, GNDVI, PRI Wheat: NDVI, EVI, SAVI, DVI General: NDVI, EVI, SAVI, GNDVI, DVI, RVI","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"analysis-types-","dir":"Reference","previous_headings":"","what":"Analysis Types:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"comprehensive: analyses (stress, growth, yield) stress: Focus stress detection indices growth: Growth stage analysis yield: Yield prediction support","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"output-structure-","dir":"Reference","previous_headings":"","what":"Output Structure:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"function returns list three main components:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"-vegetation-indices-spatraster-","dir":"Reference","previous_headings":"","what":"1. vegetation_indices (SpatRaster)","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"Multi-layer raster calculated indices (NDVI, EVI, etc.)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"-analysis-results-list-","dir":"Reference","previous_headings":"","what":"2. analysis_results (List)","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"stress_analysis (requested): Percentage pixels stress category Categories: healthy (NDVI 0.6-1.0), moderate stress (0.4-0.6), severe stress (0.0-0.4) Includes mean, median, std_dev, thresholds used growth_analysis (requested): Predicted growth stage based NDVI patterns Stage confidence (0-1 scale) Detailed statistics index Growth stages: emergence, vegetative, reproductive, maturity (crop-specific) yield_analysis (requested): Composite Yield Index: Normalized 0-1 score combining multiple indices 0.0 = low yield potential 0.5 = Medium yield potential 1.0 = Maximum yield potential Yield Potential Class: Categorical (Low, Medium, High, High) Index Contributions: index contributed composite score Calculation: index (NDVI, EVI, GNDVI, DVI, RVI) normalized 0-1, averaged create composite score summary_statistics: Basic stats (mean, std, min, max, percentiles) indices Coverage percentage pixel counts","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"-metadata-list-","dir":"Reference","previous_headings":"","what":"3. metadata (List)","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"Processing information: crop_type, indices_used, processing_date, spatial properties","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"example-interpretation-","dir":"Reference","previous_headings":"","what":"Example Interpretation:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"","code":"result <- analyze_crop_vegetation(data, crop_type = \"corn\")  # Stress Assessment stress <- result$analysis_results$stress_analysis$NDVI cat(sprintf(\"Healthy: %.1f%%, Stressed: %.1f%%\\n\",             stress$healthy_percentage,             stress$severe_stress_percentage))  # Growth Stage stage <- result$analysis_results$growth_analysis$predicted_growth_stage cat(sprintf(\"Growth stage: %s\\n\", stage))  # Yield Potential yield <- result$analysis_results$yield_analysis cat(sprintf(\"Yield potential: %s (score: %.2f)\\n\",             yield$yield_potential_class,             yield$composite_yield_index))"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"important-notes-","dir":"Reference","previous_headings":"","what":"Important Notes:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"Composite Yield Index vegetation-based proxy, direct yield prediction Thresholds based literature may need regional calibration Results validated ground truth data detailed output documentation, see package vignette","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"analysis-types--1","dir":"Reference","previous_headings":"","what":"Analysis Types:","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"comprehensive: analyses (stress, growth, yield) stress: Focus stress detection indices growth: Growth stage analysis yield: Yield prediction support","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_crop_vegetation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specialized crop vegetation analysis — analyze_crop_vegetation","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require actual spectral data # Comprehensive corn analysis corn_analysis <- analyze_crop_vegetation(   spectral_data = sentinel_data,   crop_type = \"corn\",   analysis_type = \"comprehensive\",   cdl_mask = corn_mask )  # Access results corn_analysis$vegetation_indices        # SpatRaster with indices corn_analysis$analysis_results$stress_analysis  # Stress detection results corn_analysis$metadata$indices_used     # Which indices were calculated  # Stress detection in soybeans stress_analysis <- analyze_crop_vegetation(   spectral_data = landsat_stack,   crop_type = \"soybeans\",   analysis_type = \"stress\",   growth_stage = \"mid\" ) } # }  # \\donttest{ # Example with mock spectral data # Create mock multi-band raster (simulating satellite data) red_band <- terra::rast(nrows = 5, ncols = 5, crs = \"EPSG:4326\") nir_band <- terra::rast(nrows = 5, ncols = 5, crs = \"EPSG:4326\") terra::values(red_band) <- runif(25, 0.1, 0.3)   # Typical red values terra::values(nir_band) <- runif(25, 0.4, 0.8)   # Typical NIR values spectral_stack <- c(red_band, nir_band) names(spectral_stack) <- c(\"red\", \"nir\")  # Analyze with mock data result <- analyze_crop_vegetation(spectral_stack, crop_type = \"general\") print(names(result))  # Should show analysis components #> [1] \"vegetation_indices\" \"analysis_results\"   \"metadata\"           # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_growth_stage.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze growth stage — analyze_growth_stage","title":"Analyze growth stage — analyze_growth_stage","text":"Analyze growth stage","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_growth_stage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze growth stage — analyze_growth_stage","text":"","code":"analyze_growth_stage(vegetation_indices, crop_type, growth_stage, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_seasonal_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze seasonal patterns — analyze_seasonal_patterns","title":"Analyze seasonal patterns — analyze_seasonal_patterns","text":"Internal function analyze seasonal patterns temporal data.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_seasonal_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze seasonal patterns — analyze_seasonal_patterns","text":"","code":"analyze_seasonal_patterns(rasters, dates)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_seasonal_patterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze seasonal patterns — analyze_seasonal_patterns","text":"rasters List rasters dates Vector dates","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_seasonal_patterns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze seasonal patterns — analyze_seasonal_patterns","text":"List seasonal analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_temporal_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze temporal changes in geospatial data — analyze_temporal_changes","title":"Analyze temporal changes in geospatial data — analyze_temporal_changes","text":"Analyze temporal changes raster data including trend analysis, change detection, seasonal patterns. Works time series data.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_temporal_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze temporal changes in geospatial data — analyze_temporal_changes","text":"","code":"analyze_temporal_changes(   data_list,   dates = NULL,   region_boundary = NULL,   analysis_type = \"trend\",   output_folder = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_temporal_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze temporal changes in geospatial data — analyze_temporal_changes","text":"data_list List raster data different time periods dates Vector dates corresponding rasters region_boundary Region boundary analysis analysis_type Type temporal analysis: \"trend\", \"change_detection\", \"seasonal\", \"statistics\" output_folder Output directory results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_temporal_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze temporal changes in geospatial data — analyze_temporal_changes","text":"Temporal analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_temporal_changes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze temporal changes in geospatial data — analyze_temporal_changes","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Analyze NDVI trends over time ndvi_trend <- analyze_temporal_changes(   data_list = c(\"ndvi_2020.tif\", \"ndvi_2021.tif\", \"ndvi_2022.tif\"),   dates = c(\"2020\", \"2021\", \"2022\"),   region_boundary = \"Iowa\",   analysis_type = \"trend\" )  # Detect land cover changes land_changes <- analyze_temporal_changes(   data_list = land_cover_files,   dates = land_cover_dates,   analysis_type = \"change_detection\" ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_variable_correlations.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze correlations between multiple variables — analyze_variable_correlations","title":"Analyze correlations between multiple variables — analyze_variable_correlations","text":"Analyze correlations multiple raster variables create correlation matrices plots.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_variable_correlations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze correlations between multiple variables — analyze_variable_correlations","text":"","code":"analyze_variable_correlations(   variable_list,   output_folder = NULL,   region_boundary = NULL,   method = \"pearson\",   create_plots = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_variable_correlations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze correlations between multiple variables — analyze_variable_correlations","text":"variable_list Named list raster variables output_folder Output directory results region_boundary Optional region boundary method Correlation method create_plots Create correlation plots","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_variable_correlations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze correlations between multiple variables — analyze_variable_correlations","text":"List correlation results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_variable_correlations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze correlations between multiple variables — analyze_variable_correlations","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require directory structures with multiple data files # Analyze correlations between multiple variables variables <- list(   ndvi = \"ndvi.tif\",   nitrogen = \"soil_nitrogen.tif\",   elevation = \"dem.tif\",   precipitation = \"precip.tif\" )  correlation_results <- analyze_variable_correlations(   variables,   output_folder = \"correlations/\",   region_boundary = \"Ohio\" ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_bodies.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze water body characteristics using multiple indices — analyze_water_bodies","title":"Analyze water body characteristics using multiple indices — analyze_water_bodies","text":"Comprehensive water body analysis using multiple water indices classify characterize water features.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_bodies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze water body characteristics using multiple indices — analyze_water_bodies","text":"","code":"analyze_water_bodies(   green,   nir,   swir1 = NULL,   region_boundary = NULL,   water_threshold_ndwi = 0.3,   water_threshold_mndwi = 0.5,   output_folder = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_bodies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze water body characteristics using multiple indices — analyze_water_bodies","text":"green Green band SpatRaster file path nir NIR band SpatRaster file path swir1 SWIR1 band SpatRaster file path region_boundary Optional region boundary analysis water_threshold_ndwi NDWI threshold water detection (default: 0.3) water_threshold_mndwi MNDWI threshold water detection (default: 0.5) output_folder Optional output directory verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_bodies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze water body characteristics using multiple indices — analyze_water_bodies","text":"List water analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_bodies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze water body characteristics using multiple indices — analyze_water_bodies","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Comprehensive water analysis water_analysis <- analyze_water_bodies(   green = \"green.tif\",   nir = \"nir.tif\",   swir1 = \"swir1.tif\",   region_boundary = \"study_area.shp\",   verbose = TRUE )  # Access results water_analysis$water_indices     # All calculated indices water_analysis$water_mask        # Binary water mask water_analysis$statistics        # Water body statistics } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_quality_comprehensive.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","title":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","text":"Complete water quality analysis flexible data input handling, robust error checking, comprehensive spatial integration. Supports water quality dataset format automatic column detection standardized processing.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_quality_comprehensive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","text":"","code":"analyze_water_quality_comprehensive(   water_data,   variable = NULL,   region_boundary = NULL,   river_network = NULL,   output_folder = tempdir(),   thresholds = NULL,   coord_cols = NULL,   date_column = NULL,   station_id_col = NULL,   quality_filters = list(),   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_quality_comprehensive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","text":"water_data Water quality data various formats: File path (CSV, shapefile, GeoJSON) data.frame coordinates sf object List datasets multi-dataset analysis variable Variable analyze (auto-detected NULL) region_boundary Region boundary (optional) river_network Optional river network data context output_folder Output directory (default: tempdir()) thresholds Named list threshold values classification (optional) coord_cols Coordinate column names (auto-detected NULL) date_column Date/time column name (auto-detected NULL) station_id_col Station ID column name (auto-detected NULL) quality_filters Quality control filters apply verbose Print detailed progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_quality_comprehensive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","text":"List comprehensive water quality analysis results: water_data: Processed spatial data statistics: Summary statistics variable category spatial_analysis: Spatial pattern analysis temporal_analysis: Temporal trends (date data available) threshold_analysis: Threshold exceedance analysis output_files: Paths generated output files metadata: Analysis metadata parameters","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_quality_comprehensive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze water quality comprehensively with flexible data handling — analyze_water_quality_comprehensive","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Flexible data input - auto-detects columns results <- analyze_water_quality_comprehensive(\"water_stations.csv\")  # Specify parameters for custom data results <- analyze_water_quality_comprehensive(   water_data = my_data,   variable = \"nitrate_concentration\",   region_boundary = \"Ohio\",   coord_cols = c(\"longitude\", \"latitude\"),   thresholds = list(     Normal = c(0, 2),     Elevated = c(2, 5),     High = c(5, 10),     Critical = c(10, Inf)   ) )  # Multi-dataset analysis results <- analyze_water_quality_comprehensive(   water_data = list(     surface = \"surface_water.csv\",     groundwater = \"groundwater.csv\"   ),   variable = \"total_nitrogen\" ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_spatial_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze spatial patterns in water quality data — analyze_water_spatial_patterns","title":"Analyze spatial patterns in water quality data — analyze_water_spatial_patterns","text":"Analyze spatial patterns water quality data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_spatial_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze spatial patterns in water quality data — analyze_water_spatial_patterns","text":"","code":"analyze_water_spatial_patterns(water_sf, variable, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_temporal_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze temporal patterns in water quality data — analyze_water_temporal_patterns","title":"Analyze temporal patterns in water quality data — analyze_water_temporal_patterns","text":"Analyze temporal patterns water quality data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_water_temporal_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze temporal patterns in water quality data — analyze_water_temporal_patterns","text":"","code":"analyze_water_temporal_patterns(water_sf, variable, date_column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_yield_potential.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze yield potential — analyze_yield_potential","title":"Analyze yield potential — analyze_yield_potential","text":"Analyze yield potential","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/analyze_yield_potential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze yield potential — analyze_yield_potential","text":"","code":"analyze_yield_potential(vegetation_indices, crop_type, indices, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_color_scheme_ggplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply color scheme to ggplot — apply_color_scheme_ggplot","title":"Apply color scheme to ggplot — apply_color_scheme_ggplot","text":"Apply color scheme ggplot","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_color_scheme_ggplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply color scheme to ggplot — apply_color_scheme_ggplot","text":"","code":"apply_color_scheme_ggplot(plot, color_scheme, aesthetic = \"fill\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_quality_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply quality filter to remove outliers — apply_quality_filter","title":"Apply quality filter to remove outliers — apply_quality_filter","text":"Apply quality filter remove outliers","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_quality_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply quality filter to remove outliers — apply_quality_filter","text":"","code":"apply_quality_filter(ndvi, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_temporal_smoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply temporal smoothing — apply_temporal_smoothing","title":"Apply temporal smoothing — apply_temporal_smoothing","text":"Apply temporal smoothing","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_temporal_smoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply temporal smoothing — apply_temporal_smoothing","text":"","code":"apply_temporal_smoothing(ndvi_stack, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_water_quality_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply water quality filters — apply_water_quality_filters","title":"Apply water quality filters — apply_water_quality_filters","text":"Apply water quality filters","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/apply_water_quality_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply water quality filters — apply_water_quality_filters","text":"","code":"apply_water_quality_filters(water_sf, variable, quality_filters, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/assess_data_for_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess data characteristics for interpolation method selection — assess_data_for_interpolation","title":"Assess data characteristics for interpolation method selection — assess_data_for_interpolation","text":"Assess data characteristics interpolation method selection","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/assess_data_for_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess data characteristics for interpolation method selection — assess_data_for_interpolation","text":"","code":"assess_data_for_interpolation(spatial_sf, target_variables, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-detect best spatial join method — auto_detect_method","title":"Auto-detect best spatial join method — auto_detect_method","text":"Auto-detect best spatial join method","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-detect best spatial join method — auto_detect_method","text":"","code":"auto_detect_method(source_type, target_type, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auto-detect best spatial join method — auto_detect_method","text":"source_type Type source data target_type Type target data verbose Print messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auto-detect best spatial join method — auto_detect_method","text":"Character string recommended method","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_spectral_bands.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-detect spectral bands — auto_detect_spectral_bands","title":"Auto-detect spectral bands — auto_detect_spectral_bands","text":"Auto-detect spectral bands","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_spectral_bands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-detect spectral bands — auto_detect_spectral_bands","text":"","code":"auto_detect_spectral_bands(spectral_data, layer_names, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_title.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-detect title for quick mapping — auto_detect_title","title":"Auto-detect title for quick mapping — auto_detect_title","text":"Auto-detect title quick mapping","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_title.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-detect title for quick mapping — auto_detect_title","text":"","code":"auto_detect_title(spatial_data, variable)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-detect variable for quick mapping — auto_detect_variable","title":"Auto-detect variable for quick mapping — auto_detect_variable","text":"Auto-detect variable quick mapping","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_detect_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-detect variable for quick mapping — auto_detect_variable","text":"","code":"auto_detect_variable(spatial_data)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-geocode data with geographic identifiers — auto_geocode_data","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"Automatically detects geocodes data containing US geographic identifiers (states, counties, FIPS codes, HUC watershed codes, ZIP codes, city names) without requiring latitude/longitude coordinates.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"","code":"auto_geocode_data(   data,   detect_columns = TRUE,   entity_column = NULL,   entity_type = NULL,   verbose = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"data Data frame, file path (CSV, shapefile, etc.), sf object detect_columns Auto-detect geographic entity columns (default: TRUE) entity_column Explicitly specify column containing geographic entities (optional) entity_type Explicitly specify entity type: \"state\", \"county\", \"fips\", \"huc\", \"zipcode\", \"city\" (optional) verbose Print detailed progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"sf object geocoded point polygon geometries","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"Supported geographic entities: States: Full names 2-letter abbreviations (e.g., \"Ohio\", \"OH\") Counties: County names, optionally state FIPS codes: 5-digit Federal Information Processing Standards codes HUC codes: Hydrologic Unit Codes (HUC8, HUC10, HUC12) ZIP codes: 5-digit US postal codes Cities: City names, works best state column Column name variations supported: HUC columns: HUC_8, HUC-8, huc8, Huc 8, etc. State columns: State, STATE, state_name, StateName, ST, etc. entity types handle spaces, hyphens, underscores, mixed case Required packages (installed automatically needed): tigris: US Census boundaries (states, counties, FIPS) nhdplusTools: HUC watershed boundaries zipcodeR: ZIP code centroids tidygeocoder: city name geocoding","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/auto_geocode_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-geocode data with geographic identifiers — auto_geocode_data","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detect and geocode - simplest usage geodata <- auto_geocode_data(\"mydata.csv\")  # With state names state_data <- data.frame(   state = c(\"California\", \"Texas\", \"New York\"),   population = c(39538223, 29145505, 20201249) ) state_sf <- auto_geocode_data(state_data)  # With FIPS codes fips_data <- data.frame(   fips = c(\"39049\", \"39035\", \"39113\"),  # Ohio counties   unemployment_rate = c(4.2, 3.8, 5.1) ) county_sf <- auto_geocode_data(fips_data)  # With HUC codes (handles various formats) watershed_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\", \"04110002\"),   water_quality_index = c(72, 65, 80) ) huc_sf <- auto_geocode_data(watershed_data)  # Explicit specification zip_sf <- auto_geocode_data(   my_data,   entity_column = \"postal_code\",   entity_type = \"zipcode\" )  # Then use with your other geospatialsuite functions quick_map(state_sf, variable = \"population\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_advanced_terrain_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","title":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","text":"Calculate advanced terrain metrics DEM including curvature, wetness index, stream power index.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_advanced_terrain_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","text":"","code":"calculate_advanced_terrain_metrics(   elevation_raster,   metrics = c(\"wetness_index\", \"curvature\", \"convergence\"),   region_boundary = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_advanced_terrain_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","text":"elevation_raster Digital elevation model metrics Vector metrics calculate region_boundary Optional region boundary","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_advanced_terrain_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","text":"List terrain metric rasters","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_advanced_terrain_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate advanced terrain metrics — calculate_advanced_terrain_metrics","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Calculate advanced terrain metrics terrain_metrics <- calculate_advanced_terrain_metrics(   elevation_raster = \"dem.tif\",   metrics = c(\"wetness_index\", \"curvature\", \"convergence\"),   region_boundary = \"watershed.shp\" ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_comprehensive_vegetation_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate comprehensive vegetation statistics - — calculate_comprehensive_vegetation_stats","title":"Calculate comprehensive vegetation statistics - — calculate_comprehensive_vegetation_stats","text":"Calculate comprehensive vegetation statistics -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_comprehensive_vegetation_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate comprehensive vegetation statistics - — calculate_comprehensive_vegetation_stats","text":"","code":"calculate_comprehensive_vegetation_stats(vegetation_stack, indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_contributing_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contributing area — calculate_contributing_area","title":"Calculate contributing area — calculate_contributing_area","text":"Internal function calculate contributing area wetness index.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_contributing_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contributing area — calculate_contributing_area","text":"","code":"calculate_contributing_area(dem)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_contributing_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contributing area — calculate_contributing_area","text":"dem Digital elevation model","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_contributing_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contributing area — calculate_contributing_area","text":"SpatRaster contributing area","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_index_by_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate index by type — calculate_index_by_type","title":"Calculate index by type — calculate_index_by_type","text":"Calculate index type","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_index_by_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate index by type — calculate_index_by_type","text":"","code":"calculate_index_by_type(   index_type,   red,   nir,   blue,   green,   swir1,   swir2,   red_edge,   coastal,   nir2,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate multiple vegetation indices at once — calculate_multiple_indices","title":"Calculate multiple vegetation indices at once — calculate_multiple_indices","text":"Calculate multiple vegetation indices spectral data single operation. Efficient comparative analysis comprehensive vegetation assessment. Supports directory input automatic CRS handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate multiple vegetation indices at once — calculate_multiple_indices","text":"","code":"calculate_multiple_indices(   spectral_data = NULL,   indices = c(\"NDVI\", \"EVI\", \"SAVI\"),   output_stack = TRUE,   region_boundary = NULL,   parallel = FALSE,   verbose = FALSE,   ... )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate multiple vegetation indices at once — calculate_multiple_indices","text":"spectral_data Multi-band raster, directory path, individual bands indices Vector index names calculate output_stack Return single multi-layer raster (TRUE) list (FALSE) region_boundary Optional region boundary clipping parallel Use parallel processing multiple indices verbose Print progress messages ... Additional arguments passed calculate_vegetation_index","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate multiple vegetation indices at once — calculate_multiple_indices","text":"SpatRaster stack list indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_indices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate multiple vegetation indices at once — calculate_multiple_indices","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require satellite imagery files (Landsat/Sentinel data etc.) # Calculate multiple basic indices from directory multi_indices <- calculate_multiple_indices(   spectral_data = \"/path/to/sentinel/bands/\",   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"MSAVI\"),   auto_detect_bands = TRUE )  # Comprehensive vegetation analysis from individual files veg_analysis <- calculate_multiple_indices(   red = red_band, nir = nir_band, blue = blue_band,   indices = c(\"NDVI\", \"EVI\", \"ARVI\", \"GNDVI\", \"DVI\"),   output_stack = TRUE,   region_boundary = \"Iowa\" )  # Directory with custom band matching stress_indices <- calculate_multiple_indices(   spectral_data = \"/path/to/bands/\",   indices = c(\"PRI\", \"SIPI\", \"NDRE\"),   band_names = c(\"red\", \"green\", \"nir\", \"red_edge\"),   output_stack = TRUE ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_water_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate multiple water indices at once — calculate_multiple_water_indices","title":"Calculate multiple water indices at once — calculate_multiple_water_indices","text":"Calculate multiple water indices spectral data single operation. Efficient comprehensive water moisture analysis.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_water_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate multiple water indices at once — calculate_multiple_water_indices","text":"","code":"calculate_multiple_water_indices(   green,   nir,   swir1 = NULL,   indices = c(\"NDWI\", \"MNDWI\", \"NDMI\"),   output_stack = TRUE,   clamp_values = TRUE,   mask_invalid = TRUE,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_water_indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate multiple water indices at once — calculate_multiple_water_indices","text":"green Green band SpatRaster file path nir NIR band SpatRaster file path swir1 SWIR1 band SpatRaster file path indices Vector index names calculate output_stack Return single multi-layer raster (TRUE) list (FALSE) clamp_values Apply reasonable value clamping mask_invalid Mask invalid values verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_water_indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate multiple water indices at once — calculate_multiple_water_indices","text":"SpatRaster stack list water indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_multiple_water_indices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate multiple water indices at once — calculate_multiple_water_indices","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Calculate multiple water indices water_indices <- calculate_multiple_water_indices(   green = green_band,   nir = nir_band,   swir1 = swir1_band,   indices = c(\"NDWI\", \"MNDWI\", \"NDMI\", \"MSI\"),   output_stack = TRUE,   verbose = TRUE )  # Access individual indices ndwi <- water_indices[[\"NDWI\"]] mndwi <- water_indices[[\"MNDWI\"]] } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate NDVI with time series options — calculate_ndvi_enhanced","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"NDVI calculation specifically designed time series analysis date matching, quality filtering, temporal smoothing, multi-temporal support. Use time series analysis, use calculate_vegetation_index() single dates.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"","code":"calculate_ndvi_enhanced(   red_data,   nir_data,   clamp_range = c(-0.2, 1),   match_by_date = FALSE,   quality_filter = FALSE,   temporal_smoothing = FALSE,   verbose = FALSE,   date_patterns = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"red_data Red band data (files, directory, raster objects) nir_data NIR band data (files, directory, raster objects) clamp_range Range clamp NDVI values (default: c(-0.2, 1)) match_by_date Logical: match rasters date using filenames quality_filter Apply quality filtering (remove outliers) temporal_smoothing Apply temporal smoothing time series verbose Print progress messages date_patterns Custom date patterns matching","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"SpatRaster NDVI layers (single multi-layer time series)","code":""},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"use-calculate-ndvi-enhanced-for-","dir":"Reference","previous_headings":"","what":"Use calculate_ndvi_enhanced() for:","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"Time series analysis: Multiple dates, trend analysis Quality control: Remove outliers, temporal smoothing Date matching: Automatic pairing red/NIR date Multi-temporal studies: Seasonal analysis, change detection","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"use-calculate-vegetation-index-index-type-ndvi-for-","dir":"Reference","previous_headings":"","what":"Use calculate_vegetation_index(index_type=\"NDVI\") for:","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"Single date analysis: One-time calculation Different indices: Want calculate EVI, SAVI, etc. Quick calculations: Simple, fast NDVI Mixed workflows: Part larger vegetation index analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_ndvi_enhanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate NDVI with time series options — calculate_ndvi_enhanced","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Time series NDVI with date matching ndvi_series <- calculate_ndvi_enhanced(   red_data = \"/path/to/red/time_series/\",   nir_data = \"/path/to/nir/time_series/\",   match_by_date = TRUE,   quality_filter = TRUE,   temporal_smoothing = TRUE )  # Simple NDVI (single date with quality control) ndvi_clean <- calculate_ndvi_enhanced(   red_data = red_raster,   nir_data = nir_raster,   quality_filter = TRUE ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_skewness.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate skewness for data assessment — calculate_skewness","title":"Calculate skewness for data assessment — calculate_skewness","text":"Calculate skewness data assessment","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_skewness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate skewness for data assessment — calculate_skewness","text":"","code":"calculate_skewness(x)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_spatial_correlation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","title":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","text":"Calculate spatial correlation two raster layers using various methods. Supports pixel-wise correlation local correlation analysis.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_spatial_correlation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","text":"","code":"calculate_spatial_correlation(   raster1,   raster2,   method = \"pearson\",   local_correlation = FALSE,   window_size = 3 )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_spatial_correlation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","text":"raster1 First raster layer raster2 Second raster layer method Correlation method: \"pearson\", \"spearman\", \"kendall\" local_correlation Calculate local correlation using moving window window_size Window size local correlation (pixels)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_spatial_correlation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","text":"Correlation coefficient SpatRaster local correlations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_spatial_correlation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate spatial correlation between raster layers — calculate_spatial_correlation","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Global correlation between NDVI and soil nitrogen correlation <- calculate_spatial_correlation(ndvi_raster, nitrogen_raster)  # Local correlation with moving window local_corr <- calculate_spatial_correlation(   ndvi_raster, nitrogen_raster,   local_correlation = TRUE,   window_size = 5 ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate temporal statistics — calculate_temporal_statistics","title":"Calculate temporal statistics — calculate_temporal_statistics","text":"Internal function calculate temporal statistics.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate temporal statistics — calculate_temporal_statistics","text":"","code":"calculate_temporal_statistics(rasters, dates)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate temporal statistics — calculate_temporal_statistics","text":"rasters List rasters dates Vector dates","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate temporal statistics — calculate_temporal_statistics","text":"List temporal statistics","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_trend.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate temporal trend using linear regression — calculate_temporal_trend","title":"Calculate temporal trend using linear regression — calculate_temporal_trend","text":"Internal function calculate pixel-wise temporal trends.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_trend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate temporal trend using linear regression — calculate_temporal_trend","text":"","code":"calculate_temporal_trend(rasters, dates)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_trend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate temporal trend using linear regression — calculate_temporal_trend","text":"rasters List rasters dates Vector dates","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_temporal_trend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate temporal trend using linear regression — calculate_temporal_trend","text":"List trend analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate comprehensive vegetation indices — calculate_vegetation_index","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"Calculate wide range vegetation indices spectral bands automatic band detection, comprehensive error handling, validation. Supports 40+ different vegetation indices various applications. Accepts directories, file lists, automatic CRS handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"","code":"calculate_vegetation_index(   spectral_data = NULL,   red = NULL,   nir = NULL,   blue = NULL,   green = NULL,   swir1 = NULL,   swir2 = NULL,   red_edge = NULL,   coastal = NULL,   nir2 = NULL,   index_type = \"NDVI\",   auto_detect_bands = FALSE,   band_names = NULL,   clamp_range = NULL,   mask_invalid = TRUE,   scale_factor = 1,   auto_crs_fix = TRUE,   region_boundary = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"spectral_data Either individual bands (red, nir, etc.), multi-band raster, directory path, list raster files red Red band SpatRaster file path nir NIR band SpatRaster file path blue Optional blue band green Optional green band swir1 Optional SWIR1 band swir2 Optional SWIR2 band red_edge Optional Red Edge band coastal Optional Coastal/Aerosol band nir2 Optional second NIR band index_type Vegetation index calculate (see list_vegetation_indices()) auto_detect_bands Automatically detect bands multi-band raster band_names Custom band names multi-band input clamp_range Range clamp output values (optional) mask_invalid Mask invalid/extreme values scale_factor Scaling factor needed (default: 1) auto_crs_fix Automatically fix CRS mismatches bands region_boundary Optional boundary crop mask result. Can sf object, file path shapefile, region name (get_region_boundary() available) verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"SpatRaster vegetation index","code":""},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"single-calculation-","dir":"Reference","previous_headings":"","what":"Single Calculation:","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"","code":"# Individual band files ndvi <- calculate_vegetation_index(red = \"red.tif\", nir = \"nir.tif\", index_type = \"NDVI\")  # Multi-band raster evi <- calculate_vegetation_index(spectral_data = \"landsat.tif\", index_type = \"EVI\",                                  auto_detect_bands = TRUE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"directory-multiple-files-","dir":"Reference","previous_headings":"","what":"Directory/Multiple Files:","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"","code":"# Directory with band files savi <- calculate_vegetation_index(spectral_data = \"/path/to/bands/\",                                   band_names = c(\"red\", \"nir\"), index_type = \"SAVI\")  # File list arvi <- calculate_vegetation_index(spectral_data = c(\"red.tif\", \"nir.tif\", \"blue.tif\"),                                   index_type = \"ARVI\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"basic-calculate-vegetation-index-","dir":"Reference","previous_headings":"","what":"Basic calculate_vegetation_index():","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"Single time point calculation 40+ different indices Directory/file support Automatic CRS fixing Use : Single-date analysis, comparing different indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"calculate-ndvi-enhanced-","dir":"Reference","previous_headings":"","what":"calculate_ndvi_enhanced():","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"Time series support Quality filtering Temporal smoothing Date matching red/NIR Use : Multi-temporal analysis, time series trends #' ## Band Naming Conventions: function supports case-insensitive band detection: Generic names: \"red\"/\"RED\"/\"Red\", \"nir\"/\"NIR\", \"blue\"/\"BLUE\", \"green\"/\"GREEN\" Landsat 8/9: B1-B7 (e.g., B4=Red, B5=NIR) Sentinel-2: B01-B12 (e.g., B04=Red, B08=NIR, B05=RedEdge) MODIS: band1-band7","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"satellite-specific-examples-","dir":"Reference","previous_headings":"","what":"Satellite-Specific Examples:","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"Landsat 8/9:   Sentinel-2:   Custom band names:   complete band naming documentation, see: vignette(\"vegetation-indices\", package = \"geospatialsuite\")","code":"# Bands automatically detected ndvi <- calculate_vegetation_index(   spectral_data = \"LC08_stack.tif\",  # Has bands named B1-B7   index_type = \"NDVI\",   auto_detect_bands = TRUE ) # Red Edge indices need Sentinel-2 ndre <- calculate_vegetation_index(   spectral_data = sentinel_data,  # Has B01-B12   index_type = \"NDRE\",   auto_detect_bands = TRUE ) # Rename your bands first names(my_raster) <- c(\"red\", \"nir\", \"blue\", \"green\")  # Or specify explicitly ndvi <- calculate_vegetation_index(   red = my_raster[[1]],   nir = my_raster[[4]],   index_type = \"NDVI\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate comprehensive vegetation indices — calculate_vegetation_index","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require satellite imagery files (Landsat/Sentinel data etc.) # Basic NDVI calculation ndvi <- calculate_vegetation_index(red = red_band, nir = nir_band, index_type = \"NDVI\")  # Multi-band raster with auto-detection evi <- calculate_vegetation_index(spectral_data = landsat_stack,                                  index_type = \"EVI\", auto_detect_bands = TRUE)  # Directory with automatic band detection savi <- calculate_vegetation_index(spectral_data = \"/path/to/sentinel/bands/\",                                   index_type = \"SAVI\", auto_detect_bands = TRUE)  # Advanced index with custom parameters pri <- calculate_vegetation_index(red = red_band, nir = nir_band, green = green_band,                                  index_type = \"PRI\", clamp_range = c(-1, 1))  # Custom band names for multi-band data ndvi <- calculate_vegetation_index(spectral_data = sentinel_data,                                   band_names = c(\"B4\", \"B3\", \"B2\", \"B8\"),                                   index_type = \"NDVI\")  # With region boundary (auto CRS conversion and crop/mask) ndvi_ohio <- calculate_vegetation_index(red = red_band, nir = nir_band,                                        index_type = \"NDVI\",                                        region_boundary = boundary_sf,                                        verbose = TRUE) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate vegetation statistics — calculate_vegetation_statistics","title":"Calculate vegetation statistics — calculate_vegetation_statistics","text":"Calculate vegetation statistics","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_vegetation_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate vegetation statistics — calculate_vegetation_statistics","text":"","code":"calculate_vegetation_statistics(vegetation_indices, indices, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate water indices including both NDWI variants — calculate_water_index","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"Calculate various water indices including NDWI (McFeeters 1996), MNDWI (Xu 2006), NDMI (Gao 1996) water body detection moisture content. Updated formulas based latest research satellite missions (2024).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"","code":"calculate_water_index(   green,   nir,   swir1 = NULL,   index_type = \"NDWI\",   clamp_range = NULL,   mask_invalid = TRUE,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"green Green band SpatRaster file path nir NIR band SpatRaster file path swir1 SWIR1 band SpatRaster file path (MNDWI, NDMI) index_type Index type: \"NDWI\", \"MNDWI\", \"NDMI\", \"MSI\", \"NDII\", \"WI\", \"SRWI\", \"LSWI\" clamp_range Optional range clamp output values mask_invalid Mask invalid/extreme values verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"SpatRaster water index","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"Available water indices specific applications:","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"primary-water-detection-indices-","dir":"Reference","previous_headings":"","what":"Primary Water Detection Indices:","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"NDWI (McFeeters 1996): (Green - NIR) / (Green + NIR) - Use: Open water body detection, flood mapping - Range: Values -1 1, water bodies typically > 0.3 - Pros: Simple, effective clear water - Cons: Sensitive built-areas, can overestimate water MNDWI (Xu 2006): (Green - SWIR1) / (Green + SWIR1) - Use: Enhanced water detection, urban water bodies - Range: Values -1 1, water bodies typically > 0.5 - Pros: Better separation water built-areas - Cons: Requires SWIR band, less effective turbid water","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"vegetation-moisture-indices-","dir":"Reference","previous_headings":"","what":"Vegetation Moisture Indices:","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"NDMI (Gao 1996): (NIR - SWIR1) / (NIR + SWIR1) - Use: Vegetation water content, drought monitoring - Range: Values -1 1, higher values = water content - Application: Agriculture, forest fire risk assessment MSI: SWIR1 / NIR - Moisture Stress Index - Use: Plant water stress detection - Range: [0, 5+], lower values = higher moisture NDII: (NIR - SWIR1) / (NIR + SWIR1) - NDMI - Use: Alternative name NDMI, vegetation moisture","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"specialized-water-indices-","dir":"Reference","previous_headings":"","what":"Specialized Water Indices:","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"WI: NIR / SWIR1 - Water Index (simple ratio) SRWI: NIR / SWIR1 - Simple Ratio Water Index LSWI: (NIR - SWIR1) / (NIR + SWIR1) - Land Surface Water Index","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"band-requirements-by-satellite-","dir":"Reference","previous_headings":"","what":"Band Requirements by Satellite:","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"Landsat 8/9: Green=Band 3, NIR=Band 5, SWIR1=Band 6 Sentinel-2: Green=Band 3, NIR=Band 8, SWIR1=Band 11 MODIS: Green=Band 4, NIR=Band 2, SWIR1=Band 6","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate water indices including both NDWI variants — calculate_water_index","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Original NDWI for water body detection ndwi <- calculate_water_index(green_band, nir_band, index_type = \"NDWI\")  # Modified NDWI for enhanced water detection (requires SWIR1) mndwi <- calculate_water_index(green_band, nir_band, swir1_band, index_type = \"MNDWI\")  # NDMI for vegetation moisture monitoring ndmi <- calculate_water_index(green_band, nir_band, swir1_band, index_type = \"NDMI\")  # With quality control water_index <- calculate_water_index(   green = \"green.tif\",   nir = \"nir.tif\",   swir1 = \"swir1.tif\",   index_type = \"MNDWI\",   clamp_range = c(-1, 1),   mask_invalid = TRUE,   verbose = TRUE ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_quality_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate comprehensive water quality statistics — calculate_water_quality_statistics","title":"Calculate comprehensive water quality statistics — calculate_water_quality_statistics","text":"Calculate comprehensive water quality statistics","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/calculate_water_quality_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate comprehensive water quality statistics — calculate_water_quality_statistics","text":"","code":"calculate_water_quality_statistics(   water_sf,   variable,   numeric_vars,   threshold_results,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_raster_compatibility.html","id":null,"dir":"Reference","previous_headings":"","what":"Check raster compatibility — check_raster_compatibility","title":"Check raster compatibility — check_raster_compatibility","text":"Check raster compatibility","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_raster_compatibility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check raster compatibility — check_raster_compatibility","text":"","code":"check_raster_compatibility(raster1, raster2, auto_align = TRUE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_raster_compatibility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check raster compatibility — check_raster_compatibility","text":"raster1 First raster raster2 Second raster auto_align Attempt automatic alignment","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_raster_compatibility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check raster compatibility — check_raster_compatibility","text":"Aligned raster2 original compatible","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_required_packages.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and load required packages — check_required_packages","title":"Check and load required packages — check_required_packages","text":"Check load required packages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/check_required_packages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and load required packages — check_required_packages","text":"","code":"check_required_packages(packages)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_data_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify data input type — classify_data_input","title":"Classify data input type — classify_data_input","text":"Classify data input type","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_data_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify data input type — classify_data_input","text":"","code":"classify_data_input(data_input, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_data_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify data input type — classify_data_input","text":"data_input Input data various types verbose Print diagnostic messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_data_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify data input type — classify_data_input","text":"List type, class, data object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_spatial_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify spatial data type and load data — classify_spatial_data","title":"Classify spatial data type and load data — classify_spatial_data","text":"Classify spatial data type load data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_spatial_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify spatial data type and load data — classify_spatial_data","text":"","code":"classify_spatial_data(data_input, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_spatial_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify spatial data type and load data — classify_spatial_data","text":"data_input Input data (file path, directory, spatial object) verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/classify_spatial_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify spatial data type and load data — classify_spatial_data","text":"List data, type, class, path information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/combine_water_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine multiple water quality datasets — combine_water_datasets","title":"Combine multiple water quality datasets — combine_water_datasets","text":"Combine multiple water quality datasets","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/combine_water_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine multiple water quality datasets — combine_water_datasets","text":"","code":"combine_water_datasets(water_sf_list, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compare_interpolation_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare interpolation methods — compare_interpolation_methods","title":"Compare interpolation methods — compare_interpolation_methods","text":"Compare multiple interpolation methods using cross-validation return performance metrics method selection.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compare_interpolation_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare interpolation methods — compare_interpolation_methods","text":"","code":"compare_interpolation_methods(   spatial_data,   target_variable,   methods = c(\"NN\", \"simple\", \"spline\"),   cv_folds = 5,   verbose = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compare_interpolation_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare interpolation methods — compare_interpolation_methods","text":"spatial_data Spatial data interpolation target_variable Variable interpolate methods Vector methods compare cv_folds Number cross-validation folds verbose Print comparison results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compare_interpolation_methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare interpolation methods — compare_interpolation_methods","text":"Data frame method comparison results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compare_interpolation_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare interpolation methods — compare_interpolation_methods","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Compare interpolation methods method_comparison <- compare_interpolation_methods(   soil_data,   target_variable = \"nitrogen\",   methods = c(\"NN\", \"simple\", \"spline\"),   cv_folds = 10 )  # View results print(method_comparison) # Best method best_method <- method_comparison$method[which.min(method_comparison$rmse)] } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compile_interpolation_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile interpolation results into requested format — compile_interpolation_results","title":"Compile interpolation results into requested format — compile_interpolation_results","text":"Compile interpolation results requested format","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/compile_interpolation_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile interpolation results into requested format — compile_interpolation_results","text":"","code":"compile_interpolation_results(   interpolation_results,   original_data,   target_variables,   output_format,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_julian_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Julian date to standard format — convert_julian_date","title":"Convert Julian date to standard format — convert_julian_date","text":"Internal function convert Julian dates (YYYY-DDD) standard YYYY-MM-DD format.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_julian_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Julian date to standard format — convert_julian_date","text":"","code":"convert_julian_date(julian_str)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_julian_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Julian date to standard format — convert_julian_date","text":"julian_str Julian date string format \"YYYY-DDD\"","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_julian_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Julian date to standard format — convert_julian_date","text":"Standard date string \"YYYY-MM-DD\"","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_to_spatial_flexible.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert data.frame to sf with flexible coordinate detection — convert_to_spatial_flexible","title":"Convert data.frame to sf with flexible coordinate detection — convert_to_spatial_flexible","text":"Convert data.frame sf flexible coordinate detection","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/convert_to_spatial_flexible.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert data.frame to sf with flexible coordinate detection — convert_to_spatial_flexible","text":"","code":"convert_to_spatial_flexible(water_df, coord_cols, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_base_plot_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create base plot map as fallback — create_base_plot_map","title":"Create base plot map as fallback — create_base_plot_map","text":"Create base plot map fallback","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_base_plot_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create base plot map as fallback — create_base_plot_map","text":"","code":"create_base_plot_map(spatial_sf, fill_variable, map_type, title, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_comparison_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create comparison map (before/after, side-by-side) — create_comparison_map","title":"Create comparison map (before/after, side-by-side) — create_comparison_map","text":"Create comparison maps showing /analysis side--side comparisons using reliable terra plotting.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_comparison_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create comparison map (before/after, side-by-side) — create_comparison_map","text":"","code":"create_comparison_map(   data1,   data2,   comparison_type = \"side_by_side\",   titles = c(\"Dataset 1\", \"Dataset 2\"),   region_boundary = NULL,   color_scheme = \"viridis\",   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_comparison_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create comparison map (before/after, side-by-side) — create_comparison_map","text":"data1 First dataset (, reference) data2 Second dataset (, comparison) comparison_type Type: \"side_by_side\", \"difference\" titles Titles dataset region_boundary Optional region boundary color_scheme Color scheme datasets output_file Optional output file path verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_comparison_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create comparison map (before/after, side-by-side) — create_comparison_map","text":"NULL (plots directly device) file path saved","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_comparison_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create comparison map (before/after, side-by-side) — create_comparison_map","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Before/after NDVI comparison create_comparison_map(\"ndvi_2020.tif\", \"ndvi_2023.tif\",                      comparison_type = \"side_by_side\",                      titles = c(\"2020\", \"2023\"),                      output_file = \"ndvi_comparison.png\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_correlation_plots.html","id":null,"dir":"Reference","previous_headings":"","what":"Create correlation plots — create_correlation_plots","title":"Create correlation plots — create_correlation_plots","text":"Internal function create correlation plots heatmaps.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_correlation_plots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create correlation plots — create_correlation_plots","text":"","code":"create_correlation_plots(correlation_matrix, output_folder)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_correlation_plots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create correlation plots — create_correlation_plots","text":"correlation_matrix Correlation matrix output_folder Output directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_area_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create crop area map - — create_crop_area_map","title":"Create crop area map - — create_crop_area_map","text":"Create crop area map -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_area_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create crop area map - — create_crop_area_map","text":"","code":"create_crop_area_map(cdl_raster, crop_codes, crop_names, boundary)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_diversity_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create crop diversity map - — create_crop_diversity_map","title":"Create crop diversity map - — create_crop_diversity_map","text":"Create crop diversity map -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_diversity_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create crop diversity map - — create_crop_diversity_map","text":"","code":"create_crop_diversity_map(cdl_raster, crop_codes, boundary)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create crop map visualization — create_crop_map","title":"Create crop map visualization — create_crop_map","text":"Create crop map visualization","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create crop map visualization — create_crop_map","text":"","code":"create_crop_map(   cdl_data,   crop_selection,   region_boundary = NULL,   style = \"categorical\",   output_file = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create crop map visualization — create_crop_map","text":"cdl_data CDL raster data crop_selection Selected crop types region_boundary Optional boundary cropping style Visualization style output_file Optional output file path","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create crop map visualization — create_crop_map","text":"Character string output file path saved, NULL plotted screen. Called primarily side effects (creating plots).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_mask.html","id":null,"dir":"Reference","previous_headings":"","what":"Create crop mask from CDL data — create_crop_mask","title":"Create crop mask from CDL data — create_crop_mask","text":"Create binary classified crop mask USDA CDL data specified crops. Fixed handle terra operations properly.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_mask.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create crop mask from CDL data — create_crop_mask","text":"","code":"create_crop_mask(   cdl_data,   crop_codes,   region_boundary = NULL,   mask_type = \"binary\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_mask.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create crop mask from CDL data — create_crop_mask","text":"cdl_data CDL raster data (file path SpatRaster) crop_codes Vector CDL codes crop names region_boundary Optional region boundary clipping mask_type Type mask: \"binary\" (1/0) \"preserve\" (keep original codes)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_mask.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create crop mask from CDL data — create_crop_mask","text":"SpatRaster crop mask","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_crop_mask.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create crop mask from CDL data — create_crop_mask","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require actual CDL data files # Create corn mask corn_mask <- create_crop_mask(\"cdl_2023.tif\", \"corn\", \"Iowa\")  # Create grain crops mask grain_mask <- create_crop_mask(cdl_raster, \"grains\", mask_type = \"preserve\") } # }  # \\donttest{ # Example with mock data (this can run) mock_cdl <- terra::rast(nrows = 5, ncols = 5, crs = \"EPSG:4326\") terra::values(mock_cdl) <- c(1, 1, 5, 5, 24, 1, 5, 5, 24, 24,                             1, 1, 5, 24, 24, 5, 5, 24, 24, 1,                             1, 5, 5, 24, 1)  # corn, soy, wheat  # Create corn mask from mock data corn_mask <- create_crop_mask(mock_cdl, \"corn\") print(terra::values(corn_mask))  # Should show 1s and 0s #>       crop_mask_binary #>  [1,]                1 #>  [2,]                1 #>  [3,]                0 #>  [4,]                0 #>  [5,]                0 #>  [6,]                1 #>  [7,]                0 #>  [8,]                0 #>  [9,]                0 #> [10,]                0 #> [11,]                1 #> [12,]                1 #> [13,]                0 #> [14,]                0 #> [15,]                0 #> [16,]                0 #> [17,]                0 #> [18,]                0 #> [19,]                0 #> [20,]                1 #> [21,]                1 #> [22,]                0 #> [23,]                0 #> [24,]                0 #> [25,]                1 # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_dominant_crop_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dominant crop map - — create_dominant_crop_map","title":"Create dominant crop map - — create_dominant_crop_map","text":"Create dominant crop map -","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_dominant_crop_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dominant crop map - — create_dominant_crop_map","text":"","code":"create_dominant_crop_map(cdl_raster, crop_codes, crop_names, boundary)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ggplot_map_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ggplot map safely — create_ggplot_map_safe","title":"Create ggplot map safely — create_ggplot_map_safe","text":"Create ggplot map safely","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ggplot_map_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ggplot map safely — create_ggplot_map_safe","text":"","code":"create_ggplot_map_safe(   spatial_sf,   fill_variable,   map_type,   region_boundary,   color_scheme,   title,   point_size,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create interactive map using leaflet (if available) — create_interactive_map","title":"Create interactive map using leaflet (if available) — create_interactive_map","text":"Create interactive maps leaflet integration available. Falls back gracefully leaflet installed.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create interactive map using leaflet (if available) — create_interactive_map","text":"","code":"create_interactive_map(   spatial_data,   fill_variable = NULL,   popup_vars = NULL,   basemap = \"terrain\",   color_scheme = \"viridis\",   title = \"Interactive Map\",   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create interactive map using leaflet (if available) — create_interactive_map","text":"spatial_data Spatial data map (sf object) fill_variable Variable coloring/filling popup_vars Variables show popups basemap Basemap type: \"terrain\", \"satellite\", \"osm\", \"light\" color_scheme Color scheme continuous variables title Map title verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create interactive map using leaflet (if available) — create_interactive_map","text":"leaflet map object NULL leaflet unavailable","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create interactive map using leaflet (if available) — create_interactive_map","text":"","code":"if (FALSE) { # \\dontrun{ # These examples demonstrate workflows with user's own spatial data # Simple interactive point map map <- create_interactive_map(study_sites, fill_variable = \"ndvi_mean\")  # Polygon map with custom basemap map <- create_interactive_map(counties, fill_variable = \"population\",                              basemap = \"satellite\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Create interactive map safely — create_interactive_map_safe","title":"Create interactive map safely — create_interactive_map_safe","text":"Create interactive map safely","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_interactive_map_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create interactive map safely — create_interactive_map_safe","text":"","code":"create_interactive_map_safe(   spatial_sf,   fill_variable,   map_type,   title,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ndvi_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create NDVI map visualization — create_ndvi_map","title":"Create NDVI map visualization — create_ndvi_map","text":"Create NDVI map visualization","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ndvi_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create NDVI map visualization — create_ndvi_map","text":"","code":"create_ndvi_map(   ndvi_data,   region_boundary = NULL,   ndvi_classes = \"none\",   title = \"NDVI Analysis\",   output_file = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ndvi_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create NDVI map visualization — create_ndvi_map","text":"ndvi_data NDVI raster data region_boundary Optional boundary analysis ndvi_classes Classification scheme NDVI title Plot title output_file Optional output file path","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_ndvi_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create NDVI map visualization — create_ndvi_map","text":"Character string output file path saved, NULL plotted screen. Called primarily side effects (creating plots).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_overlay_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Create overlay comparison — create_overlay_comparison","title":"Create overlay comparison — create_overlay_comparison","text":"Create overlay comparison","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_overlay_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create overlay comparison — create_overlay_comparison","text":"","code":"create_overlay_comparison(data1, data2, titles, color_scheme)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_map_reliable.html","id":null,"dir":"Reference","previous_headings":"","what":"Create reliable raster map — create_raster_map_reliable","title":"Create reliable raster map — create_raster_map_reliable","text":"Create reliable raster map","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_map_reliable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create reliable raster map — create_raster_map_reliable","text":"","code":"create_raster_map_reliable(   raster_data,   region_boundary,   color_scheme,   title,   output_file,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_mosaic.html","id":null,"dir":"Reference","previous_headings":"","what":"Create raster mosaic with intelligent file selection — create_raster_mosaic","title":"Create raster mosaic with intelligent file selection — create_raster_mosaic","text":"Create mosaics multiple raster files various methods intelligent file selection based region boundaries.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_mosaic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create raster mosaic with intelligent file selection — create_raster_mosaic","text":"","code":"create_raster_mosaic(   input_data,   method = \"merge\",   region_boundary = NULL,   output_file = NULL,   parallel = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_mosaic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create raster mosaic with intelligent file selection — create_raster_mosaic","text":"input_data Character vector file paths, directory path, list rasters method Mosaicing method: \"merge\", \"mosaic\", \"mean\", \"max\", \"min\" region_boundary Optional region boundary clipping output_file Optional output file path parallel Use parallel processing","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_mosaic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create raster mosaic with intelligent file selection — create_raster_mosaic","text":"SpatRaster object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_raster_mosaic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create raster mosaic with intelligent file selection — create_raster_mosaic","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Basic mosaic mosaic <- create_raster_mosaic(\"/path/to/rasters\", method = \"merge\")  # Mosaic for specific region ohio_mosaic <- create_raster_mosaic(\"/aster/files\", \"merge\", \"Ohio\")  # Mean composite mean_mosaic <- create_raster_mosaic(raster_list, method = \"mean\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_spatial_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create universal spatial map with reliable terra plotting — create_spatial_map","title":"Create universal spatial map with reliable terra plotting — create_spatial_map","text":"Universal mapping function works spatial data type using reliable terra base R plotting. complex dependencies required. Falls back gracefully optional packages unavailable.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_spatial_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create universal spatial map with reliable terra plotting — create_spatial_map","text":"","code":"create_spatial_map(   spatial_data,   fill_variable = NULL,   coord_cols = c(\"lon\", \"lat\"),   region_boundary = NULL,   map_type = \"auto\",   color_scheme = \"viridis\",   interactive = FALSE,   title = NULL,   point_size = 3,   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_spatial_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create universal spatial map with reliable terra plotting — create_spatial_map","text":"spatial_data sf object, data.frame coordinates, file path, SpatRaster fill_variable Variable use fill/color (vector data) coord_cols Coordinate column names data.frame provided region_boundary Optional region boundary map_type Type map: \"points\", \"polygons\", \"raster\", \"auto\" color_scheme Color scheme: \"viridis\", \"plasma\", \"ndvi\", \"terrain\", \"categorical\" interactive Create interactive map using leaflet (available) title Map title point_size Size points (point data) output_file Optional output file path verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_spatial_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create universal spatial map with reliable terra plotting — create_spatial_map","text":"ggplot2 object, leaflet map, file path (depending options)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_spatial_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create universal spatial map with reliable terra plotting — create_spatial_map","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Simple point map create_spatial_map(study_sites, fill_variable = \"ndvi_mean\")  # Raster map with region boundary create_spatial_map(ndvi_raster, region_boundary = \"Ohio\",                   color_scheme = \"ndvi\")  # Interactive map (if leaflet available) create_spatial_map(counties, fill_variable = \"population\",                   interactive = TRUE) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Create water quality plot — create_water_quality_plot","title":"Create water quality plot — create_water_quality_plot","text":"Create water quality plot","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create water quality plot — create_water_quality_plot","text":"","code":"create_water_quality_plot(   water_data,   variable,   region_boundary = NULL,   river_network = NULL,   thresholds = NULL,   output_file = NULL )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create water quality plot — create_water_quality_plot","text":"water_data Water quality spatial data variable Variable visualize region_boundary Optional boundary analysis river_network Optional river network overlay thresholds Quality thresholds visualization output_file Optional output file path","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create water quality plot — create_water_quality_plot","text":"Character string output file path saved, NULL plotted screen. Called primarily side effects (creating plots).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot_robust.html","id":null,"dir":"Reference","previous_headings":"","what":"Create robust water quality visualization — create_water_quality_plot_robust","title":"Create robust water quality visualization — create_water_quality_plot_robust","text":"Create robust water quality visualization","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/create_water_quality_plot_robust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create robust water quality visualization — create_water_quality_plot_robust","text":"","code":"create_water_quality_plot_robust(   water_data,   variable,   region_boundary,   river_network,   threshold_results,   output_file )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_coordinate_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect coordinate columns automatically — detect_coordinate_columns","title":"Detect coordinate columns automatically — detect_coordinate_columns","text":"Detect coordinate columns automatically","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_coordinate_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect coordinate columns automatically — detect_coordinate_columns","text":"","code":"detect_coordinate_columns(water_df, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geographic_entities.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect and geocode geographic entity columns — detect_geographic_entities","title":"Detect and geocode geographic entity columns — detect_geographic_entities","text":"Detect geocode geographic entity columns","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geographic_entities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect and geocode geographic entity columns — detect_geographic_entities","text":"","code":"detect_geographic_entities(data_input, verbose_debug = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geographic_entities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect and geocode geographic entity columns — detect_geographic_entities","text":"data_input Data frame potential geographic identifiers verbose_debug Print debugging information (default: FALSE)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geographic_entities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect and geocode geographic entity columns — detect_geographic_entities","text":"List detected column type, NULL none found","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geometry_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect geometry type automatically — detect_geometry_type","title":"Detect geometry type automatically — detect_geometry_type","text":"Detect geometry type automatically","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_geometry_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect geometry type automatically — detect_geometry_type","text":"","code":"detect_geometry_type(spatial_sf)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_huc_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect HUC level from column name or data — detect_huc_level","title":"Detect HUC level from column name or data — detect_huc_level","text":"Detect HUC level column name data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_huc_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect HUC level from column name or data — detect_huc_level","text":"","code":"detect_huc_level(column_name, data_values)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_huc_level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect HUC level from column name or data — detect_huc_level","text":"column_name Name HUC column data_values Sample HUC values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_huc_level.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect HUC level from column name or data — detect_huc_level","text":"Character string HUC type (e.g., \"huc08\", \"huc12\")","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_state_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper to detect state column — detect_state_column","title":"Helper to detect state column — detect_state_column","text":"Helper detect state column","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_state_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper to detect state column — detect_state_column","text":"","code":"detect_state_column(data)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_temporal_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect temporal changes between periods — detect_temporal_changes","title":"Detect temporal changes between periods — detect_temporal_changes","text":"Internal function detect changes time periods.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_temporal_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect temporal changes between periods — detect_temporal_changes","text":"","code":"detect_temporal_changes(rasters, dates)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_temporal_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect temporal changes between periods — detect_temporal_changes","text":"rasters List rasters dates Vector dates","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_temporal_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect temporal changes between periods — detect_temporal_changes","text":"List change detection results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_vegetation_stress.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect vegetation stress — detect_vegetation_stress","title":"Detect vegetation stress — detect_vegetation_stress","text":"Detect vegetation stress","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_vegetation_stress.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect vegetation stress — detect_vegetation_stress","text":"","code":"detect_vegetation_stress(vegetation_indices, crop_type, indices, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_water_quality_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect water quality data columns intelligently — detect_water_quality_columns","title":"Detect water quality data columns intelligently — detect_water_quality_columns","text":"Detect water quality data columns intelligently","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/detect_water_quality_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect water quality data columns intelligently — detect_water_quality_columns","text":"","code":"detect_water_quality_columns(   water_sf,   variable,   date_column,   station_id_col,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Download or access sample datasets for geospatialsuite — download_sample_data","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"Access built-sample datasets learning testing geospatialsuite functionality. datasets .rds format (CRAN-preferred) included package (~50-80KB total).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"","code":"download_sample_data(   dataset = \"all\",   dest_dir = tempdir(),   overwrite = FALSE,   verbose = TRUE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"dataset Name dataset download. See list_sample_datasets() available options. Use \"\" list datasets. dest_dir Directory save downloaded data (default: tempdir()) overwrite Overwrite existing files? (default: FALSE) verbose Print download progress? (default: TRUE)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"Character vector file paths sample data","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":"built-in-sample-data-no-download-required-","dir":"Reference","previous_headings":"","what":"Built-in Sample Data (No Download Required)","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"package includes small sample datasets inst/extdata/ using .rds format: sample_red.rds: Red band SpatRaster (10x10 pixels, Ohio region) sample_nir.rds: NIR band SpatRaster (10x10 pixels) sample_blue.rds: Blue band SpatRaster (10x10 pixels) sample_green.rds: Green band SpatRaster (10x10 pixels) sample_swir1.rds: SWIR1 band SpatRaster (10x10 pixels) sample_multiband.rds: Multi-band SpatRaster (5 layers stacked) sample_points.rds: Sample field locations (20 points, sf object) sample_boundary.rds: Sample study area polygon (sf object) sample_coordinates.csv: Sample coordinates attributes .rds files contain native R objects (SpatRaster sf) load instantly readRDS() load_sample_data() helper function.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/download_sample_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Download or access sample datasets for geospatialsuite — download_sample_data","text":"","code":"# \\donttest{ # List available datasets datasets <- list_sample_datasets() print(datasets) #>                 filename       type size_kb #> 1         sample_red.rds SpatRaster       2 #> 2         sample_nir.rds SpatRaster       2 #> 3        sample_blue.rds SpatRaster       2 #> 4       sample_green.rds SpatRaster       2 #> 5       sample_swir1.rds SpatRaster       2 #> 6   sample_multiband.rds SpatRaster       8 #> 7      sample_points.rds         sf       3 #> 8    sample_boundary.rds         sf       2 #> 9 sample_coordinates.csv data.frame       1 #>                                          description #> 1   Red band reflectance (10x10 pixels, Ohio region) #> 2   NIR band reflectance (10x10 pixels, Ohio region) #> 3  Blue band reflectance (10x10 pixels, Ohio region) #> 4 Green band reflectance (10x10 pixels, Ohio region) #> 5 SWIR1 band reflectance (10x10 pixels, Ohio region) #> 6   Multi-band raster (Blue, Green, Red, NIR, SWIR1) #> 7 Sample field locations (20 points with attributes) #> 8                 Sample study area boundary polygon #> 9    Sample coordinates with elevation and soil data #>                                          use_case available #> 1 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 2 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 3     Enhanced vegetation index (EVI) calculation      TRUE #> 4           Water index calculation (NDWI, GNDVI)      TRUE #> 5        Water and moisture indices (NDMI, MNDWI)      TRUE #> 6    Auto band detection, multi-index calculation      TRUE #> 7     Spatial join examples, extraction workflows      TRUE #> 8    Region boundary examples, masking operations      TRUE #> 9         Geocoding, spatial integration examples      TRUE #>                                access_method #> 1         load_sample_data('sample_red.rds') #> 2         load_sample_data('sample_nir.rds') #> 3        load_sample_data('sample_blue.rds') #> 4       load_sample_data('sample_green.rds') #> 5       load_sample_data('sample_swir1.rds') #> 6   load_sample_data('sample_multiband.rds') #> 7      load_sample_data('sample_points.rds') #> 8    load_sample_data('sample_boundary.rds') #> 9 load_sample_data('sample_coordinates.csv')  # Get path to built-in sample data red_file <- get_sample_data(\"sample_red.rds\") nir_file <- get_sample_data(\"sample_nir.rds\")  # Load and use sample data red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\")   # Plot (users can run this interactively)   # plot(ndvi, main = \"NDVI\", col = terrain.colors(100)) # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_interpolation_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute specific interpolation method — execute_interpolation_method","title":"Execute specific interpolation method — execute_interpolation_method","text":"Execute specific interpolation method","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_interpolation_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute specific interpolation method — execute_interpolation_method","text":"","code":"execute_interpolation_method(   complete_data,   variable,   method,   target_grid,   power,   max_distance,   min_points,   max_points,   mice_method,   mice_iterations,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_mice_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute MICE interpolation — execute_mice_interpolation","title":"Execute MICE interpolation — execute_mice_interpolation","text":"Execute MICE interpolation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_mice_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute MICE interpolation — execute_mice_interpolation","text":"","code":"execute_mice_interpolation(   complete_data,   variable,   mice_method,   mice_iterations,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_nn_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute nearest neighbor interpolation — execute_nn_interpolation","title":"Execute nearest neighbor interpolation — execute_nn_interpolation","text":"Execute nearest neighbor interpolation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_nn_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute nearest neighbor interpolation — execute_nn_interpolation","text":"","code":"execute_nn_interpolation(complete_data, variable, target_grid, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_simple_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute simple distance weighting interpolation — execute_simple_interpolation","title":"Execute simple distance weighting interpolation — execute_simple_interpolation","text":"Execute simple distance weighting interpolation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_simple_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute simple distance weighting interpolation — execute_simple_interpolation","text":"","code":"execute_simple_interpolation(   complete_data,   variable,   target_grid,   power,   max_distance,   max_points,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_spline_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute spline interpolation — execute_spline_interpolation","title":"Execute spline interpolation — execute_spline_interpolation","text":"Execute spline interpolation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/execute_spline_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute spline interpolation — execute_spline_interpolation","text":"","code":"execute_spline_interpolation(complete_data, variable, target_grid, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_aster_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coordinates from ASTER filename — extract_aster_coordinates","title":"Extract coordinates from ASTER filename — extract_aster_coordinates","text":"Internal function extract lat/lon coordinates ASTER filenames. Supports ASTER GDEM (ASTGTMV003) WBD (ASTWBDV001) formats.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_aster_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coordinates from ASTER filename — extract_aster_coordinates","text":"","code":"extract_aster_coordinates(filename, boundingbox = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_aster_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coordinates from ASTER filename — extract_aster_coordinates","text":"filename ASTER filename (e.g., \"ASTGTMV003_N40W084_dem.tif\" \"ASTWBDV001_N40W084_dem.tif\") boundingbox Logical. TRUE, returns bounding box coordinates instead centroid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_aster_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract coordinates from ASTER filename — extract_aster_coordinates","text":"List coordinates (lat/lon boundingbox=FALSE, lat_min/lat_max/lon_min/lon_max boundingbox=TRUE), NULL pattern matched","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_bands_from_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract bands from multi-band raster — extract_bands_from_raster","title":"Extract bands from multi-band raster — extract_bands_from_raster","text":"Extract bands multi-band raster","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_bands_from_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract bands from multi-band raster — extract_bands_from_raster","text":"","code":"extract_bands_from_raster(spectral_data, auto_detect, band_names, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_dates_universal.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract dates from filenames using various patterns — extract_dates_universal","title":"Extract dates from filenames using various patterns — extract_dates_universal","text":"Universal function extract dates filenames provide custom labels. Enhanced flexible regex patterns work filename prefix.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_dates_universal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract dates from filenames using various patterns — extract_dates_universal","text":"","code":"extract_dates_universal(input_data, date_patterns = NULL, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_dates_universal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract dates from filenames using various patterns — extract_dates_universal","text":"input_data Character vector (file paths folder), list raster layers date_patterns Named list custom regex patterns date extraction verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_dates_universal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract dates from filenames using various patterns — extract_dates_universal","text":"Character vector extracted inferred date labels","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/extract_dates_universal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract dates from filenames using various patterns — extract_dates_universal","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Extract dates from filenames dates <- extract_dates_universal(c(\"ndvi_2023-05-15.tif\", \"evi_2023-06-15.tif\"))  # Custom date patterns custom_patterns <- list(\"MMDDYYYY\" = \"\\\\b[0-9]{2}[0-9]{2}[0-9]{4}\\\\b\") dates <- extract_dates_universal(files, custom_patterns) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_enhanced_analysis_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate enhanced analysis summary — generate_enhanced_analysis_summary","title":"Generate enhanced analysis summary — generate_enhanced_analysis_summary","text":"Generate enhanced analysis summary","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_enhanced_analysis_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate enhanced analysis summary — generate_enhanced_analysis_summary","text":"","code":"generate_enhanced_analysis_summary(results, config)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_html_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate HTML summary report — generate_html_summary","title":"Generate HTML summary report — generate_html_summary","text":"Generate HTML summary report","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_html_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate HTML summary report — generate_html_summary","text":"","code":"generate_html_summary(summary_report, results, output_file)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_statistics_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate comprehensive statistics report — generate_statistics_report","title":"Generate comprehensive statistics report — generate_statistics_report","text":"Generate comprehensive statistics report","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/generate_statistics_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate comprehensive statistics report — generate_statistics_report","text":"","code":"generate_statistics_report(   statistics,   threshold_results,   spatial_analysis,   temporal_analysis,   variable,   region_boundary )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_cities.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode city names — geocode_cities","title":"Geocode city names — geocode_cities","text":"Geocode city names","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_cities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode city names — geocode_cities","text":"","code":"geocode_cities(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_counties.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode US counties — geocode_counties","title":"Geocode US counties — geocode_counties","text":"Geocode US counties","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_counties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode US counties — geocode_counties","text":"","code":"geocode_counties(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_entities.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode geographic entities to coordinates — geocode_entities","title":"Geocode geographic entities to coordinates — geocode_entities","text":"Geocode geographic entities coordinates","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_entities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode geographic entities to coordinates — geocode_entities","text":"","code":"geocode_entities(data_input, entity_info, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_entities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geocode geographic entities to coordinates — geocode_entities","text":"data_input Data frame geographic entity column entity_info List detect_geographic_entities verbose Print messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_entities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geocode geographic entities to coordinates — geocode_entities","text":"sf object geocoded locations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_fips.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode FIPS codes — geocode_fips","title":"Geocode FIPS codes — geocode_fips","text":"Geocode FIPS codes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_fips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode FIPS codes — geocode_fips","text":"","code":"geocode_fips(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_hucs.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode HUC watershed codes — geocode_hucs","title":"Geocode HUC watershed codes — geocode_hucs","text":"Geocode HUC watershed codes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_hucs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode HUC watershed codes — geocode_hucs","text":"","code":"geocode_hucs(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_states.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode US states — geocode_states","title":"Geocode US states — geocode_states","text":"Geocode US states","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_states.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode US states — geocode_states","text":"","code":"geocode_states(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_zipcodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocode ZIP codes — geocode_zipcodes","title":"Geocode ZIP codes — geocode_zipcodes","text":"Geocode ZIP codes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocode_zipcodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geocode ZIP codes — geocode_zipcodes","text":"","code":"geocode_zipcodes(data, column, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocoding_examples.html","id":null,"dir":"Reference","previous_headings":"","what":"Geocoding Examples and Use Cases — geocoding_examples","title":"Geocoding Examples and Use Cases — geocoding_examples","text":"file contains documented examples auto-geocoding functionality. examples demonstrate various use cases auto_geocode_data function.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geocoding_examples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geocoding Examples and Use Cases — geocoding_examples","text":"","code":"if (FALSE) { # \\dontrun{ # ======================================== # Example 1: State-level analysis # ======================================== state_data <- data.frame(   state = c(\"California\", \"TX\", \"New York\", \"FL\"),   gdp_billions = c(3598, 2357, 2053, 1389),   population_millions = c(39.5, 29.1, 20.2, 22.2) )  # Auto-detect and geocode state_sf <- auto_geocode_data(state_data, verbose = TRUE)  # Visualize quick_map(state_sf, variable = \"gdp_billions\",           title = \"GDP by State (Billions)\")  # ======================================== # Example 2: County-level with FIPS codes # ======================================== county_data <- data.frame(   fips = c(\"39049\", \"39035\", \"39113\", \"39061\"),   county_name = c(\"Franklin\", \"Cuyahoga\", \"Montgomery\", \"Hamilton\"),   unemployment = c(4.2, 5.1, 4.8, 3.9) )  county_sf <- auto_geocode_data(county_data) quick_map(county_sf, variable = \"unemployment\")  # ======================================== # Example 3: Watershed analysis with HUC codes # ======================================== # Works with ANY HUC format: HUC_8, HUC-8, huc8, Huc 8, etc. watershed_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\", \"04110002\"),   basin_name = c(\"Great Miami\", \"Mill Creek-Cincinnati\", \"Middle Ohio\"),   water_quality_index = c(72, 65, 80),   nitrogen_mg_l = c(2.3, 3.1, 1.8) )  huc_sf <- auto_geocode_data(watershed_data, verbose = TRUE) quick_map(huc_sf, variable = \"water_quality_index\",           title = \"Water Quality by Watershed\")  # ======================================== # Example 4: ZIP code analysis # ======================================== zip_data <- data.frame(   zip = c(\"43215\", \"44113\", \"45202\", \"43017\"),   median_home_price = c(285000, 195000, 320000, 410000) )  zip_sf <- auto_geocode_data(zip_data) quick_map(zip_sf, variable = \"median_home_price\")  # ======================================== # Example 5: Loading from CSV file # ======================================== # Assuming you have a CSV with state data census_sf <- auto_geocode_data(\"state_census_data.csv\", verbose = TRUE) quick_map(census_sf)  # ======================================== # Example 6: Preview before geocoding # ======================================== # Check what will be detected without actually geocoding my_data <- data.frame(   State = c(\"Ohio\", \"Michigan\"),   HUC8 = c(\"04100009\", \"04100012\"),   value = c(100, 200) )  preview_geocoding(my_data)  # ======================================== # Example 7: Explicit column specification # ======================================== # When auto-detection isn't working or you want to be explicit data_with_weird_names <- data.frame(   my_state_col = c(\"CA\", \"TX\", \"NY\"),   revenue = c(1000000, 800000, 1200000) )  result <- auto_geocode_data(   data_with_weird_names,   entity_column = \"my_state_col\",   entity_type = \"state\",   verbose = TRUE )  # ======================================== # Example 8: Integration with other geospatialsuite functions # ======================================== # Geocode, then use with spatial analysis state_sf <- auto_geocode_data(state_data)  # Use with universal_spatial_join raster_data <- terra::rast(\"ndvi_data.tif\") result <- universal_spatial_join(   source_data = state_sf,   target_data = raster_data,   method = \"extract\" )  # Create comprehensive analysis quick_map(result, variable = \"extracted_mean_ndvi\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":null,"dir":"Reference","previous_headings":"","what":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"geospatialsuite provides universal functions geospatial analysis reliable visualization work region multimodal data. Features include 60+ vegetation indices, efficient terra-based visualization, universal spatial mapping, dynamic crop analysis, water quality assessment, publication-quality mapping support geographic region robust error handling.","code":""},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"universal-spatial-analysis-","dir":"Reference","previous_headings":"","what":"Universal Spatial Analysis:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"Universal region support (states, countries, CONUS, custom boundaries) Universal spatial join (works raster-vector combination) Multi-dataset integration temporal analysis Spatial interpolation terrain analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"advanced-vegetation-analysis-","dir":"Reference","previous_headings":"","what":"Advanced Vegetation Analysis:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"60+ vegetation indices including NDVI, EVI, SAVI, ARVI, PRI, SIPI, etc. Specialized crop analysis stress detection yield assessment Auto band detection multi-band satellite imagery Quality filtering temporal smoothing time series","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"reliable-visualization-","dir":"Reference","previous_headings":"","what":"Reliable Visualization:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"Universal mapping auto-detection (quick_map() function) Terra-based plotting using reliable terra::plot() terra::plotRGB() Interactive maps leaflet integration (optional) RGB composites stretching algorithms Comparison maps /analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"agricultural-applications-","dir":"Reference","previous_headings":"","what":"Agricultural Applications:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"Dynamic CDL crop analysis (crop codes categories) NDVI time series classification Crop-specific analysis (corn, soybeans, wheat, etc.) Water quality assessment threshold analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"performance-amp-reliability-features-","dir":"Reference","previous_headings":"","what":"Performance & Reliability Features:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"Standard terra plotting - complex dependencies required Robust error handling throughout functions Simplified visualization maps Smart fallback systems optional packages unavailable","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"quick-start-examples-","dir":"Reference","previous_headings":"","what":"Quick Start Examples:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"","code":"# One-line mapping (auto-detects everything!) quick_map(\"mydata.shp\")  # Auto-geocode data without coordinates census_data <- data.frame(   state = c(\"Ohio\", \"Pennsylvania\", \"Michigan\"),   median_income = c(58642, 61744, 59584) ) spatial_data <- auto_geocode_data(census_data) quick_map(spatial_data, variable = \"median_income\")  # Works with HUC codes too (any format: HUC_8, HUC-8, huc8) watershed_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\"),   water_quality = c(72, 65) ) huc_spatial <- auto_geocode_data(watershed_data) quick_map(huc_spatial)  # Calculate multiple vegetation indices indices <- calculate_multiple_indices(   red = red_band, nir = nir_band,   indices = c(\"NDVI\", \"EVI\", \"SAVI\", \"PRI\") )  # Comprehensive crop analysis crop_analysis <- analyze_crop_vegetation(   spectral_data = sentinel_data,   crop_type = \"corn\",   analysis_type = \"comprehensive\" )  # Enhanced NDVI calculation ndvi_enhanced <- calculate_ndvi_enhanced(   red_data = red_raster,   nir_data = nir_raster,   quality_filter = TRUE )  # Fast, reliable RGB plotting plot_rgb_raster(satellite_data, r = 4, g = 3, b = 2,                stretch = \"hist\", title = \"False Color\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"recommended-optional-packages-","dir":"Reference","previous_headings":"","what":"Recommended Optional Packages:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"enhanced features, consider installing optional packages:","code":"# For interactive mapping install.packages(\"leaflet\")  # For enhanced colors install.packages(c(\"viridis\", \"RColorBrewer\"))  # For advanced remote sensing (optional) install.packages(\"RStoolbox\")  # For multi-panel plots (optional) install.packages(\"patchwork\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"core-dependencies-only-","dir":"Reference","previous_headings":"","what":"Core Dependencies Only:","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"package works reliably just core dependencies: terra (raster operations plotting) sf (vector operations) ggplot2 (static mapping) dplyr (data manipulation) complex visualization dependencies required!","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/geospatialsuite-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"geospatialsuite: Comprehensive Geospatiotemporal Analysis and Multimodal Integration Toolkit — geospatialsuite-package","text":"Olatunde D. Akanbi olatunde.akanbi@case.edu Vibha Mandayam vibha.mandayam@case.edu Yinghui Wu yinghui.wu2@case.edu Jeffrey Yarus jmy41@case.edu Erika . Barcelos erika.barcelos@case.edu Roger H. French roger.french@case.edu","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_available_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Get available indices — get_available_indices","title":"Get available indices — get_available_indices","text":"Get available indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_available_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get available indices — get_available_indices","text":"","code":"get_available_indices()"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_comprehensive_cdl_codes.html","id":null,"dir":"Reference","previous_headings":"","what":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","title":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","text":"Get USDA Cropland Data Layer (CDL) codes specific crops crop categories. Supports major crops predefined categories.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_comprehensive_cdl_codes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","text":"","code":"get_comprehensive_cdl_codes(crop_type = \"all\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_comprehensive_cdl_codes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","text":"crop_type Crop type category name. Options include: Individual crops: \"corn\", \"soybeans\", \"wheat\", etc. Categories: \"grains\", \"oilseeds\", \"fruits\", \"vegetables\", etc. \"\" available codes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_comprehensive_cdl_codes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","text":"Vector CDL codes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_comprehensive_cdl_codes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get comprehensive CDL crop codes — get_comprehensive_cdl_codes","text":"","code":"# \\donttest{ # Get corn code corn_codes <- get_comprehensive_cdl_codes(\"corn\") print(corn_codes)  # Should be 1 #> [1] 1  # Get all grain crop codes grain_codes <- get_comprehensive_cdl_codes(\"grains\") print(grain_codes)  # Should be vector of grain codes #>  [1]  1  4 21 22 23 24 25 27 28 29 30  # See available crop types (this will print to console) get_comprehensive_cdl_codes(\"help\") #> Available crop types and categories: #>  #> Individual crops: #>  [1] \"corn\"                     \"cotton\"                   #>  [3] \"rice\"                     \"sorghum\"                  #>  [5] \"soybeans\"                 \"sunflower\"                #>  [7] \"peanuts\"                  \"tobacco\"                  #>  [9] \"sweet_corn\"               \"pop_or_orn_corn\"          #> [11] \"mint\"                     \"barley\"                   #> [13] \"durum_wheat\"              \"spring_wheat\"             #> [15] \"winter_wheat\"             \"other_small_grains\"       #> [17] \"dbl_crop_winwht_soybeans\" \"rye\"                      #> [19] \"oats\"                     \"millet\"                   #> [21] \"speltz\"                   \"canola\"                   #> [23] \"flaxseed\"                 \"safflower\"                #> [25] \"rape_seed\"                \"mustard\"                  #> [27] \"alfalfa\"                  \"other_hay_non_alfalfa\"    #> [29] \"camelina\"                 \"buckwheat\"                #> [31] \"sugarbeets\"               \"dry_beans\"                #> [33] \"potatoes\"                 \"other_crops\"              #> [35] \"sugarcane\"                \"sweet_potatoes\"           #> [37] \"misc_vegs_fruits\"         \"watermelons\"              #> [39] \"onions\"                   \"cucumbers\"                #> [41] \"chick_peas\"               \"lentils\"                  #> [43] \"peas\"                     \"tomatoes\"                 #> [45] \"caneberries\"              \"hops\"                     #> [47] \"herbs\"                    \"clover_wildflowers\"       #> [49] \"sod_grass_seed\"           \"switchgrass\"              #> [51] \"fallow_idle_cropland\"     \"cherries\"                 #> [53] \"peaches\"                  \"apples\"                   #> [55] \"grapes\"                   \"christmas_trees\"          #> [57] \"other_tree_crops\"         \"citrus\"                   #> [59] \"pecans\"                   \"almonds\"                  #> [61] \"walnuts\"                  \"pears\"                    #> [63] \"carrots\"                  \"asparagus\"                #> [65] \"garlic\"                   \"cantaloupes\"              #> [67] \"prunes\"                   \"olives\"                   #> [69] \"oranges\"                  \"honeydew_melons\"          #> [71] \"broccoli\"                 \"avocados\"                 #> [73] \"peppers\"                  \"pomegranates\"             #> [75] \"nectarines\"               \"greens\"                   #> [77] \"plums\"                    \"strawberries\"             #> [79] \"squash\"                   \"apricots\"                 #> [81] \"vetch\"                    \"dbl_crop_oats_corn\"       #> [83] \"lettuce\"                  \"pasture_grass\"            #> [85] \"grassland_pasture\"        \"deciduous_forest\"         #> [87] \"evergreen_forest\"         \"mixed_forest\"             #> [89] \"water\"                    \"perennial_ice_snow\"       #> [91] \"herbaceous_wetlands\"      \"woody_wetlands\"           #> [93] \"developed_open_space\"     \"developed_low_intensity\"  #> [95] \"developed_med_intensity\"  \"developed_high_intensity\" #> [97] \"barren\"                   \"shrubland\"                #> [99] \"grassland_herbaceous\"     #>  #> Crop categories: #>  [1] \"grains\"           \"oilseeds\"         \"fruits\"           \"vegetables\"       #>  [5] \"legumes\"          \"forage\"           \"specialty\"        \"food_crops\"       #>  [9] \"feed_crops\"       \"industrial_crops\" \"all_crops\"        # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_formulas.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index formulas — get_index_formulas","title":"Get index formulas — get_index_formulas","text":"Get index formulas","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_formulas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index formulas — get_index_formulas","text":"","code":"get_index_formulas(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_ranges.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index typical ranges — get_index_ranges","title":"Get index typical ranges — get_index_ranges","text":"Get index typical ranges","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_ranges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index typical ranges — get_index_ranges","text":"","code":"get_index_ranges(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_references.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index references — get_index_references","title":"Get index references — get_index_references","text":"Get index references","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_references.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index references — get_index_references","text":"","code":"get_index_references(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_required_bands.html","id":null,"dir":"Reference","previous_headings":"","what":"Get required bands for each vegetation index — get_index_required_bands","title":"Get required bands for each vegetation index — get_index_required_bands","text":"Get required bands vegetation index","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_index_required_bands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get required bands for each vegetation index — get_index_required_bands","text":"","code":"get_index_required_bands(index_type)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_interpretation_guidelines.html","id":null,"dir":"Reference","previous_headings":"","what":"Get interpretation guidelines — get_interpretation_guidelines","title":"Get interpretation guidelines — get_interpretation_guidelines","text":"Get interpretation guidelines","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_interpretation_guidelines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get interpretation guidelines — get_interpretation_guidelines","text":"","code":"get_interpretation_guidelines(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_region_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Get region boundary for any specified region — get_region_boundary","title":"Get region boundary for any specified region — get_region_boundary","text":"Universal function get region boundaries geographic area including US states, countries, CONUS, counties, custom bounding boxes comprehensive error handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_region_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get region boundary for any specified region — get_region_boundary","text":"","code":"get_region_boundary(region_def, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_region_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get region boundary for any specified region — get_region_boundary","text":"region_def Region definition various formats: Character: \"Ohio\", \"Nigeria\", \"CONUS\" Character colon: \"Ohio:Franklin\" (state:county) Numeric vector: c(xmin, ymin, xmax, ymax) bounding box sf object: existing spatial object verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_region_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get region boundary for any specified region — get_region_boundary","text":"sf object boundary geometry","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_region_boundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get region boundary for any specified region — get_region_boundary","text":"","code":"# \\donttest{ # US State with error handling ohio_boundary <- get_region_boundary(\"Ohio\") #>    |                                                                               |                                                                      |   0%   |                                                                               |====                                                                  |   6%   |                                                                               |========                                                              |  11%   |                                                                               |============                                                          |  17%   |                                                                               |===================                                                   |  27%   |                                                                               |===========================                                           |  39%   |                                                                               |===================================                                   |  50%   |                                                                               |=====================================                                 |  52%   |                                                                               |========================================                              |  57%   |                                                                               |=========================================                             |  59%   |                                                                               |======================================================                |  77%   |                                                                               |===============================================================       |  90%   |                                                                               |=================================================================     |  93%   |                                                                               |======================================================================| 100%  # Custom bounding box with validation custom_area <- get_region_boundary(c(-84.5, 39.0, -82.0, 41.0)) # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_reliable_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Get reliable colors for terra plotting — get_reliable_colors","title":"Get reliable colors for terra plotting — get_reliable_colors","text":"Get reliable colors terra plotting","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_reliable_colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get reliable colors for terra plotting — get_reliable_colors","text":"","code":"get_reliable_colors(color_scheme, n = 100)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_sample_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get path to sample data file — get_sample_data","title":"Get path to sample data file — get_sample_data","text":"Helper function get full path sample data file included geospatialsuite. useful want file path rather loading data directly.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_sample_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get path to sample data file — get_sample_data","text":"","code":"get_sample_data(filename)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_sample_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get path to sample data file — get_sample_data","text":"filename Name sample data file (e.g., \"sample_red.rds\")","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_sample_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get path to sample data file — get_sample_data","text":"Character string full path file","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_sample_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get path to sample data file — get_sample_data","text":"","code":"# \\donttest{ # Get path to sample raster red_file <- get_sample_data(\"sample_red.rds\") nir_file <- get_sample_data(\"sample_nir.rds\")  # Load manually with terra::rast() for PackedSpatRaster red <- terra::rast(readRDS(red_file)) nir <- terra::rast(readRDS(nir_file))  # Or use load_sample_data() directly (recommended) red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\")  # Calculate NDVI ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\") # plot(ndvi) # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_satellite_band_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Get satellite band information — get_satellite_band_info","title":"Get satellite band information — get_satellite_band_info","text":"Get satellite band information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_satellite_band_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get satellite band information — get_satellite_band_info","text":"","code":"get_satellite_band_info(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_summary_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Get summary function for terra operations — get_summary_function","title":"Get summary function for terra operations — get_summary_function","text":"Get summary function terra operations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_summary_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get summary function for terra operations — get_summary_function","text":"","code":"get_summary_function(summary_function)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_summary_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get summary function for terra operations — get_summary_function","text":"summary_function Character name function","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_summary_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get summary function for terra operations — get_summary_function","text":"Function object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_terra_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Get terra colors for plotting — get_terra_colors","title":"Get terra colors for plotting — get_terra_colors","text":"Get terra colors plotting","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_terra_colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get terra colors for plotting — get_terra_colors","text":"","code":"get_terra_colors(scheme = \"viridis\", n = 100)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_water_index_formulas.html","id":null,"dir":"Reference","previous_headings":"","what":"Get water index formulas — get_water_index_formulas","title":"Get water index formulas — get_water_index_formulas","text":"Get water index formulas","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_water_index_formulas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get water index formulas — get_water_index_formulas","text":"","code":"get_water_index_formulas(indices)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_water_index_requirements.html","id":null,"dir":"Reference","previous_headings":"","what":"Get water index requirements — get_water_index_requirements","title":"Get water index requirements — get_water_index_requirements","text":"Get water index requirements","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/get_water_index_requirements.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get water index requirements — get_water_index_requirements","text":"","code":"get_water_index_requirements()"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_index_edge_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle edge cases for index calculations — handle_index_edge_cases","title":"Handle edge cases for index calculations — handle_index_edge_cases","text":"Handle edge cases index calculations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_index_edge_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle edge cases for index calculations — handle_index_edge_cases","text":"","code":"handle_index_edge_cases(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_outliers_in_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle outliers in spatial data — handle_outliers_in_data","title":"Handle outliers in spatial data — handle_outliers_in_data","text":"Handle outliers spatial data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_outliers_in_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle outliers in spatial data — handle_outliers_in_data","text":"","code":"handle_outliers_in_data(   spatial_sf,   target_variables,   method,   threshold,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_water_index_edge_cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle edge cases for water index calculations — handle_water_index_edge_cases","title":"Handle edge cases for water index calculations — handle_water_index_edge_cases","text":"Handle edge cases water index calculations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/handle_water_index_edge_cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle edge cases for water index calculations — handle_water_index_edge_cases","text":"","code":"handle_water_index_edge_cases(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_multiple_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate multiple datasets — integrate_multiple_datasets","title":"Integrate multiple datasets — integrate_multiple_datasets","text":"Integrate multiple datasets","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_multiple_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate multiple datasets — integrate_multiple_datasets","text":"","code":"integrate_multiple_datasets(   vector_data,   raster_datasets,   region_boundary = NULL,   output_format = \"sf\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_terrain_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate terrain analysis with vector data — integrate_terrain_analysis","title":"Integrate terrain analysis with vector data — integrate_terrain_analysis","text":"Specialized function terrain analysis integration. Calculates terrain variables DEM extracts values vector data points/polygons.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_terrain_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate terrain analysis with vector data — integrate_terrain_analysis","text":"","code":"integrate_terrain_analysis(   vector_data,   elevation_raster,   terrain_vars = c(\"slope\", \"aspect\", \"TRI\", \"TPI\", \"flowdir\"),   custom_terrain_functions = NULL,   extraction_method = \"simple\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_terrain_analysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate terrain analysis with vector data — integrate_terrain_analysis","text":"vector_data Vector data (points, lines, polygons) elevation_raster Digital elevation model terrain_vars Terrain variables calculate custom_terrain_functions Custom terrain analysis functions extraction_method Method extracting terrain values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_terrain_analysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate terrain analysis with vector data — integrate_terrain_analysis","text":"sf object terrain attributes","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/integrate_terrain_analysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrate terrain analysis with vector data — integrate_terrain_analysis","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Extract terrain variables for study sites sites_with_terrain <- integrate_terrain_analysis(   vector_data = \"study_sites.shp\",   elevation_raster = \"dem.tif\",   terrain_vars = c(\"slope\", \"aspect\", \"TRI\", \"TPI\") )  # Use custom terrain functions custom_functions <- list(   ruggedness = function(sf_data) {     sf_data$slope * sf_data$TRI   } )  terrain_analysis <- integrate_terrain_analysis(   vector_data = field_boundaries,   elevation_raster = dem_raster,   custom_terrain_functions = custom_functions ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/is_valid_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate date string — is_valid_date","title":"Validate date string — is_valid_date","text":"Internal function check date string valid.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/is_valid_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate date string — is_valid_date","text":"","code":"is_valid_date(date_str)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/is_valid_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate date string — is_valid_date","text":"date_str Date string validate","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/is_valid_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate date string — is_valid_date","text":"Logical indicating date valid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_sample_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"List available sample datasets — list_sample_datasets","title":"List available sample datasets — list_sample_datasets","text":"Display information sample datasets included geospatialsuite.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_sample_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List available sample datasets — list_sample_datasets","text":"","code":"list_sample_datasets(detailed = TRUE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_sample_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List available sample datasets — list_sample_datasets","text":"detailed Return detailed information? (default: TRUE)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_sample_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List available sample datasets — list_sample_datasets","text":"Data frame dataset information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_sample_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List available sample datasets — list_sample_datasets","text":"","code":"# \\donttest{ # List all sample datasets datasets <- list_sample_datasets() print(datasets) #>                 filename       type size_kb #> 1         sample_red.rds SpatRaster       2 #> 2         sample_nir.rds SpatRaster       2 #> 3        sample_blue.rds SpatRaster       2 #> 4       sample_green.rds SpatRaster       2 #> 5       sample_swir1.rds SpatRaster       2 #> 6   sample_multiband.rds SpatRaster       8 #> 7      sample_points.rds         sf       3 #> 8    sample_boundary.rds         sf       2 #> 9 sample_coordinates.csv data.frame       1 #>                                          description #> 1   Red band reflectance (10x10 pixels, Ohio region) #> 2   NIR band reflectance (10x10 pixels, Ohio region) #> 3  Blue band reflectance (10x10 pixels, Ohio region) #> 4 Green band reflectance (10x10 pixels, Ohio region) #> 5 SWIR1 band reflectance (10x10 pixels, Ohio region) #> 6   Multi-band raster (Blue, Green, Red, NIR, SWIR1) #> 7 Sample field locations (20 points with attributes) #> 8                 Sample study area boundary polygon #> 9    Sample coordinates with elevation and soil data #>                                          use_case available #> 1 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 2 Vegetation index calculation (NDVI, SAVI, etc.)      TRUE #> 3     Enhanced vegetation index (EVI) calculation      TRUE #> 4           Water index calculation (NDWI, GNDVI)      TRUE #> 5        Water and moisture indices (NDMI, MNDWI)      TRUE #> 6    Auto band detection, multi-index calculation      TRUE #> 7     Spatial join examples, extraction workflows      TRUE #> 8    Region boundary examples, masking operations      TRUE #> 9         Geocoding, spatial integration examples      TRUE #>                                access_method #> 1         load_sample_data('sample_red.rds') #> 2         load_sample_data('sample_nir.rds') #> 3        load_sample_data('sample_blue.rds') #> 4       load_sample_data('sample_green.rds') #> 5       load_sample_data('sample_swir1.rds') #> 6   load_sample_data('sample_multiband.rds') #> 7      load_sample_data('sample_points.rds') #> 8    load_sample_data('sample_boundary.rds') #> 9 load_sample_data('sample_coordinates.csv')  # Quick list datasets_simple <- list_sample_datasets(detailed = FALSE) # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_vegetation_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Get comprehensive list of available vegetation indices — list_vegetation_indices","title":"Get comprehensive list of available vegetation indices — list_vegetation_indices","text":"Returns detailed information 40+ available vegetation indices including formulas, required bands, applications, references.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_vegetation_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get comprehensive list of available vegetation indices — list_vegetation_indices","text":"","code":"list_vegetation_indices(   category = \"all\",   application = \"all\",   detailed = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_vegetation_indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get comprehensive list of available vegetation indices — list_vegetation_indices","text":"category Filter category: \"\", \"basic\", \"enhanced\", \"specialized\", \"stress\" application Filter application: \"general\", \"agriculture\", \"forestry\", \"stress\", \"water\" detailed Return detailed information including formulas references","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_vegetation_indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get comprehensive list of available vegetation indices — list_vegetation_indices","text":"Data frame vegetation index information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_vegetation_indices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get comprehensive list of available vegetation indices — list_vegetation_indices","text":"","code":"# \\donttest{ # All available indices all_indices <- list_vegetation_indices()  # Only stress detection indices stress_indices <- list_vegetation_indices(category = \"stress\")  # Detailed information with formulas detailed_info <- list_vegetation_indices(detailed = TRUE)  # Agricultural applications only ag_indices <- list_vegetation_indices(application = \"agriculture\") # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_water_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Get comprehensive list of available water indices — list_water_indices","title":"Get comprehensive list of available water indices — list_water_indices","text":"Returns detailed information available water indices including formulas, required bands, applications, interpretation guidelines.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_water_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get comprehensive list of available water indices — list_water_indices","text":"","code":"list_water_indices(detailed = FALSE, application_filter = \"all\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_water_indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get comprehensive list of available water indices — list_water_indices","text":"detailed Return detailed information including formulas applications application_filter Filter application: \"\", \"water_detection\", \"moisture_monitoring\", \"drought_assessment\"","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_water_indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get comprehensive list of available water indices — list_water_indices","text":"Data frame water index information","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/list_water_indices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get comprehensive list of available water indices — list_water_indices","text":"","code":"# \\donttest{ # All available water indices water_indices <- list_water_indices()  # Detailed information with formulas detailed_info <- list_water_indices(detailed = TRUE)  # Only water detection indices water_detection <- list_water_indices(application_filter = \"water_detection\") # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_process_spatial_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and process spatial data for interpolation — load_and_process_spatial_data","title":"Load and process spatial data for interpolation — load_and_process_spatial_data","text":"Load process spatial data interpolation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_process_spatial_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and process spatial data for interpolation — load_and_process_spatial_data","text":"","code":"load_and_process_spatial_data(spatial_data, coord_cols, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_stack_bands.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and stack individual band files — load_and_stack_bands","title":"Load and stack individual band files — load_and_stack_bands","text":"Load stack individual band files","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_stack_bands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and stack individual band files — load_and_stack_bands","text":"","code":"load_and_stack_bands(file_list, band_names = NULL, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_validate_band.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and validate spectral band — load_and_validate_band","title":"Load and validate spectral band — load_and_validate_band","text":"Load validate spectral band","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_and_validate_band.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and validate spectral band — load_and_validate_band","text":"","code":"load_and_validate_band(band_data, band_name, required = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_bands_from_directory.html","id":null,"dir":"Reference","previous_headings":"","what":"Load bands from directory — load_bands_from_directory","title":"Load bands from directory — load_bands_from_directory","text":"Load bands directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_bands_from_directory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load bands from directory — load_bands_from_directory","text":"","code":"load_bands_from_directory(directory, band_names = NULL, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Load raster data from various sources — load_raster_data","title":"Load raster data from various sources — load_raster_data","text":"Universal function load raster data files, directories, raster objects comprehensive error handling validation.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load raster data from various sources — load_raster_data","text":"","code":"load_raster_data(   input_data,   pattern = \"\\\\.(tif|tiff)$\",   recursive = FALSE,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load raster data from various sources — load_raster_data","text":"input_data Character string (path file directory), character vector file paths, SpatRaster/Raster* object pattern File pattern directory search (default: tif files) recursive Search subdirectories recursively verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load raster data from various sources — load_raster_data","text":"List terra SpatRaster objects","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load raster data from various sources — load_raster_data","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require directory structures with multiple data files # Load from directory with error handling rasters <- load_raster_data(\"/path/to/raster/files\")  # Load from file list with validation rasters <- load_raster_data(c(\"file1.tif\", \"file2.tif\")) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Load raster with error handling — load_raster_safe","title":"Load raster with error handling — load_raster_safe","text":"Load raster error handling","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load raster with error handling — load_raster_safe","text":"","code":"load_raster_safe(x, param_name = \"raster\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_safe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load raster with error handling — load_raster_safe","text":"x File path raster object param_name Parameter name error messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_raster_safe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load raster with error handling — load_raster_safe","text":"SpatRaster object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_sample_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Load sample data directly — load_sample_data","title":"Load sample data directly — load_sample_data","text":"Convenience function load sample data directly R objects. Automatically detects file type uses appropriate loading function. .rds files containing SpatRaster objects, properly unpacks PackedSpatRaster format. .csv files, uses read.csv().","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_sample_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load sample data directly — load_sample_data","text":"","code":"load_sample_data(filename, ...)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_sample_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load sample data directly — load_sample_data","text":"filename Name sample data file ... Additional arguments passed loading function","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_sample_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load sample data directly — load_sample_data","text":"Loaded data object (SpatRaster, sf, data.frame)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_sample_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load sample data directly — load_sample_data","text":"","code":"# \\donttest{ # Load raster data (returns SpatRaster) red <- load_sample_data(\"sample_red.rds\") nir <- load_sample_data(\"sample_nir.rds\") blue <- load_sample_data(\"sample_blue.rds\")  # Load vector data (returns sf object) points <- load_sample_data(\"sample_points.rds\") boundary <- load_sample_data(\"sample_boundary.rds\")  # Load CSV (returns data.frame) coords <- load_sample_data(\"sample_coordinates.csv\")  # Use loaded data ndvi <- calculate_vegetation_index(red = red, nir = nir, index_type = \"NDVI\") evi <- calculate_vegetation_index(red = red, nir = nir, blue = blue, index_type = \"EVI\") # plot(ndvi, main = \"NDVI\") # plot(evi, main = \"EVI\") # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_single_water_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Load single water quality dataset — load_single_water_dataset","title":"Load single water quality dataset — load_single_water_dataset","text":"Load single water quality dataset","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_single_water_dataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load single water quality dataset — load_single_water_dataset","text":"","code":"load_single_water_dataset(data_input, coord_cols, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_vector_data_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Load vector data safely with coordinate detection — load_vector_data_safe","title":"Load vector data safely with coordinate detection — load_vector_data_safe","text":"Load vector data safely coordinate detection Load vector data safely coordinate detection","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_vector_data_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load vector data safely with coordinate detection — load_vector_data_safe","text":"","code":"load_vector_data_safe(file_path)  load_vector_data_safe(file_path)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_vector_data_safe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load vector data safely with coordinate detection — load_vector_data_safe","text":"file_path Path vector file","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_vector_data_safe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load vector data safely with coordinate detection — load_vector_data_safe","text":"sf object sf object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_water_quality_data_flexible.html","id":null,"dir":"Reference","previous_headings":"","what":"Load water quality data with flexible format handling — load_water_quality_data_flexible","title":"Load water quality data with flexible format handling — load_water_quality_data_flexible","text":"Load water quality data flexible format handling","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/load_water_quality_data_flexible.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load water quality data with flexible format handling — load_water_quality_data_flexible","text":"","code":"load_water_quality_data_flexible(water_data, coord_cols, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/map_custom_band_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Map custom band names — map_custom_band_names","title":"Map custom band names — map_custom_band_names","text":"Map custom band names","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/map_custom_band_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map custom band names — map_custom_band_names","text":"","code":"map_custom_band_names(spectral_data, band_names, verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/mask_invalid_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask invalid values based on index type — mask_invalid_values","title":"Mask invalid values based on index type — mask_invalid_values","text":"Mask invalid values based index type","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/mask_invalid_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask invalid values based on index type — mask_invalid_values","text":"","code":"mask_invalid_values(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/mask_invalid_water_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask invalid values for water indices — mask_invalid_water_values","title":"Mask invalid values for water indices — mask_invalid_water_values","text":"Mask invalid values water indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/mask_invalid_water_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask invalid values for water indices — mask_invalid_water_values","text":"","code":"mask_invalid_water_values(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/match_rasters_by_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Match rasters by date — match_rasters_by_date","title":"Match rasters by date — match_rasters_by_date","text":"Match rasters date","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/match_rasters_by_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match rasters by date — match_rasters_by_date","text":"","code":"match_rasters_by_date(   red_data,   nir_data,   date_patterns = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/multiscale_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-scale spatial operations — multiscale_operations","title":"Multi-scale spatial operations — multiscale_operations","text":"Handle multi-scale operations including -scaling, -scaling, pyramid operations efficient processing.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/multiscale_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-scale spatial operations — multiscale_operations","text":"","code":"multiscale_operations(   spatial_data,   target_scales = c(1, 2, 4, 8),   operation = \"mean\",   pyramid = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/multiscale_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-scale spatial operations — multiscale_operations","text":"spatial_data Input spatial data target_scales Vector scale factors operation Operation perform scale pyramid Create image pyramid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/multiscale_operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-scale spatial operations — multiscale_operations","text":"List results different scales","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/multiscale_operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-scale spatial operations — multiscale_operations","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Create multi-scale analysis scales <- multiscale_operations(\"data.tif\", c(1, 2, 4, 8), \"mean\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/normalize_column_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize column names for robust matching — normalize_column_name","title":"Normalize column names for robust matching — normalize_column_name","text":"Normalize column names robust matching","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/normalize_column_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize column names for robust matching — normalize_column_name","text":"","code":"normalize_column_name(x)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_cross_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform cross-validation for interpolation accuracy — perform_cross_validation","title":"Perform cross-validation for interpolation accuracy — perform_cross_validation","text":"Perform cross-validation interpolation accuracy","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_cross_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform cross-validation for interpolation accuracy — perform_cross_validation","text":"","code":"perform_cross_validation(   spatial_sf,   target_variables,   method,   cv_folds,   power,   max_distance,   min_points,   max_points,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_extract_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform extract join (vector to raster) — perform_extract_join","title":"Perform extract join (vector to raster) — perform_extract_join","text":"Perform extract join (vector raster)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_extract_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform extract join (vector to raster) — perform_extract_join","text":"","code":"perform_extract_join(   source_info,   target_info,   summary_function,   buffer_distance,   crs_target,   na_strategy,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_overlay_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform other join methods (stubs for now) — perform_overlay_join","title":"Perform other join methods (stubs for now) — perform_overlay_join","text":"Perform join methods (stubs now)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_overlay_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform other join methods (stubs for now) — perform_overlay_join","text":"","code":"perform_overlay_join(   source_info,   target_info,   summary_function,   crs_target,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_resample_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform resample join (raster to raster) — perform_resample_join","title":"Perform resample join (raster to raster) — perform_resample_join","text":"Perform resample join (raster raster)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_resample_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform resample join (raster to raster) — perform_resample_join","text":"","code":"perform_resample_join(   source_info,   target_info,   scale_factor,   summary_function,   crs_target,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_threshold_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform threshold analysis — perform_threshold_analysis","title":"Perform threshold analysis — perform_threshold_analysis","text":"Perform threshold analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/perform_threshold_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform threshold analysis — perform_threshold_analysis","text":"","code":"perform_threshold_analysis(water_sf, variable, thresholds, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_raster_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create fast raster plot using terra — plot_raster_fast","title":"Create fast raster plot using terra — plot_raster_fast","text":"Create efficient raster plots using terra's native plotting capabilities. Fast reliable without external dependencies.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_raster_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create fast raster plot using terra — plot_raster_fast","text":"","code":"plot_raster_fast(   raster_data,   title = \"Raster Plot\",   color_scheme = \"viridis\",   region_boundary = NULL,   breaks = NULL,   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_raster_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create fast raster plot using terra — plot_raster_fast","text":"raster_data SpatRaster plot file path title Plot title color_scheme Color scheme apply region_boundary Optional boundary overlay breaks Custom breaks classification output_file Optional output file path verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_raster_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create fast raster plot using terra — plot_raster_fast","text":"NULL (plots directly device) file path saved","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_raster_fast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create fast raster plot using terra — plot_raster_fast","text":"","code":"if (FALSE) { # \\dontrun{ # These examples demonstrate workflows with user's own spatial data # Simple raster plot plot_raster_fast(ndvi_raster, \"NDVI Analysis\", \"ndvi\")  # With custom breaks and save to file plot_raster_fast(elevation, \"Elevation\", \"terrain\",                 breaks = c(0, 500, 1000, 1500, 2000),                 output_file = \"elevation_map.png\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_rgb_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create multi-band raster RGB plot — plot_rgb_raster","title":"Create multi-band raster RGB plot — plot_rgb_raster","text":"Create RGB plots multi-band rasters using terra's native RGB plotting. Reliable fast without external dependencies.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_rgb_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create multi-band raster RGB plot — plot_rgb_raster","text":"","code":"plot_rgb_raster(   raster_data,   r = 1,   g = 2,   b = 3,   stretch = \"lin\",   title = \"RGB Composite\",   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_rgb_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create multi-band raster RGB plot — plot_rgb_raster","text":"raster_data Multi-band SpatRaster file path r Red band index (default: 1) g Green band index (default: 2) b Blue band index (default: 3) stretch Stretch method: \"lin\", \"hist\", \"minmax\", \"perc\" title Plot title output_file Optional output file path verbose Print progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_rgb_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create multi-band raster RGB plot — plot_rgb_raster","text":"NULL (plots directly device) file path saved","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/plot_rgb_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create multi-band raster RGB plot — plot_rgb_raster","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # True color composite plot_rgb_raster(satellite_data, r = 3, g = 2, b = 1, title = \"True Color\")  # False color composite with histogram stretch plot_rgb_raster(landsat_data, r = 4, g = 3, b = 2, stretch = \"hist\",                title = \"False Color Composite\", output_file = \"rgb_composite.png\") } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/preview_geocoding.html","id":null,"dir":"Reference","previous_headings":"","what":"Preview geographic entity detection — preview_geocoding","title":"Preview geographic entity detection — preview_geocoding","text":"Test geographic entities detected data without actually performing geocoding. Useful debugging verification.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/preview_geocoding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preview geographic entity detection — preview_geocoding","text":"","code":"preview_geocoding(data, show_sample = TRUE, n_sample = 5)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/preview_geocoding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preview geographic entity detection — preview_geocoding","text":"data Data frame analyze show_sample Show sample values (default: TRUE) n_sample Number sample values show (default: 5)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/preview_geocoding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preview geographic entity detection — preview_geocoding","text":"List detection results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/preview_geocoding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Preview geographic entity detection — preview_geocoding","text":"","code":"if (FALSE) { # \\dontrun{ # Check what will be detected my_data <- data.frame(   HUC_8 = c(\"04100009\", \"04100012\"),   State = c(\"Ohio\", \"PA\"),   value = c(100, 200) )  preview_geocoding(my_data) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_spatial_data_safe.html","id":null,"dir":"Reference","previous_headings":"","what":"Process spatial data safely with error handling — process_spatial_data_safe","title":"Process spatial data safely with error handling — process_spatial_data_safe","text":"Process spatial data safely error handling","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_spatial_data_safe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process spatial data safely with error handling — process_spatial_data_safe","text":"","code":"process_spatial_data_safe(spatial_data, coord_cols, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_vector_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Process vector data from data frame — process_vector_data","title":"Process vector data from data frame — process_vector_data","text":"Process vector data data frame Process vector data data frame","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_vector_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process vector data from data frame — process_vector_data","text":"","code":"process_vector_data(   data_input,   coord_cols = c(\"lon\", \"lat\"),   try_geocoding = TRUE,   verbose = FALSE )  process_vector_data(   data_input,   coord_cols = c(\"lon\", \"lat\"),   try_geocoding = TRUE,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_vector_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process vector data from data frame — process_vector_data","text":"data_input Data frame potential coordinate columns geographic entities coord_cols Coordinate column names try_geocoding Attempt geocode coordinates found (default: TRUE) verbose Print messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/process_vector_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process vector data from data frame — process_vector_data","text":"sf object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_diagnostic.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick diagnostic check — quick_diagnostic","title":"Quick diagnostic check — quick_diagnostic","text":"Quick diagnostic identify might wrong package.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_diagnostic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick diagnostic check — quick_diagnostic","text":"","code":"quick_diagnostic()"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_diagnostic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick diagnostic check — quick_diagnostic","text":"List containing diagnostic results components: r_version Character string R version minimal_works Logical indicating basic functionality works function_status Logical indicating function availability status Called primarily side effects (printing diagnostic messages).","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick map function - one-line mapping with auto-detection — quick_map","title":"Quick map function - one-line mapping with auto-detection — quick_map","text":"Ultra-simple function quick spatial mapping. Auto-detects data type creates appropriate map.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick map function - one-line mapping with auto-detection — quick_map","text":"","code":"quick_map(spatial_data, variable = NULL, title = NULL, ...)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick map function - one-line mapping with auto-detection — quick_map","text":"spatial_data spatial data variable Variable visualize (optional, auto-detected) title Map title (optional) ... Additional arguments passed create_spatial_map","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick map function - one-line mapping with auto-detection — quick_map","text":"Map object","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/quick_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quick map function - one-line mapping with auto-detection — quick_map","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package quick_map(\"data.shp\") quick_map(my_raster) quick_map(points_data, interactive = TRUE) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/raster_to_raster_ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Raster to Raster Operations — raster_to_raster_ops","title":"Raster to Raster Operations — raster_to_raster_ops","text":"Specialized function mathematical overlay operations rasters. Handles alignment, projection, complex operations comprehensive error handling performance optimization.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/raster_to_raster_ops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raster to Raster Operations — raster_to_raster_ops","text":"","code":"raster_to_raster_ops(   raster1,   raster2,   operation = \"overlay\",   align_method = \"resample\",   summary_function = \"mean\",   handle_na = \"propagate\",   mask_value = NA,   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/raster_to_raster_ops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Raster to Raster Operations — raster_to_raster_ops","text":"raster1 First raster (SpatRaster file path) raster2 Second raster (SpatRaster file path) operation Character. Mathematical operation: \"add\": Add rasters (raster1 + raster2) \"subtract\": Subtract rasters (raster1 - raster2) \"multiply\": Multiply rasters (raster1 * raster2) \"divide\": Divide rasters (raster1 / raster2) \"mask\": Mask raster1 raster2 \"overlay\": Combine summary function \"difference\": Absolute difference |raster1 - raster2| \"ratio\": Ratio raster1 / raster2 (zero handling) align_method Character. align mismatched rasters: \"resample\": Resample raster2 match raster1 (default) \"crop\": Crop common extent \"extend\": Extend smaller raster match larger \"project\": Reproject raster2 raster1 CRS summary_function Character. Function overlay operation handle_na Character. handle NA values: \"propagate\": NA + value = NA (default) \"ignore\": Skip NAs calculations \"zero\": Treat NAs zero mask_value Numeric. Value use masking (default: NA) output_file Character. Optional output file path verbose Logical. Print processing details","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/raster_to_raster_ops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Raster to Raster Operations — raster_to_raster_ops","text":"SpatRaster operation results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/raster_to_raster_ops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raster to Raster Operations — raster_to_raster_ops","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Mathematical operations sum_raster <- raster_to_raster_ops(\"ndvi.tif\", \"evi.tif\", \"add\") diff_raster <- raster_to_raster_ops(\"before.tif\", \"after.tif\", \"subtract\")  # Masking operations masked <- raster_to_raster_ops(\"data.tif\", \"mask.tif\", \"mask\")  # Complex overlay with alignment overlay <- raster_to_raster_ops(   raster1 = \"fine_res.tif\",   raster2 = \"coarse_res.tif\",   operation = \"overlay\",   align_method = \"resample\",   summary_function = \"mean\",   verbose = TRUE ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_geospatial_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","title":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","text":"Execute complete geospatial analysis workflows simplified visualization. handle test cases provide robust error handling without complex dependencies.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_geospatial_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","text":"","code":"run_comprehensive_geospatial_workflow(analysis_config)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_geospatial_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","text":"analysis_config List containing analysis configuration required fields: analysis_type: \"ndvi_crop_analysis\", \"water_quality_analysis\", \"terrain_analysis\", \"temporal_analysis\", \"vegetation_comprehensive\", \"mosaic_analysis\", \"interactive_mapping\" input_data: Input data paths objects region_boundary: Region boundary specification output_folder: Output directory (optional) visualization_config: Visualization settings (optional)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_geospatial_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","text":"List containing analysis results, visualizations, summary, configuration","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_geospatial_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run comprehensive geospatial workflow - — run_comprehensive_geospatial_workflow","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Simple NDVI crop analysis workflow config <- list(   analysis_type = \"ndvi_crop_analysis\",   input_data = list(red = red_raster, nir = nir_raster),   region_boundary = \"Ohio\",   output_folder = \"results/\" ) results <- run_comprehensive_geospatial_workflow(config) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_vegetation_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run comprehensive vegetation analysis workflow - — run_comprehensive_vegetation_workflow","title":"Run comprehensive vegetation analysis workflow - — run_comprehensive_vegetation_workflow","text":"Complete vegetation analysis using multiple indices simplified processing. reliability test compatibility.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_vegetation_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run comprehensive vegetation analysis workflow - — run_comprehensive_vegetation_workflow","text":"","code":"run_comprehensive_vegetation_workflow(config, output_folder = tempdir())"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_vegetation_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run comprehensive vegetation analysis workflow - — run_comprehensive_vegetation_workflow","text":"config Analysis configuration output_folder Output directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_comprehensive_vegetation_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run comprehensive vegetation analysis workflow - — run_comprehensive_vegetation_workflow","text":"Comprehensive vegetation analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_mosaic_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run enhanced mosaic workflow — run_enhanced_mosaic_workflow","title":"Run enhanced mosaic workflow — run_enhanced_mosaic_workflow","text":"Run enhanced mosaic workflow Run enhanced mosaic workflow","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_mosaic_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run enhanced mosaic workflow — run_enhanced_mosaic_workflow","text":"","code":"run_enhanced_mosaic_workflow(config, output_folder)  run_enhanced_mosaic_workflow(config, output_folder)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_ndvi_crop_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run enhanced NDVI crop analysis workflow - — run_enhanced_ndvi_crop_workflow","title":"Run enhanced NDVI crop analysis workflow - — run_enhanced_ndvi_crop_workflow","text":"Enhanced NDVI workflow quality filtering, temporal analysis, visualization. handle test scenarios provide robust error handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_ndvi_crop_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run enhanced NDVI crop analysis workflow - — run_enhanced_ndvi_crop_workflow","text":"","code":"run_enhanced_ndvi_crop_workflow(config, output_folder = tempdir())"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_ndvi_crop_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run enhanced NDVI crop analysis workflow - — run_enhanced_ndvi_crop_workflow","text":"config Analysis configuration output_folder Output directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_ndvi_crop_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run enhanced NDVI crop analysis workflow - — run_enhanced_ndvi_crop_workflow","text":"List enhanced NDVI results visualizations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_temporal_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run enhanced temporal workflow — run_enhanced_temporal_workflow","title":"Run enhanced temporal workflow — run_enhanced_temporal_workflow","text":"Run enhanced temporal workflow Run enhanced temporal workflow","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_temporal_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run enhanced temporal workflow — run_enhanced_temporal_workflow","text":"","code":"run_enhanced_temporal_workflow(config, output_folder)  run_enhanced_temporal_workflow(config, output_folder)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_terrain_analysis_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run enhanced terrain analysis workflow — run_enhanced_terrain_analysis_workflow","title":"Run enhanced terrain analysis workflow — run_enhanced_terrain_analysis_workflow","text":"Run enhanced terrain analysis workflow Run enhanced terrain analysis workflow","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_terrain_analysis_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run enhanced terrain analysis workflow — run_enhanced_terrain_analysis_workflow","text":"","code":"run_enhanced_terrain_analysis_workflow(config, output_folder)  run_enhanced_terrain_analysis_workflow(config, output_folder)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_water_quality_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run enhanced water quality analysis workflow — run_enhanced_water_quality_workflow","title":"Run enhanced water quality analysis workflow — run_enhanced_water_quality_workflow","text":"Enhanced water quality workflow simplified visualization.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_water_quality_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run enhanced water quality analysis workflow — run_enhanced_water_quality_workflow","text":"","code":"run_enhanced_water_quality_workflow(config, output_folder = tempdir())  run_enhanced_water_quality_workflow(config, output_folder = tempdir())"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_water_quality_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run enhanced water quality analysis workflow — run_enhanced_water_quality_workflow","text":"config Analysis configuration output_folder Output directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_enhanced_water_quality_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run enhanced water quality analysis workflow — run_enhanced_water_quality_workflow","text":"Enhanced water quality analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_interactive_mapping_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run interactive mapping workflow — run_interactive_mapping_workflow","title":"Run interactive mapping workflow — run_interactive_mapping_workflow","text":"Create interactive mapping workflow multiple data types layers. Simplified reliability.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_interactive_mapping_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run interactive mapping workflow — run_interactive_mapping_workflow","text":"","code":"run_interactive_mapping_workflow(config, output_folder = tempdir())"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_interactive_mapping_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run interactive mapping workflow — run_interactive_mapping_workflow","text":"config Analysis configuration output_folder Output directory","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_interactive_mapping_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run interactive mapping workflow — run_interactive_mapping_workflow","text":"Interactive mapping results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_multi_dataset_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Run multi-dataset workflow — run_multi_dataset_workflow","title":"Run multi-dataset workflow — run_multi_dataset_workflow","text":"Run multi-dataset workflow","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/run_multi_dataset_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run multi-dataset workflow — run_multi_dataset_workflow","text":"","code":"run_multi_dataset_workflow(config, output_folder)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_interactive_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Save interactive map to file — save_interactive_map","title":"Save interactive map to file — save_interactive_map","text":"Save interactive map file","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_interactive_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save interactive map to file — save_interactive_map","text":"","code":"save_interactive_map(map_object, output_file, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_interpolation_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Save interpolation results to file — save_interpolation_results","title":"Save interpolation results to file — save_interpolation_results","text":"Save interpolation results file","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_interpolation_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save interpolation results to file — save_interpolation_results","text":"","code":"save_interpolation_results(results, output_file, output_format, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_plot_to_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Save plot to file with error handling — save_plot_to_file","title":"Save plot to file with error handling — save_plot_to_file","text":"Save plot file error handling","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_plot_to_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save plot to file with error handling — save_plot_to_file","text":"","code":"save_plot_to_file(   plot_function,   output_file,   verbose,   width = 1200,   height = 800 )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_static_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Save static map with ggplot2 — save_static_map","title":"Save static map with ggplot2 — save_static_map","text":"Save static map ggplot2","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_static_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save static map with ggplot2 — save_static_map","text":"","code":"save_static_map(plot_object, output_file, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_temporal_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Save temporal analysis results — save_temporal_results","title":"Save temporal analysis results — save_temporal_results","text":"Internal function save temporal analysis results files.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_temporal_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save temporal analysis results — save_temporal_results","text":"","code":"save_temporal_results(result, output_folder, analysis_type)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_temporal_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save temporal analysis results — save_temporal_results","text":"result Temporal analysis results output_folder Output directory analysis_type Type analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_vegetation_analysis_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Save vegetation analysis results — save_vegetation_analysis_results","title":"Save vegetation analysis results — save_vegetation_analysis_results","text":"Save vegetation analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_vegetation_analysis_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save vegetation analysis results — save_vegetation_analysis_results","text":"","code":"save_vegetation_analysis_results(   analysis_results,   vegetation_indices,   output_folder,   crop_type,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_water_quality_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Save water quality analysis results — save_water_quality_results","title":"Save water quality analysis results — save_water_quality_results","text":"Save water quality analysis results","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/save_water_quality_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save water quality analysis results — save_water_quality_results","text":"","code":"save_water_quality_results(   water_sf,   variable,   statistics,   threshold_results,   spatial_analysis,   temporal_analysis,   region_boundary,   river_network,   output_folder,   verbose )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_crop_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Select appropriate indices for crop analysis — select_crop_indices","title":"Select appropriate indices for crop analysis — select_crop_indices","text":"Select appropriate indices crop analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_crop_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select appropriate indices for crop analysis — select_crop_indices","text":"","code":"select_crop_indices(crop_type, analysis_type, growth_stage)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_optimal_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Select optimal interpolation method based on data characteristics — select_optimal_method","title":"Select optimal interpolation method based on data characteristics — select_optimal_method","text":"Select optimal interpolation method based data characteristics","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_optimal_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select optimal interpolation method based on data characteristics — select_optimal_method","text":"","code":"select_optimal_method(data_assessment, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_rasters_for_region.html","id":null,"dir":"Reference","previous_headings":"","what":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","title":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","text":"Intelligently select raster files overlap specified region. ASTER files (GDEM WBD), uses filename-based coordinate extraction fast filtering without loading full rasters.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_rasters_for_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","text":"","code":"select_rasters_for_region(   input_folder,   region_boundary,   overlap = TRUE,   buffer_size = 0.1 )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_rasters_for_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","text":"input_folder Directory containing raster files region_boundary Region boundary bounding box overlap Logical. TRUE (default), checks actual overlap region. FALSE, includes tiles whose centroid falls within region. applies ASTER files; non-ASTER files always use overlap detection. buffer_size Buffer around region (degrees)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_rasters_for_region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","text":"Character vector relevant file paths","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/select_rasters_for_region.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select rasters for specific region with intelligent filtering — select_rasters_for_region","text":"","code":"# \\donttest{ # Select ASTER files for Michigan using overlap detection michigan_files <- select_rasters_for_region(\"/aster/files\", \"Michigan\") #> Selecting rasters for specified region... #> Selected 0 files out of 0 for the specified region  # Use centroid-based selection (faster, fewer tiles) michigan_files_centroid <- select_rasters_for_region(\"/aster/files\", \"Michigan\",                                                        overlap = FALSE) #> Selecting rasters for specified region... #> Selected 0 files out of 0 for the specified region  # Select with custom buffer nevada_files <- select_rasters_for_region(\"/data\", \"Nevada\", buffer_size = 0.2) #> Selecting rasters for specified region... #> Selected 0 files out of 0 for the specified region # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","title":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","text":"Simplified version spatial interpolation maintaining backward compatibility. new projects, use spatial_interpolation_comprehensive() instead.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","text":"","code":"spatial_interpolation(   spatial_data,   target_variables,   method = \"NN\",   power = 2,   mice_method = \"pmm\" )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","text":"spatial_data sf object missing values target_variables Variables interpolate method Interpolation method: \"NN\", \"simple\", \"mice\" power Power parameter simple method (default: 2) mice_method MICE method multivariate imputation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","text":"sf object interpolated values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Legacy spatial interpolation function (for backward compatibility) — spatial_interpolation","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Simple interpolation (legacy interface) interpolated_data <- spatial_interpolation(   soil_data,   target_variables = c(\"nitrogen\", \"carbon\"),   method = \"NN\" ) } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"Perform spatial interpolation using reliable methods fill missing values spatial datasets. Supports nearest neighbor, spline interpolation, multivariate imputation comprehensive error handling.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"","code":"spatial_interpolation_comprehensive(   spatial_data,   target_variables,   method = \"NN\",   target_grid = NULL,   region_boundary = NULL,   power = 2,   max_distance = Inf,   min_points = 3,   max_points = 50,   cross_validation = FALSE,   cv_folds = 5,   handle_outliers = \"none\",   outlier_threshold = 3,   coord_cols = c(\"lon\", \"lat\"),   mice_method = \"pmm\",   mice_iterations = 10,   output_format = \"sf\",   output_file = NULL,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"spatial_data Spatial data interpolate. Can : sf object point geometries data.frame coordinate columns File path spatial data (CSV, SHP, GeoJSON) target_variables Character vector variables interpolate method Interpolation method: \"NN\": Nearest neighbor (default) \"simple\": Simple distance weighting \"spline\": Thin plate spline interpolation \"mice\": Multivariate imputation (requires mice package) \"auto\": Automatically select best method based data target_grid Target grid interpolation. Can : SpatRaster template raster output sf object target locations NULL point--point interpolation region_boundary Optional region boundary clipping results power Power parameter simple distance weighting (default: 2) max_distance Maximum distance interpolation (map units) min_points Minimum number points interpolation max_points Maximum number points use prediction cross_validation Perform cross-validation accuracy assessment cv_folds Number folds cross-validation (default: 5) handle_outliers Method outlier handling: \"none\", \"remove\", \"cap\" outlier_threshold Z-score threshold outlier detection (default: 3) coord_cols Coordinate column names data.frame input mice_method MICE method multivariate imputation mice_iterations Number MICE iterations (default: 10) output_format Output format: \"sf\", \"raster\", \"\" output_file Optional output file path verbose Print detailed progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"Depending output_format: \"sf\" sf object interpolated values \"raster\" SpatRaster interpolated surfaces \"\" List containing sf raster results Additional attributes include: interpolation_info: Method used, parameters, processing time cross_validation: CV results performed","code":""},{"path":[]},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"distance-based-methods-","dir":"Reference","previous_headings":"","what":"Distance-Based Methods:","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"NN (Nearest Neighbor): Assigns nearest known value - Best : Categorical data preserving exact values - Fast creates Voronoi-like patterns - assumptions data distribution Simple (Simple distance weighting): Basic distance-based averaging - Best : Quick estimates minimal computation - Uses inverse distance weighting without external dependencies","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"statistical-methods-","dir":"Reference","previous_headings":"","what":"Statistical Methods:","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"Spline: Smooth surface interpolation using thin plate splines - Best : Smooth, continuous phenomena - Creates smooth surfaces without sharp changes - Good environmental data gradual spatial variation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"multivariate-methods-","dir":"Reference","previous_headings":"","what":"Multivariate Methods:","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"MICE: Multivariate imputation chained equations - Best : Multiple correlated variables missing values - Handles complex missing data patterns - Preserves relationships variables - Requires mice package","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"input-data-support-","dir":"Reference","previous_headings":"","what":"Input Data Support:","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"sf objects point geometries data.frame coordinate columns File paths (CSV, shapefile, GeoJSON) Target grids raster output","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"quality-control-features-","dir":"Reference","previous_headings":"","what":"Quality Control Features:","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"Cross-validation method comparison Outlier detection handling Performance metrics calculation Robust error handling","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"method-selection-guide","dir":"Reference","previous_headings":"","what":"Method Selection Guide","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"Dense, regular data Simple distance weighting good balance Sparse, irregular data Nearest neighbor stability Environmental data Spline smooth surfaces Categorical data Nearest neighbor Multiple correlated variables MICE multivariate patterns Unknown data characteristics Auto-selection based data properties","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"performance-optimization","dir":"Reference","previous_headings":"","what":"Performance Optimization","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"large datasets: Set max_points=50-100 faster processing high accuracy: Use cross_validation=TRUE compare methods memory efficiency: Process variables individually smooth results: Use spline method","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/spatial_interpolation_comprehensive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform spatial interpolation for missing data — spatial_interpolation_comprehensive","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require external data files not included with the package # Basic nearest neighbor interpolation soil_interpolated <- spatial_interpolation_comprehensive(   spatial_data = \"soil_samples.csv\",   target_variables = c(\"nitrogen\", \"phosphorus\", \"ph\"),   method = \"NN\",   target_grid = study_area_grid,   region_boundary = \"Iowa\" )  # Simple distance weighting temp_interp <- spatial_interpolation_comprehensive(   spatial_data = weather_stations,   target_variables = \"temperature\",   method = \"simple\",   power = 2,   cross_validation = TRUE,   verbose = TRUE )  # Multivariate imputation for environmental data env_imputed <- spatial_interpolation_comprehensive(   spatial_data = env_monitoring,   target_variables = c(\"temp\", \"humidity\", \"pressure\", \"wind_speed\"),   method = \"mice\",   mice_iterations = 15,   handle_outliers = \"cap\" )  # Auto-method selection with comparison best_interp <- spatial_interpolation_comprehensive(   spatial_data = precipitation_data,   target_variables = \"annual_precip\",   method = \"auto\",   cross_validation = TRUE,   cv_folds = 10,   target_grid = dem_template )  # Access results and diagnostics plot(best_interp)  # Plot interpolated surface best_interp$cross_validation$rmse  # Cross-validation RMSE best_interp$interpolation_info$method_selected  # Method chosen } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_function_availability.html","id":null,"dir":"Reference","previous_headings":"","what":"Test individual function existence — test_function_availability","title":"Test individual function existence — test_function_availability","text":"Helper function test core functions exist callable.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_function_availability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test individual function existence — test_function_availability","text":"","code":"test_function_availability(verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_function_availability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test individual function existence — test_function_availability","text":"verbose Print detailed messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_function_availability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test individual function existence — test_function_availability","text":"List function availability","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_geospatialsuite_package_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","title":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","text":"Simplified testing function focuses core functionality minimal dependencies robust error handling. Designed 100% success rate. replaces complex testing function simple, reliable tests.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_geospatialsuite_package_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","text":"","code":"test_geospatialsuite_package_simple(   test_output_dir = tempdir(),   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_geospatialsuite_package_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","text":"test_output_dir Directory test outputs (default: tempdir()) verbose Print detailed test progress messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_geospatialsuite_package_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","text":"List test results success/failure status component","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_geospatialsuite_package_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test geospatialsuite with simplified, robust tests — test_geospatialsuite_package_simple","text":"","code":"# \\donttest{ # Quick test (essential functions only) test_results <- test_geospatialsuite_package_simple() #> Testing geospatialsuite v0.1.0 - Simplified Tests #> ==============================================  #>  #>  SIMPLIFIED TEST SUMMARY #> ==================== #> Tests passed: 8/8 (100.0%) #> Duration: 0.32 seconds #>  #>  ALL TESTS PASSED! geospatialsuite is working correctly. #> Core functionality verified #>  Reliable terra-based operations #> Simple, robust implementation  # Verbose test test_results <- test_geospatialsuite_package_simple(verbose = TRUE) #> Testing geospatialsuite v0.1.0 - Simplified Tests #> ============================================== #>  #>  Testing basic NDVI calculation... #>  Basic NDVI calculation working #>  #>  Testing water index calculation... #>  Water index calculation working #>  #>  Testing basic visualization...  #>  Basic visualization working #>  #>  Testing multiple indices calculation... #>  Multiple indices calculation working #>  #>  Testing enhanced NDVI... #>  Enhanced NDVI calculation working #>  #>  Testing core dependencies... #> Core dependencies: #>    terra #>    sf #>    dplyr #>  All core dependencies available #>  #>  Testing basic spatial operations... #>  Basic spatial operations working #>  #>  Testing data loading utilities... #>  Data loading utilities working #>  #>  SIMPLIFIED TEST SUMMARY #> ==================== #> Tests passed: 8/8 (100.0%) #> Duration: 0.31 seconds #>  #> Detailed Results: #>   basic_ndvi_test: PASS #>   water_index_test: PASS #>   basic_visualization_test: PASS #>   multiple_indices_simple_test: PASS #>   enhanced_ndvi_simple_test: PASS #>   dependencies_test: PASS #>   spatial_operations_test: PASS #>   data_loading_test: PASS #>  #>  ALL TESTS PASSED! geospatialsuite is working correctly. #> Core functionality verified #>  Reliable terra-based operations #> Simple, robust implementation # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_package_minimal.html","id":null,"dir":"Reference","previous_headings":"","what":"Test package with minimal complexity — test_package_minimal","title":"Test package with minimal complexity — test_package_minimal","text":"Ultra-minimal test checks basic functionality. Designed always pass package minimally functional.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_package_minimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test package with minimal complexity — test_package_minimal","text":"","code":"test_package_minimal(verbose = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_package_minimal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test package with minimal complexity — test_package_minimal","text":"verbose Print messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/test_package_minimal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test package with minimal complexity — test_package_minimal","text":"Logical indicating basic functionality","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Universal Spatial Join - Complete Implementation — universal_spatial_join","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"Comprehensive spatial join system handles spatial data combinations: Vector Vector, Vector Raster, Raster Raster full documentation, error handling, extensive examples. replaces previous spatial join functions unified, robust system.","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"","code":"universal_spatial_join(   source_data,   target_data,   method = \"auto\",   scale_factor = NULL,   summary_function = \"mean\",   buffer_distance = NULL,   temporal_tolerance = NULL,   crs_target = NULL,   na_strategy = \"remove\",   chunk_size = 1e+06,   parallel = FALSE,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"source_data Source spatial data. Can : File path: \"/path//data.tif\" \"/path//data.shp\" Directory: \"/path//spatial_files/\" (processes spatial files) R object: SpatRaster, sf object, data.frame coordinates List: Multiple files, raster stack, sf objects target_data Target spatial data (format options source_data). Can NULL scaling operations scale_factor. method Spatial join method: \"auto\": Automatically detect best method (default) \"extract\": Extract raster values vector features \"overlay\": Spatial intersection/overlay vectors \"resample\": Resample raster match target geometry \"zonal\": Calculate zonal statistics (raster â†’ vector) \"nearest\": Nearest neighbor spatial join \"interpolate\": Spatial interpolation (IDW, kriging) \"temporal\": Time-aware spatial join scale_factor Numeric (> 0 provided). Scale factor resolution changes: NULL: Use target data resolution (default) > 1: Coarser resolution (e.g., 2 = half resolution) < 1: Finer resolution (e.g., 0.5 = double resolution) Custom: positive number specific scaling summary_function Character. Function aggregating overlapping values: \"mean\": Average values (default continuous data) \"median\": Median values (robust outliers) \"max\"/\"min\": Maximum/minimum values \"sum\": Sum values (useful counts, areas) \"sd\": Standard deviation (measure variability) \"mode\"/\"majority\": frequent value (categorical data) buffer_distance Numeric (>= 0 provided). Buffer distance map units: point extraction: Buffer around points line extraction: Buffer along lines nearest neighbor: Search radius Units: source data CRS (meters, degrees, etc.) temporal_tolerance Numeric (>= 0 provided). Time tolerance temporal joins (days): Maximum time difference matching observations used method = \"temporal\" Example: 7 = match within 7 days crs_target Character numeric. Target coordinate reference system: EPSG code: 4326, 3857, etc. PROJ string: \"+proj=utm +zone=33 +datum=WGS84\" NULL: Use source data CRS (default) na_strategy Character. Strategy handling NA values: \"remove\": Keep NAs missing (default) \"nearest\": Replace nearest neighbor value \"interpolate\": Spatial interpolation NAs \"zero\": Replace NAs zero chunk_size Numeric (> 0). Chunk size processing large datasets: Number features/cells process Larger = faster memory Smaller = slower less memory Default: 1,000,000 parallel Logical. Use parallel processing: TRUE: Use multiple cores (faster large data) FALSE: Single core processing (default) Requires 'parallel' package verbose Logical. Print detailed progress messages: TRUE: Show processing steps diagnostics FALSE: Silent processing (default)","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"Spatial data object joined attributes. Return type depends operation: extract (vector â†’ raster) sf object new columns containing extracted raster values. Original geometry preserved, new columns named \"extracted_\" followed raster layer name zonal (raster â†’ vector) sf object new columns containing zonal statistics. Original geometry preserved, new columns named \"zonal_\" followed statistic name raster layer name resample (raster â†’ raster) SpatRaster resampled/processed data matching target resolution scale factor overlay (vector â†’ vector) sf object intersected/overlaid features combining attributes datasets nearest sf object attributes nearest features joined Returned objects include 'spatial_join_info' attribute containing: method: Join method used source_type, target_type: Data types processed processing_time: Time taken (verbose=TRUE) timestamp: Processing timestamp summary_function: Aggregation function used","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"quick-start-guide-","dir":"Reference","previous_headings":"","what":"Quick Start Guide:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"common use case - extract raster values point locations:","code":"result <- universal_spatial_join(\"my_points.csv\", \"my_raster.tif\", method=\"extract\")"},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"data-type-combinations-","dir":"Reference","previous_headings":"","what":"Data Type Combinations:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"Vector â†’ Raster: Extract raster values points/polygons/lines Raster â†’ Vector: Calculate zonal statistics polygons Raster â†’ Raster: Resample, overlay, mathematical operations Vector â†’ Vector: Spatial intersections, overlays, nearest neighbor","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"input-format-support-","dir":"Reference","previous_headings":"","what":"Input Format Support:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"File paths: \".tif\", \".shp\", \".gpkg\", \".geojson\", \".nc\" Directories: Automatically processes spatial files R objects: SpatRaster, sf, data.frame coordinates Lists: Multiple files raster stacks","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"scaling-operations-","dir":"Reference","previous_headings":"","what":"Scaling Operations:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"-scaling: Aggregate coarser resolution (scale_factor > 1) -scaling: Interpolate finer resolution (scale_factor < 1) Custom resolution: Match target raster geometry","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"error-handling-","dir":"Reference","previous_headings":"","what":"Error Handling:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"Auto CRS reprojection: Handles coordinate system mismatches Geometry alignment: Auto-crops, extends, resamples needed NA handling: Multiple strategies missing data Memory management: Chunked processing large datasets","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"method-selection-guide-","dir":"Reference","previous_headings":"","what":"Method Selection Guide:","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"extract Use point/polygon locations want get values raster zonal Use polygons want statistics raster data within polygon resample Use need change raster resolution align two rasters overlay Use joining two vector datasets based spatial relationships nearest Use want find closest features two vector datasets auto Let function choose - works well standard extract/resample operations","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"common-error-solutions","dir":"Reference","previous_headings":"","what":"Common Error Solutions","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"CRS Mismatch \"CRS mismatch detected\" - Function automatically reprojects data, manual CRS checking recommended precision Memory Issues \"Large dataset processing\" - Reduce chunk_size parameter (try 500000) set parallel=FALSE Spatial Overlap \"spatial overlap found\" - Check source target data cover geographic area File Found \"File exist\" - Verify file paths ensure files exist specified locations Missing Bands \"Required bands found\" - raster operations, ensure expected spectral bands present Invalid Geometries \"Geometry errors\" - Function attempts fix automatically, check input data quality","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"performance-tips","dir":"Reference","previous_headings":"","what":"Performance Tips","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"large datasets (>1M cells): set chunk_size=500000 parallel=TRUE Use method=\"resample\" scale_factor > 1 reduce data size complex operations time series analysis: consider temporal_tolerance balance accuracy vs processing speed processing multiple datasets: ensure consistent CRS avoid reprojection overhead point extraction: use smaller buffer_distance possible reduce processing time","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/universal_spatial_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Universal Spatial Join - Complete Implementation — universal_spatial_join","text":"","code":"if (FALSE) { # \\dontrun{ # These examples require satellite imagery files (Landsat/Sentinel data etc.) # ================================================================= # MOST COMMON USE CASE: Extract raster values to CSV points # =================================================================  # Your typical workflow: CSV file with coordinates + raster file results <- universal_spatial_join(   source_data = \"my_field_sites.csv\",    # CSV with lon, lat columns   target_data = \"satellite_image.tif\",   # Any raster file   method = \"extract\",                     # Extract raster values to points   buffer_distance = 100,                  # 100m buffer around each point   summary_function = \"mean\",              # Average within buffer   verbose = TRUE                          # See what's happening )  # Check results - original data + new columns with raster values head(results) #   site_id       lon       lat           geometry extracted_satellite_image # 1       1 -83.12345  40.12345 POINT (-83.1 40.1)                   0.752 # 2       2 -83.23456  40.23456 POINT (-83.2 40.2)                   0.681 # 3       3 -83.34567  40.34567 POINT (-83.3 40.3)                   0.594  # Access the extracted values results$extracted_satellite_image  # ================================================================= # ZONAL STATISTICS: Calculate statistics by polygon areas # =================================================================  # Calculate average precipitation by watershed watershed_precip <- universal_spatial_join(   source_data = \"precipitation_raster.tif\",  # Raster data   target_data = \"watershed_boundaries.shp\",  # Polygon boundaries   method = \"zonal\",                           # Calculate zonal statistics   summary_function = \"mean\",                  # Average precipitation per watershed   verbose = TRUE )  # Result: polygons with precipitation statistics head(watershed_precip) #   watershed_id                     geometry zonal_mean_precipitation_raster # 1            1 POLYGON ((-84.2 40.1, ...))                             42.3 # 2            2 POLYGON ((-84.5 40.3, ...))                             38.7  # ================================================================= # RESAMPLE RASTER: Change resolution or align rasters # =================================================================  # Aggregate 30m Landsat to 250m MODIS resolution landsat_resampled <- universal_spatial_join(   source_data = \"landsat_30m.tif\",      # High resolution input   target_data = \"modis_250m.tif\",       # Target resolution template   method = \"resample\",                   # Resample operation   summary_function = \"mean\",             # Average when aggregating   verbose = TRUE )  # Check new resolution terra::res(landsat_resampled) # [1] 250 250  # Scale by factor instead of template coarser_raster <- universal_spatial_join(   source_data = \"fine_resolution.tif\",   target_data = NULL,                    # No template needed   method = \"resample\",   scale_factor = 5,                      # 5x coarser resolution   summary_function = \"mean\" )  # ================================================================= # VECTOR OVERLAY: Join two vector datasets # =================================================================  # Find which counties contain each field site sites_with_counties <- universal_spatial_join(   source_data = \"field_sites.shp\",      # Point data   target_data = \"county_boundaries.shp\", # Polygon data   method = \"overlay\",                     # Spatial intersection   verbose = TRUE )  # Result: points with county attributes added head(sites_with_counties) #   site_id           geometry county_name state_name # 1       1 POINT (-83.1 40.1)    Franklin       Ohio # 2       2 POINT (-83.2 40.2)    Delaware       Ohio  # ================================================================= # AUTO-DETECTION: Let function choose best method # =================================================================  # Function automatically detects: points + raster = extract method auto_result <- universal_spatial_join(   source_data = my_points,               # Any point data   target_data = my_raster,               # Any raster data   method = \"auto\",                       # Automatically choose method   verbose = TRUE                         # See what method was chosen ) # Output: \"Auto-detected method: extract for vector to raster\"  # ================================================================= # ERROR HANDLING EXAMPLES # =================================================================  # Function handles common issues automatically robust_result <- universal_spatial_join(   source_data = \"points_wgs84.csv\",     # WGS84 coordinate system   target_data = \"raster_utm.tif\",       # UTM coordinate system   method = \"extract\",   na_strategy = \"nearest\",               # Handle missing values   verbose = TRUE                         # See CRS handling messages ) # Output: \"CRS mismatch detected. Reprojecting to match raster CRS...\" } # }"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate method parameter — validate_method","title":"Validate method parameter — validate_method","text":"Validate method parameter","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate method parameter — validate_method","text":"","code":"validate_method(method, valid_methods, param_name = \"method\")"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate method parameter — validate_method","text":"method Method validate valid_methods Vector valid methods param_name Parameter name error messages","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate method parameter — validate_method","text":"TRUE valid, stops error invalid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method_compatibility.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate method compatibility — validate_method_compatibility","title":"Validate method compatibility — validate_method_compatibility","text":"Validate method compatibility","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method_compatibility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate method compatibility — validate_method_compatibility","text":"","code":"validate_method_compatibility(method, source_type, target_type)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_method_compatibility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate method compatibility — validate_method_compatibility","text":"method Selected method source_type Source data type target_type Target data type","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_numeric_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate numeric range — validate_numeric_range","title":"Validate numeric range — validate_numeric_range","text":"Validate numeric range","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_numeric_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate numeric range — validate_numeric_range","text":"","code":"validate_numeric_range(   x,   min_val = NULL,   max_val = NULL,   param_name = \"parameter\",   allow_null = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_numeric_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate numeric range — validate_numeric_range","text":"x Numeric value validate min_val Minimum allowed value max_val Maximum allowed value param_name Parameter name error messages allow_null Allow NULL values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_numeric_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate numeric range — validate_numeric_range","text":"TRUE valid, stops error invalid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate output quality — validate_output","title":"Validate output quality — validate_output","text":"Validate output quality","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate output quality — validate_output","text":"","code":"validate_output(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_raster_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate raster input — validate_raster_input","title":"Validate raster input — validate_raster_input","text":"Validate raster input","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_raster_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate raster input — validate_raster_input","text":"","code":"validate_raster_input(x, param_name = \"raster_data\", allow_null = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_raster_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate raster input — validate_raster_input","text":"x Input validate param_name Parameter name error messages allow_null Allow NULL values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_raster_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate raster input — validate_raster_input","text":"TRUE valid, stops error invalid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_required_bands.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate required bands for specific indices — validate_required_bands","title":"Validate required bands for specific indices — validate_required_bands","text":"Validate required bands specific indices","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_required_bands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate required bands for specific indices — validate_required_bands","text":"","code":"validate_required_bands(   index_type,   blue,   green,   swir1,   swir2,   red_edge,   coastal,   nir2,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vector_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate vector input — validate_vector_input","title":"Validate vector input — validate_vector_input","text":"Validate vector input","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vector_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate vector input — validate_vector_input","text":"","code":"validate_vector_input(x, param_name = \"vector_data\", allow_null = FALSE)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vector_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate vector input — validate_vector_input","text":"x Input validate param_name Parameter name error messages allow_null Allow NULL values","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vector_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate vector input — validate_vector_input","text":"TRUE valid, stops error invalid","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vegetation_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate vegetation analysis — validate_vegetation_analysis","title":"Validate vegetation analysis — validate_vegetation_analysis","text":"Validate vegetation analysis","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_vegetation_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate vegetation analysis — validate_vegetation_analysis","text":"","code":"validate_vegetation_analysis(   vegetation_indices,   reference_data,   verbose = FALSE )"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_water_index_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate water index output — validate_water_index_output","title":"Validate water index output — validate_water_index_output","text":"Validate water index output","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validate_water_index_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate water index output — validate_water_index_output","text":"","code":"validate_water_index_output(index, index_type, verbose)"},{"path":"https://exelegch.github.io/geospatialsuite-docs/reference/validation-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Input Validation Helpers — validation-helpers","title":"Input Validation Helpers — validation-helpers","text":"Internal validation functions robust parameter checking","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"geospatialsuite-011","dir":"Changelog","previous_headings":"","what":"geospatialsuite 0.1.1","title":"geospatialsuite 0.1.1","text":"CRAN release: 2025-11-05","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"working-examples-and-sample-data-0-1-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Working Examples and Sample Data","title":"geospatialsuite 0.1.1","text":"sample_red.rds, sample_nir.rds, sample_blue.rds - Spectral bands sample_green.rds, sample_swir1.rds - Additional bands sample_multiband.rds - Multi-band stack auto-detection examples sample_points.shp - Sample field locations sample_boundary.shp - Study area polygon sample_coordinates.csv - Tabular data coordinates New download_sample_data() function accessing sample data New get_sample_data() helper get file paths New list_sample_datasets() browse available datasets New load_sample_data() convenience function load data directly README examples now work ---box vignettes updated working code using sample data function examples (.Rd files) updated use built-data","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"testing-improvements-0-1-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Testing Improvements","title":"geospatialsuite 0.1.1","text":"Fixed EVI calculation warnings test suite Tests now provide required bands (red, nir, blue) EVI Separated EVI tests general vegetation index tests Improved test coverage: 68 → 70+ tests","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"documentation-enhancements-0-1-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Documentation Enhancements","title":"geospatialsuite 0.1.1","text":"Created pkgdown website easy navigation Organized 185 functions 10 logical categories Comprehensive vignettes rendered searchable Consistent package naming (geospatialsuite) across documentation Enhanced function documentation working examples Fixed encoding issues vignettes (special characters now display correctly) Removed unnecessary preambles vignettes cleaner presentation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"package-structure-0-1-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Package Structure","title":"geospatialsuite 0.1.1","text":"Added R/16-data-download.R data access functions Added sample data infrastructure inst/extdata/ Added _pkgdown.yml website configuration Improved test utilities helper functions","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"bug-fixes-0-1-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"geospatialsuite 0.1.1","text":"Fixed test warnings related EVI calculations Improved error handling edge cases Enhanced validation spectral band inputs Fixed special character encoding vignettes documentation","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"documentation-0-1-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"geospatialsuite 0.1.1","text":"examples now executable without external dependencies Vignettes demonstrate real-world workflows sample data README provides quick-start guide working code Function reference organized category pkgdown site Improved vignette readability better structure formatting","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"geospatialsuite-010","dir":"Changelog","previous_headings":"","what":"geospatialsuite 0.1.0","title":"geospatialsuite 0.1.0","text":"CRAN release: 2025-09-16","code":""},{"path":[]},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"core-features-0-1-0","dir":"Changelog","previous_headings":"Initial CRAN Release","what":"Core Features","title":"geospatialsuite 0.1.0","text":"60+ vegetation indices automatic satellite band detection Universal spatial join operations raster-vector combination Robust raster visualization built-error handling Water quality analysis multiple indices (NDWI, MNDWI, NDMI) Crop Data Layer (CDL) analysis crop-specific assessments Spatial interpolation techniques (IDW, Kriging, splines) Terrain analysis capabilities Temporal analysis change detection Comprehensive workflow functions","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"visualization-0-1-0","dir":"Changelog","previous_headings":"Initial CRAN Release","what":"Visualization","title":"geospatialsuite 0.1.0","text":"quick_map() one-line mapping auto-detection create_spatial_map() publication-quality maps Support leaflet interactive maps Multiple color schemes different applications","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"data-integration-0-1-0","dir":"Changelog","previous_headings":"Initial CRAN Release","what":"Data Integration","title":"geospatialsuite 0.1.0","text":"Universal region support (US states, countries, custom boundaries) Automatic CRS handling transformation Multi-dataset integration capabilities Robust error handling throughout","code":""},{"path":"https://exelegch.github.io/geospatialsuite-docs/news/index.html","id":"documentation-0-1-0","dir":"Changelog","previous_headings":"Initial CRAN Release","what":"Documentation","title":"geospatialsuite 0.1.0","text":"Comprehensive vignettes covering major use cases 165+ documented functions Real-world examples case studies Extensive testing suite","code":""}]
